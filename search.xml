<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>进制转化题目总结</title>
      <link href="/2020/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tPage=1" target="_blank" rel="noopener">二进制中1的个数</a></h3><blockquote><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p></blockquote><p>假设n为13二进制为</p><p>1011        1011       1011        1011</p><p>0001左移0010左移0100左移1000</p><p>0001        0010       0000        1000</p><p>这样可求得1的个数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">0</span>)&#123;<span class="comment">//flag == 0表示遍历完int类型二进制表示的所有位了</span></span><br><span class="line">            <span class="keyword">if</span>((n &amp; flag)!=<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微预约小程序</title>
      <link href="/2020/06/05/%E9%A1%B9%E7%9B%AE/%E5%BE%AE%E9%A2%84%E7%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/06/05/%E9%A1%B9%E7%9B%AE/%E5%BE%AE%E9%A2%84%E7%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4><p>稳定版 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html" target="_blank" rel="noopener">Stable Build</a> (1.03.2005140)</p><p><a href="https://github.com/weilanwl/ColorUI" target="_blank" rel="noopener">ColorUI</a> 2.1.6</p><p><a href="https://weapp.iviewui.com/docs/guide/update" target="_blank" rel="noopener">iView</a> Weapp 2.0.0</p><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>SpringBoot 2.3.1</p><p>mysql 5.6</p><p>Ubuntu 18.04</p><h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><h4 id="1-1-客户端1——业务预约Web端"><a href="#1-1-客户端1——业务预约Web端" class="headerlink" title="1.1 客户端1——业务预约Web端"></a>1.1 客户端1——业务预约Web端</h4><p>将不同的可预约业务展示在web端，用户根据需求，选择业务类型和时间，用户输入身份证号、手机号后即可预约成功。同时，可在界面上显示已预约的人数、余号数量等，</p><h4 id="1-2-客户端2——模拟现场取号设备"><a href="#1-2-客户端2——模拟现场取号设备" class="headerlink" title="1.2 客户端2——模拟现场取号设备"></a>1.2 客户端2——模拟现场取号设备</h4><p>该设备具有预约取号和现场取号两大功能。</p><p>预约取号时要求输入身份证号码，如系统匹配成功，则显示办事编号，否则显示无预约等信息。</p><p>现场取号功能与客户端1的预约功能基本相同，但只需选择业务类型，无需选择时间，按系统默认分配办事编号。</p><h4 id="1-3-服务器端"><a href="#1-3-服务器端" class="headerlink" title="1.3 服务器端"></a>1.3 服务器端</h4><p>搭建Web服务器、数据库，并做好数据库表的设计，支持多线程。</p><p>将客户端1传输过来的预约信息存储至数据库中。</p><p>客户端2预约取号时，验证数据信息请求，决定是否有办事编号，并将相应信息显示在客户端2中，现场取号同理。</p><h3 id="二、数据库设计"><a href="#二、数据库设计" class="headerlink" title="二、数据库设计"></a>二、数据库设计</h3><h4 id="2-1-业务表"><a href="#2-1-业务表" class="headerlink" title="2.1 业务表"></a>2.1 业务表</h4><p>业务表包含id、服务名、已预约人数、剩余数量字段组成。4个业务，医社保办理、护照通行证办理、房产证办理、水电煤气业务办理；每个业务初始化总数量为50个</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610150019.png"  alt=""></p><h4 id="2-2-预定表"><a href="#2-2-预定表" class="headerlink" title="2.2 预定表"></a>2.2 预定表</h4><p>预定表包含id、身份证号、电话号码、服务类别id、预定取票时间、办事编号字段组成。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610150215.png"  alt=""></p><h4 id="2-3-用户表"><a href="#2-3-用户表" class="headerlink" title="2.3 用户表"></a>2.3 用户表</h4><p>用户表包含id、用户名、身份证号、电话号码字段。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610150700.png"  alt=""></p><h3 id="三、详细设计"><a href="#三、详细设计" class="headerlink" title="三、详细设计"></a>三、详细设计</h3><h4 id="3-1-预约功能"><a href="#3-1-预约功能" class="headerlink" title="3.1 预约功能"></a>3.1 预约功能</h4><p>用户选择具体的要办理的业务类型，在业务详情页显示当前预约人数，以及预约表单，当余号数量足够时可进行提交表单，余量不足时则表单提交失败。前端发送身份证号、电话号码、以及预约的日期时间；后端收到请求后，将记录存入数据库，同时也会以预约的时间生成办事编号。</p><p><strong>接口</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610154053.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610155229.png"  alt=""></p><h4 id="3-2-取号功能"><a href="#3-2-取号功能" class="headerlink" title="3.2 取号功能"></a>3.2 取号功能</h4><h5 id="3-2-1-预约取号"><a href="#3-2-1-预约取号" class="headerlink" title="3.2.1 预约取号"></a>3.2.1 预约取号</h5><p>用户输入身份证即可获取之前预约的记录。前端携带业务类型、用户身份证号发请求至后端，后端通过取号类型得知是预约取号，则从数据库中通过身份证号查出记录，再返回给前端；返回结果包含办事编号（预约时存入）。</p><h5 id="3-2-2-现场取号"><a href="#3-2-2-现场取号" class="headerlink" title="3.2.2 现场取号"></a>3.2.2 现场取号</h5><p>用户选择要办理的业务类型即可获取记录。前端携带业务类型id与取号类型发送请求至后端，后端判断是现场取号后，不用从数据库中读取数据，直接以当前时间生成办事编号，发送给前端。</p><p><strong>接口</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610155925.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610155955.png"  alt=""></p><h4 id="3-3-预约记录"><a href="#3-3-预约记录" class="headerlink" title="3.3 预约记录"></a>3.3 预约记录</h4><p>用户可查看自己预约的记录，包含预约编号、预约的身份证号码、预定取票时间信息。当预约成功或取票成功，预约历史页下拉刷新即可看到变化。</p><p><strong>接口</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610160452.png"  alt=""></p><h3 id="四、演示"><a href="#四、演示" class="headerlink" title="四、演示"></a>四、演示</h3><h4 id="4-1-预约客户端"><a href="#4-1-预约客户端" class="headerlink" title="4.1 预约客户端"></a>4.1 预约客户端</h4><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610143821.png"  style="zoom: 50%;" /><p>点击要办理的具体业务，顶部会显示业务类型、已预约人数、余票，余票数量为0则不可再进行预约</p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610144123.png"  style="zoom:50%;" /><p>余量充足的情况下可进行预约，并得到预约编号</p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610144243.png"  style="zoom:50%;" /><h4 id="4-2-预约历史"><a href="#4-2-预约历史" class="headerlink" title="4.2 预约历史"></a>4.2 预约历史</h4><p>点击底部菜单最右边可查看预约历史</p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610144400.png"  style="zoom:50%;" /><h4 id="4-3-取票客户端"><a href="#4-3-取票客户端" class="headerlink" title="4.3 取票客户端"></a>4.3 取票客户端</h4><p>分为现场取票部分和预约取票两部分</p><p>现场取票通过选择业务进行取号</p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610144601.png"  style="zoom:50%;" /><p>预约取票通过输入身份证号码进行取票</p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610144754.png"  style="zoom:50%;" /><p>未预约则提示无预约记录</p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610144850.png"  style="zoom:50%;" /><p>取票成功之后可发现，记录已经删除</p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610145000.png"  style="zoom:50%;" /><h3 id="五、开发过程出现的问题"><a href="#五、开发过程出现的问题" class="headerlink" title="五、开发过程出现的问题"></a>五、开发过程出现的问题</h3><h4 id="5-1-tabBar不显示问题"><a href="#5-1-tabBar不显示问题" class="headerlink" title="5.1 tabBar不显示问题"></a>5.1 tabBar不显示问题</h4><p>欢迎页是pages/index/index，但list的第一项不是pages/index/index就会tabBar不显示</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"pages"</span>:[</span><br><span class="line">    <span class="string">"pages/index/index"</span>,</span><br><span class="line">    <span class="string">"pages/reserve/index"</span>,</span><br><span class="line">    <span class="string">"pages/take/index"</span>,</span><br><span class="line">    <span class="string">"pages/record/index"</span>,</span><br><span class="line">    <span class="string">"pages/logs/logs"</span></span><br><span class="line">  ],</span><br><span class="line"><span class="string">"tabBar"</span>: &#123;</span><br><span class="line">    <span class="string">"list"</span>: [&#123;</span><br><span class="line">      <span class="string">"pagePath"</span>: <span class="string">"pages/reserve/index"</span>,</span><br><span class="line">      <span class="string">"text"</span>: <span class="string">"预约"</span>,</span><br><span class="line">      <span class="string">"iconPath"</span>: <span class="string">"icons/reserve_index.png"</span>,</span><br><span class="line">      <span class="string">"selectedIconPath"</span>: <span class="string">"icons/reserve_index.png"</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      <span class="string">"pagePath"</span>: <span class="string">"pages/take/index"</span>,</span><br><span class="line">      <span class="string">"text"</span>: <span class="string">"取号"</span>,</span><br><span class="line">      <span class="string">"iconPath"</span>: <span class="string">"icons/take_index.png"</span>,</span><br><span class="line">      <span class="string">"selectedIconPath"</span>: <span class="string">"icons/take_index.png"</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      <span class="string">"pagePath"</span>: <span class="string">"pages/record/index"</span>,</span><br><span class="line">      <span class="string">"text"</span>: <span class="string">"预约历史"</span>,</span><br><span class="line">      <span class="string">"iconPath"</span>: <span class="string">"icons/record_index.png"</span>,</span><br><span class="line">      <span class="string">"selectedIconPath"</span>: <span class="string">"icons/record_index.png"</span></span><br><span class="line">    &#125;]</span><br></pre></td></tr></table></figure><h4 id="5-2-iView的button组件无法绑定submit事件"><a href="#5-2-iView的button组件无法绑定submit事件" class="headerlink" title="5.2 iView的button组件无法绑定submit事件"></a>5.2 iView的button组件无法绑定submit事件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;form bindsubmit=<span class="string">"formSubmit"</span>&gt;</span><br><span class="line">    &lt;i-panel title=<span class="string">"预约信息"</span>&gt;</span><br><span class="line">      &lt;i-input value=<span class="string">"&#123;&#123; IDcard &#125;&#125;"</span> name=<span class="string">"IDcard"</span> type=<span class="string">"number"</span> title=<span class="string">"身份证号"</span> mode=<span class="string">"wrapped"</span> placeholder=<span class="string">"请输入身份证号"</span> /&gt;</span><br><span class="line">      &lt;i-input value=<span class="string">"&#123;&#123; phone &#125;&#125;"</span> name=<span class="string">"phone"</span> type=<span class="string">"number"</span> title=<span class="string">"联系电话"</span> mode=<span class="string">"wrapped"</span> placeholder=<span class="string">"请输入手机号"</span> /&gt;</span><br><span class="line">      &lt;i-input value=<span class="string">"&#123;&#123; phone &#125;&#125;"</span> name=<span class="string">"reserveTime"</span> type=<span class="string">"number"</span> title=<span class="string">"预约时间"</span> mode=<span class="string">"wrapped"</span> placeholder=<span class="string">"如2020-06-05 15:30"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/i-panel&gt;</span></span><br><span class="line"><span class="regexp">    &lt;i-button formType="submit" type="info" shape="circle"&gt;提交&lt;/i</span>-button&gt;</span><br><span class="line">    &lt;!-- <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">form-type</span>=<span class="string">"submit"</span> <span class="attr">type</span>=<span class="string">"info"</span> <span class="attr">shape</span>=<span class="string">"circle"</span>&gt;</span>提交&gt;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span> --&gt;</span><br><span class="line">  &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>view&gt;</span><br></pre></td></tr></table></figure><p>第8行是iView中的组件按钮，点击的时候无法提交表单</p><h4 id="5-3-iView的输入框无法输入"><a href="#5-3-iView的输入框无法输入" class="headerlink" title="5.3 iView的输入框无法输入"></a>5.3 iView的输入框无法输入</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i-input</span> <span class="attr">value</span>=<span class="string">"&#123;&#123; value2 &#125;&#125;"</span> <span class="attr">title</span>=<span class="string">"姓名"</span> <span class="attr">autofocus</span> <span class="attr">placeholder</span>=<span class="string">"请输入用户姓名"</span> <span class="attr">maxlength</span>=<span class="string">"100"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>要加个maxlength才行</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList实现原理及源码阅读</title>
      <link href="/2020/05/30/Java/ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2020/05/30/Java/ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>扩容</strong></p><p>发生在Add方法中，首先会调用ensureCapacityInternal确保size+1的位置可以存放元素，不够的话就调用ensureExplicitCapacity进行扩容，首先将原元素数组的长度增大1.5倍（oldCapacity + (oldCapacity &gt;&gt; 1)），然后对扩容后的容量与minCapacity进行比较：① 新容量小于minCapacity，则将新容量设为minCapacity；②新容量大于minCapacity，则指定新容量。最后将旧数组拷贝到扩容后的新数组中。</p><p><strong>线程不安全的原因</strong></p><p>对ArrayList进行添加元素的操作的时候是分两个步骤进行的，即第一步先在object[size]的位置上存放需要添加的元素；第二步将size的值增加1。由于这个过程在多线程的环境下是不能保证具有原子性的，因此ArrayList在多线程的环境下是线程不安全的。</p><p>通常有两种解决办法：第一，使用synchronized关键字；第二，可以用Collections类中的静态方法synchronizedList()，对ArrayList进行调用即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="comment">// 缺省容量,当ArrayList的构造方法中没有显示指出ArrayList的数组长度时，类内部使用默认缺省时对象数组的容量大小，为10。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 空对象数组，当ArrayList的构造方法中显示指出ArrayList的数组长度为0时，类内部将EMPTY_ELEMENTDATA 这个空对象数组赋给elemetData数组。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 缺省空对象数组，当ArrayList的构造方法中没有显示指出ArrayList的数组长度时，类内部使用默认缺省时对象数组为DEFAULTCAPACITY_EMPTY_ELEMENTDATA。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 元素数组，ArrayList的底层数据结构，只是一个对象数组，用于存放实际元素，并且被标记为transient，也就意味着在序列化的时候此字段是不会被序列化的。</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    <span class="comment">// 实际元素大小，默认为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 最大数组容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>ArrayList()无参构造函数。将DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋值给elementData</p><p>ArrayList(int initialCapacity)：initialCapacity &gt; 0则 新建一个object对象数组，并赋值给elementData；等于0则将EMPTY_ELEMENTDATA赋值给elementData</p><p>ArrayList(Collection&lt;? extends E&gt; c) 将传进来的c转化为object类型赋值给elementData，如果c为空则将EMPTY_ELEMENTDATA赋值给elementData</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList带容量大小的构造函数。    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123; <span class="comment">// 初始容量大于0</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity]; <span class="comment">// 初始化元素数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123; <span class="comment">// 初始容量为0</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA; <span class="comment">// 为空对象数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 初始容量小于0，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ArrayList无参构造函数。默认容量是10。    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 无参构造函数，设置元素数组为空 </span></span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建一个包含collection的ArrayList    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123; <span class="comment">// 集合参数构造函数</span></span><br><span class="line">    elementData = c.toArray(); <span class="comment">// 转化为数组</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123; <span class="comment">// 参数为非空集合</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>) // 是否成功转化为<span class="title">Object</span>类型数组</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// 不为Object数组的话就进行复制</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 集合大小为空，则设置元素数组为空</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add方法（扩容机制）"><a href="#add方法（扩容机制）" class="headerlink" title="add方法（扩容机制）"></a>add方法（扩容机制）</h2><p>ensureCapacityInternal确保size+1的位置可以存放元素，不够的话就进行扩容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; <span class="comment">// 添加元素</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList的扩容主要发生在向ArrayList集合中添加元素的时候。由add()方法的分析可知添加前必须确保集合的容量能够放下添加的元素。主要经历了以下几个阶段：</p><p>第一，在add()方法中调用ensureCapacityInternal(size + 1)方法来<strong>确定集合确保添加元素成功的最小集合容量minCapacity的值。参数为size+1，代表的含义是如果集合添加元素成功后，集合中的实际元素个数</strong>。在ensureCapacityInternal方法中，首先判断elementData是否为默认的空数组，如果是，minCapacity为minCapacity与集合默认容量大小中的较大值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; <span class="comment">// 判断元素数组是否为空数组</span></span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); <span class="comment">// 取较大值</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二，调用ensureExplicitCapacity(minCapacity)方法来确定集合为了确保添加元素成功是否需要对现有的元素数组进行扩容。<strong>首先将结构性修改计数器加一；然后判断minCapacity与当前元素数组的长度的大小，如果minCapacity比当前元素数组的长度大的时候需要扩容</strong>，进入第三阶段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结构性修改加1</span></span><br><span class="line">        modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三，如果需要对现有的元素数组进行扩容，则<strong>调用grow(minCapacity)方法，参数minCapacity表示集合为了确保添加元素成功的最小容量</strong>。在扩容的时候，首先将原元素数组的长度增大1.5倍（oldCapacity + (oldCapacity &gt;&gt; 1)），然后对扩容后的容量与minCapacity进行比较：① 新容量小于minCapacity，则将新容量设为minCapacity；②新容量大于minCapacity，则指定新容量。最后将旧数组拷贝到扩容后的新数组中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length; <span class="comment">// 旧容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) <span class="comment">// 新容量小于参数指定容量，修改新容量</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) <span class="comment">// 新容量大于最大容量</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity); <span class="comment">// 指定新容量</span></span><br><span class="line">    <span class="comment">// 拷贝扩容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间序列预测</title>
      <link href="/2020/05/28/%E9%A1%B9%E7%9B%AE/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B/"/>
      <url>/2020/05/28/%E9%A1%B9%E7%9B%AE/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本项目是基于时间序列算法的Web应用，通过上传数据集，选取时间序列算法，设定参数来完成数据的预测。系统分为使用Vue搭建的前端以及使用Java SpringBoot框架搭建的后端、使用Python实现算法。Java后端接收前端请求，后端调用相应算法进行计算，Java与Python之间通过RPC进行通信。算法部分使用statsmodels.tsa库下的一系列时间序列预测函数，如AR、ARMA、ARIMA等方法。对模型预测结果的评估采用了平均绝对误差、标准差、均方根误差来处理。</p><p>本文档侧重描述了ARMA、ARIMA算法的实现原理，如关于数据集的特征工程以及算法实现步骤、每个步骤对应的可视化。其余算法不做过多介绍，源码中会有注释说明。由于侧重点在于数据分析方法，所以没有对Web搭建过程做过多的介绍，Web应用的演示放在了实验结果可视化部分。</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>现代经济与生产活动中，往往需要预测未来某个时刻某一指标的值，从而更好地控制、优化经济与生产过程，时间序列分析应运而生。</p><p>时间序列是按照时间顺序取得的一系列观测值，时间序列典型的一个本质特征就是相邻观测值的依赖性。时间序列分析所论及的就是对这种依赖性进行分析的技巧，根据系统的有限长度的系列观测值，建立能够比较精确地反映序列中所包含的动态依存关系的数学模型，并借以对系统的未来进行预报。这种分析方法简单易行，便于掌握，但准确性差，一般只适用于短期预测。</p><p>时间序列包括：AR(自回归模型)，AR ( p) ，p阶的自回归模型 MA(移动平均模型)，MA(q)，q阶的移动平均模型 ARIMA(差分自回归移动平均模型)</p><p>AR,MA,ARMA都是运用于原始数据是平稳的时间序列。ARIMA运用于原始数据差分后是平稳的时间序列。</p><h2 id="2-问题描述"><a href="#2-问题描述" class="headerlink" title="2 问题描述"></a>2 问题描述</h2><p>对数据进行时间序列分析之前需要先完成数据预处理，包括缺失值的填充，异常值的删除等特征工程。之后选出符合要求的数据进行数据分析，如ARIMA比较适合预测有季节性特点的数据集；波动不大的数据就可以考虑使用ARMA这类算法。其次，使用ARMA、ARIMA算法的时候需要进行平稳性检验，非平稳数据通过一阶差分或多阶差分进行处理。最后，合理选择预测天数也是很重要的一点，算法对一两天的数据可以达到较高准确率，预测更久远的数据会增大误差。</p><h2 id="3-数据预处理和特征工程"><a href="#3-数据预处理和特征工程" class="headerlink" title="3 数据预处理和特征工程"></a>3 数据预处理和特征工程</h2><p>以pollution.csv数据集为例，介绍数据的预处理</p><h3 id="3-1-缺失值填充"><a href="#3-1-缺失值填充" class="headerlink" title="3.1 缺失值填充"></a>3.1 缺失值填充</h3><p>可以看出数据中有一些缺失值，需要进行填充</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200528210911.png"  alt=""></p><p>分别采用插值法、最近邻插补、均值法进行填充</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200528215044.png"  alt=""></p><h3 id="3-2-数据筛选"><a href="#3-2-数据筛选" class="headerlink" title="3.2 数据筛选"></a>3.2 数据筛选</h3><p>数据记录了365天，每天24小时，总共有365*24条数据。数据量比较大，故需将其聚合成以天为单位的数据集</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200528215245.png"  alt=""></p><p>对数据进行可视化，这里以pm和windspeed列数据为例。</p><p>pm数据大致情况</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529182528.png"  alt=""></p><p>windspeed数据大致情况</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529182710.png"  alt=""></p><p>下面实验均以pm为例</p><h2 id="4-基本原理与算法描述"><a href="#4-基本原理与算法描述" class="headerlink" title="4 基本原理与算法描述"></a>4 基本原理与算法描述</h2><p><strong>1、朴素法</strong></p><p>介绍：如果数据集在一段时间内都很稳定，我们想预测第二天的价格，可以取前面一天的价格，预测第二天的值。这种假设第一个预测点和上一个观察点相等的预测方法就叫朴素法。</p><p>适用场景：不适合变化很大的数据集，最适合稳定性很高的数据集</p><p><strong>2、简单平均法</strong></p><p>介绍：用之前全部已知的值计算出它们的平均值，将它作为要预测的下一个值。当然这不会很准确，但这种预测方法在某些情况下效果是最好的，比如在平均值上下波动的数据集。这种将预期值等同于之前所有观测点的平均值的预测方法就叫简单平均法。</p><p>使用场景：物品价格会随机上涨和下跌，平均价格会保持一致。我们经常会遇到一些数据集，虽然在一定时期内出现小幅变动，但每个时间段的平均值确实保持不变。这种情况下，我们可以预测出第二天的价格大致和过去天数的价格平均值一致。</p><p><strong>3、滑动平均法(MA)</strong></p><p>介绍：某段时间内，数据集有较大变化，这时如果计算整个时间段的平均值会导致误差较大，因此取最近几个时期的数据计算平均值。这种用某些窗口期计算平均值的预测方法就叫移动平均法。移动平均法能有效地消除预测中的随机波动，是非常有用的。</p><p>适用场景：物品价格在一段时间内大幅上涨，但后来又趋于平稳。我们也经常会遇到这种数据集，比如价格或销售额某段时间大幅上升或下降。</p><p>参数：p：移动窗口：加大p值会使平滑波动效果更好，但会使预测值对数据实际变动更不敏感</p><p><strong>4、简单指数平滑法(SE)</strong></p><p>介绍：通过加权平均值计算出预测值，其中权重随着观测值从早期到晚期的变化呈指数级下降。</p><p>适用场景：需要将所有数据考虑在内的同时也能给数据赋予不同非权重。例如，相比更早时期内的观测值，它会给近期的观测值赋予更大的权重。</p><p>参数：</p><p>α：平滑指数：</p><p>当时间序列呈现较稳定的水平趋势时，应选较小的α值，一般可在0.05～0.20之间取值；</p><p>当时间序列有波动，但长期趋势变化不大时，可选稍大的α值，常在0.1～0.4之间取值；</p><p>当时间序列波动很大，长期趋势变化幅度较大，宜选择较大的α值，如可在0.6～0.8间选值；</p><p>当时间序列数据是上升（或下降）的发展趋势类型，α应取较大的值，在0.6~1之间。</p><p><strong>5、霍尔特线性趋势法(Holt)</strong></p><p>介绍：可以在无需假设的情况下，准确预测出数据变化趋势。这种考虑到数据集变化趋势的方法就叫做霍尔特线性趋势法。</p><p>适用场景：每个时序数据集可以分解为相应的几个部分：趋势（Trend），季节性(Seasonal)和残差(Residual)。任何呈现某种趋势的数据集都可以用霍尔特线性趋势法用于预测。</p><p>参数：α和γ是平滑系数，取值范围均为（0，1）之间：若时间序列的波动不大，比较平稳，则α应取小一些，如0.1 ～ 0.3 ；若时间序列具有迅速且明显的变动倾向， 则α应取大一些，如0.6 ～ 0.9。</p><p><strong>6、自回归模型(AR)</strong></p><p>介绍：自回归模型（英语：Autoregressive model，简称AR模型），是统计上一种处理时间序列的方法，用同一变数例如x的之前各期，亦即x1至xt-1来预测本期xt的表现，并假设它们为一线性关系。因为这是从回归分析中的线性回归发展而来，只是不用x预测y，而是用x预测 x（自己）；所以叫做自回归</p><p><strong>7、自回归移动平均模型(ARMA)</strong></p><p>介绍：研究时间序列的重要方法，由自回归模型（简称AR模型）与移动平均模型（简称MA模型）为基础“混合”构成。在市场研究中常用于长期追踪资料的研究，如：Panel研究中，用于消费行为模式变迁研究；在零售研究中，用于具有季节变动特征的销售量、市场规模的预测等。</p><p><strong>8、差分自回归移动平均模型（ARIMA）</strong></p><p>介绍：如果数据集在一定时间段内的固定区间内呈现相似的模式，那么该数据集就具有季节性。自回归移动平均模型的目标是描述数据中彼此之间的关系。</p><p>适用场景：例如夏季降雨量较多，冬季降雨量较低，而且每年都是这样，那么这种重复现象叫做“季节性”，ARIMA即适用于这种场景。</p><h2 id="5-实验"><a href="#5-实验" class="headerlink" title="5 实验"></a>5 实验</h2><h3 id="5-1-数据集描述和评价指标"><a href="#5-1-数据集描述和评价指标" class="headerlink" title="5.1 数据集描述和评价指标"></a>5.1 数据集描述和评价指标</h3><p>数据集采用的是pollution.csv环境数据集，包含pm、humidity(湿度)、temperature(温度)、pressure(压力)、windspeed(风力)、snowfall(降雪量)、rainfall(降雨量)字段。总共有8544行数据，每行为当前小时的检测数据，由于大量的数据会引起网页卡顿或增加计算量的缘故，会把其按天进行重采样，简化到365条数据。</p><p>评价指标采用MAE平均绝对误差来计算。</p><p>MAE平均绝对误差：平均绝对误差，又叫平均绝对离差，是所有单个观测值与算术平均值的偏差的绝对值的平均。平均绝对误差可以避免误差相互抵消的问题，因而可以准确反映实际预测误差的大小。</p><h3 id="5-2-实验过程和实验结果"><a href="#5-2-实验过程和实验结果" class="headerlink" title="5.2 实验过程和实验结果"></a>5.2 实验过程和实验结果</h3><p>这部分以ARMA算法和ARIMA算法为例介绍算法原理</p><h4 id="5-2-1-ARMA分析"><a href="#5-2-1-ARMA分析" class="headerlink" title="5.2.1 ARMA分析"></a>5.2.1 ARMA分析</h4><h5 id="1-提取部分数据进行分析"><a href="#1-提取部分数据进行分析" class="headerlink" title="1.提取部分数据进行分析"></a>1.提取部分数据进行分析</h5><p>由于ARMA都是运用于原始数据是平稳的时间序列，故我们筛选出数据比较平稳的6月到9月这段时间进行预测分析</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">16</span>, <span class="number">5</span>), dpi=<span class="number">256</span>)</span><br><span class="line">data_part = data[(data.index &gt;= <span class="string">'2014-05-01'</span>) &amp; (data.index &lt;= <span class="string">'2014-9-30'</span>)]</span><br></pre></td></tr></table></figure><h5 id="2-进行平稳性检验"><a href="#2-进行平稳性检验" class="headerlink" title="2.进行平稳性检验"></a>2.进行平稳性检验</h5><p><strong>时序图</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(data_part[<span class="string">'pm'</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529133225.png"  alt=""></p><p>从时序图可以看出数据还是较为平稳的</p><p><strong>自相关图</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529133508.png"  alt=""></p><p><strong>偏自相关图</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529133446.png"  alt=""></p><p><strong>单位根检验</strong></p><p>单位根检验主要是检验p值是否大于0.05，大于0.05的时间序列是非平稳的，需要进行差分。p值小于0.05的是平稳的时间序列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"ADF检验结果:"</span>, ADF(data_part[<span class="string">'pm'</span>]))</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529133712.png"  alt=""></p><p>这里的第二个值就是p值。这里的p值小于0.05。判断选取的数据是平稳的时间序列。</p><p><strong>白噪声检验</strong></p><p>白噪声检验主要是检验p值是否大于0.05，大于0.05的时间序列是平稳的白噪声时间序列，p值小于0.05的是平稳的非白噪声的时间序列，是平稳的非白噪声的时间序列才可以进行下一步的ARMA分析。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"白噪声的检验结果:"</span>, acorr_ljungbox(data_part[<span class="string">'pm'</span>], lags=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529133744.png"  alt=""></p><p>这里明显小于0.05.判断选取的数据是平稳的非白噪声的时间序列。</p><h5 id="3-ARMA模型的训练"><a href="#3-ARMA模型的训练" class="headerlink" title="3.ARMA模型的训练"></a>3.ARMA模型的训练</h5><p>实际上就是要确定ARMA函数中p阶，q阶的最佳参数，通过计算最小的AIC值来寻找</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ps = range(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">   qs = range(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">   parameters = product(ps, qs)</span><br><span class="line">   parameters_list = list(parameters)</span><br><span class="line"></span><br><span class="line">   best_aic = float(<span class="string">'inf'</span>)</span><br><span class="line">   results = []</span><br><span class="line">   <span class="keyword">for</span> param <span class="keyword">in</span> parameters_list:</span><br><span class="line">       <span class="keyword">try</span>:</span><br><span class="line">           model = ARMA(data_part[<span class="string">'pm'</span>], order=(param[<span class="number">0</span>], param[<span class="number">1</span>])).fit()</span><br><span class="line">       <span class="keyword">except</span> ValueError:</span><br><span class="line">           print(<span class="string">"参数错误："</span>, param)</span><br><span class="line">           <span class="keyword">continue</span></span><br><span class="line">       aic = model.aic</span><br><span class="line">       <span class="keyword">if</span> aic &lt; best_aic:</span><br><span class="line">           best_model = model</span><br><span class="line">           best_aic = model.aic</span><br><span class="line">           best_param = param</span><br><span class="line">       results.append([param, model.aic])</span><br><span class="line">   results_table = pd.DataFrame(results)</span><br><span class="line">   results_table.columns = [<span class="string">'parameters'</span>, <span class="string">'aic'</span>]</span><br><span class="line">   print(<span class="string">"最优模型"</span>, best_model.summary())</span><br></pre></td></tr></table></figure><p>找到当p = 3, q = 1时有最优的模型</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529134438.png"  alt=""></p><p>用该模型就可以预测未来5天的pm值，并且使用均值绝对误差MAE进行评估</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pred_y = best_model.forecast(<span class="number">5</span>)[<span class="number">0</span>]</span><br><span class="line">    test_y = data[(data.index &gt;= <span class="string">'2014-10-1'</span>) &amp; (data.index &lt;= <span class="string">'2014-10-5'</span>)][<span class="string">'pm'</span>]</span><br><span class="line">    print(<span class="string">"预测的未来5天的pm: "</span>, pred_y)</span><br><span class="line">    print(<span class="string">"真实的未来5天的pm: "</span>, test_y)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"MAE平均绝对误差： %.2f"</span> %mean_absolute_error(test_y, pred_y))</span><br><span class="line"></span><br><span class="line">    x = data[(data.index &gt;= <span class="string">'2014-10-1'</span>) &amp; (data.index &lt;= <span class="string">'2014-10-5'</span>)]</span><br><span class="line">    plt.plot(x.index, test_y, color=<span class="string">'blue'</span>)</span><br><span class="line">    plt.plot(x.index, pred_y, color=<span class="string">'red'</span>)</span><br><span class="line">    plt.title(<span class="string">'预测值与真实值对比'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529172343.png"  alt=""></p><p>红色为预测值，蓝色为真实值</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529172412.png"  alt=""></p><h4 id="5-2-2-ARIMA分析"><a href="#5-2-2-ARIMA分析" class="headerlink" title="5.2.2 ARIMA分析"></a>5.2.2 ARIMA分析</h4><h5 id="1-提取部分数据进行分析-1"><a href="#1-提取部分数据进行分析-1" class="headerlink" title="1.提取部分数据进行分析"></a>1.提取部分数据进行分析</h5><p>ARIMA都是运用于原始数据差分后是平稳的时间序列，故我们筛选出数据不是特别平稳的11月到12月这段时间进行预测分析</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">16</span>, <span class="number">5</span>), dpi=<span class="number">256</span>)</span><br><span class="line">data_part = data[(data.index &gt;= <span class="string">'2014-6-01'</span>) &amp; (data.index &lt;= <span class="string">'2014-7-31'</span>)]</span><br></pre></td></tr></table></figure><h5 id="2-进行平稳性检验-1"><a href="#2-进行平稳性检验-1" class="headerlink" title="2.进行平稳性检验"></a>2.进行平稳性检验</h5><p><strong>时序图</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(data_part[<span class="string">'pm'</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529170233.png"  alt=""></p><p>从时序图可以看出数据的波动还是挺大</p><p><strong>自相关图</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529150855.png"  alt=""></p><p><strong>偏自相关图</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529150915.png"  alt=""></p><p><strong>单位根检验</strong></p><p>单位根检验主要是检验p值是否大于0.05，大于0.05的时间序列是非平稳的，需要进行差分。p值小于0.05的是平稳的时间序列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"ADF检验结果:"</span>, ADF(data_part[<span class="string">'pm'</span>]))</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529165333.png"  alt=""></p><p>这里的第二个值就是p值。这里的p值大于0.05。判断选取的数据是非平稳的时间序列。</p><p><strong>一阶差分</strong></p><p>一阶差分后，ADF小于0.05，转换为平稳序列</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529154350.png"  alt=""></p><p>数据差分后的时序图</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529170500.png"  alt=""></p><p><strong>白噪声检验</strong></p><p>白噪声检验主要是检验p值是否大于0.05，大于0.05的时间序列是平稳的白噪声时间序列，p值小于0.05的是平稳的非白噪声的时间序列，是平稳的非白噪声的时间序列才可以进行下一步的ARMA分析。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"白噪声的检验结果:"</span>, acorr_ljungbox(data_part[<span class="string">'pm'</span>], lags=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529151046.png"  alt=""></p><p>这里小于0.05，判断选取的数据是平稳的非白噪声的时间序列。</p><h5 id="3-ARMA模型的训练-1"><a href="#3-ARMA模型的训练-1" class="headerlink" title="3.ARMA模型的训练"></a>3.ARMA模型的训练</h5><p>由于只有一阶差分，故参数d = 1</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D_data_day = data_part[<span class="string">'pm'</span>].diff().dropna()</span><br><span class="line">   print(<span class="string">"一阶差分检验结果："</span>, ADF(D_data_day))</span><br></pre></td></tr></table></figure><p>下面寻找最优的p和q</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ps = range(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">    qs = range(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">    parameters = product(ps, qs)</span><br><span class="line">    parameters_list = list(parameters)</span><br><span class="line"></span><br><span class="line">    best_aic = float(<span class="string">'inf'</span>)</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> parameters_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            model = ARIMA(data_part[<span class="string">'pm'</span>], order=(param[<span class="number">0</span>], <span class="number">1</span>, param[<span class="number">1</span>])).fit()</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            print(<span class="string">"参数错误："</span>, param)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        aic = model.aic</span><br><span class="line">        <span class="keyword">if</span> aic &lt; best_aic:</span><br><span class="line">            best_model = model</span><br><span class="line">            best_aic = model.aic</span><br><span class="line">            best_param = param</span><br><span class="line">        results.append([param, model.aic])</span><br><span class="line">    results_table = pd.DataFrame(results)</span><br><span class="line">    results_table.columns = [<span class="string">'parameters'</span>, <span class="string">'aic'</span>]</span><br><span class="line">    print(<span class="string">"最优模型"</span>, best_model.summary())</span><br><span class="line"></span><br><span class="line">    pred_y = best_model.forecast(<span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line">    test_y = data[(data.index &gt;= <span class="string">'2014-8-1'</span>) &amp; (data.index &lt;= <span class="string">'2014-8-3'</span>)][<span class="string">'pm'</span>]</span><br><span class="line">    print(<span class="string">"预测的未来3天的pm: "</span>, pred_y)</span><br><span class="line">    print(<span class="string">"真实的未来3天的pm: "</span>, test_y)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"MAE平均绝对误差： %.2f"</span> % mean_absolute_error(test_y, pred_y))</span><br><span class="line"></span><br><span class="line">    x = data[(data.index &gt;= <span class="string">'2014-8-1'</span>) &amp; (data.index &lt;= <span class="string">'2014-8-3'</span>)]</span><br><span class="line">    plt.plot(x.index, test_y, color=<span class="string">'blue'</span>)</span><br><span class="line">    plt.plot(x.index, pred_y, color=<span class="string">'red'</span>)</span><br><span class="line">    plt.title(<span class="string">'预测值与真实值对比'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>找到最优参数 p = 1，q = 1。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529165457.png"  alt=""></p><p>用该模型预测未来3天的pm值，并且使用均值绝对误差MAE进行评估</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200604133807.png"  alt=""></p><p>红色为预测值，蓝色为真实值，总体趋势还是吻合的</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200529165739.png"  alt=""></p><h3 id="5-3-实验结果可视化"><a href="#5-3-实验结果可视化" class="headerlink" title="5.3 实验结果可视化"></a>5.3 实验结果可视化</h3><p>使用ARIMA预测train.csv数据集结果</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200604130916.png"  alt=""></p><p>数据集操作可以选择要预测的数据集，以及确定数据集的占比；预测方法部分实现了AR、MA、SES、Holt、ARIMA算法</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>本项目是基于Web的时间序列预测平台。通过上传数据集，选取时间序列算法，设定参数来完成数据的预测。系统分为使用Vue搭建的前端以及使用Java SpringBoot框架搭建的后端、使用Python实现算法。Java后端接收前端请求，后端调用相应算法进行计算，Java与Python之间通过RPC进行通信。算法部分使用statsmodels.tsa库下的一系列时间序列预测函数，如AR、ARMA、ARIMA等方法。对模型预测结果的评估采用了平均绝对误差、标准差、均方根误差来处理。</p><p>本文档侧重描述了ARMA、ARIMA算法的实现原理。如关于数据集的特征工程以及算法实现步骤、每个步骤对应的可视化。并没有对Web搭建做过多的介绍，Web应用的演示放在了实验结果可视化部分。</p><p>对于时间序列预测的算法，数据集的选取还是比较重要的，对于不同特点的数据集采用不同方法进行预测，会达到较高的预测精度，并不能期望一种算法能够适配所有数据。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]zhh_2017.统计学——时间序列预测[EB/OL].<a href="https://blog.csdn.net/i505224798/article/details/87310168,2019-02-15" target="_blank" rel="noopener">https://blog.csdn.net/i505224798/article/details/87310168,2019-02-15</a>.</p><p>[2]皮皮_blog.时间序列分析[EB/OL].<a href="http://blog.csdn.net/pipisorry/article/details/62053938,2017-3-22" target="_blank" rel="noopener">http://blog.csdn.net/pipisorry/article/details/62053938,2017-3-22</a>.</p><p>[3]张良均.Python数据分析与挖掘实战[M].机械工业出版社:北京市,2018:119-132.</p><p><a href="https://blog.csdn.net/qq_33333002/article/details/106171234" target="_blank" rel="noopener">https://blog.csdn.net/qq_33333002/article/details/106171234</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5Nzg5ODQ3NQ==&amp;mid=2247487503&amp;idx=2&amp;sn=3830a27122726bd8b43b28c0df34cd65&amp;chksm=fe4d358bc93abc9d161c7d9289e2680bf5a1c42491fa2e86e533021512985ca7a3c707f7fc0a&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1590235251941&amp;sharer_shareid=8eccc1546aceed0b542f3d42d319e5e1#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU5Nzg5ODQ3NQ==&amp;mid=2247487503&amp;idx=2&amp;sn=3830a27122726bd8b43b28c0df34cd65&amp;chksm=fe4d358bc93abc9d161c7d9289e2680bf5a1c42491fa2e86e533021512985ca7a3c707f7fc0a&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1590235251941&amp;sharer_shareid=8eccc1546aceed0b542f3d42d319e5e1#rd</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合核心概念</title>
      <link href="/2020/05/25/Java/%E6%A6%82%E5%BF%B5/Java%E9%9B%86%E5%90%88%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/05/25/Java/%E6%A6%82%E5%BF%B5/Java%E9%9B%86%E5%90%88%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>没有进行扩展，方便复习。需要更详细的，可以访问我的博客查看其它文章</p></blockquote><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200525163056"  alt="在这里插入图片描述"></p><h2 id="一、List"><a href="#一、List" class="headerlink" title="一、List"></a>一、List</h2><p>存放是有序的，允许存放重复元素</p><h3 id="1-1-ArrayList"><a href="#1-1-ArrayList" class="headerlink" title="1.1 ArrayList"></a>1.1 ArrayList</h3><p>ArrayList 是常用的 List 实现类，<strong>内部是通过数组</strong>实现的，它<strong>允许对元素进行快速随机访问</strong>。数 组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数 组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要<strong>对数组进 行复制、移动、代价比较高</strong>。因此，它<strong>适合随机查找和遍历，不适合插入和删除</strong>。</p><h3 id="1-2-LinkedList"><a href="#1-2-LinkedList" class="headerlink" title="1.2 LinkedList"></a>1.2 LinkedList</h3><p>LinkedList是用<strong>双向链表</strong>结构存储数据的，很适合<strong>数据的动态插入和删除</strong>，<strong>随机访问和遍历速度比较 慢</strong>。另外，他实现了Deque接口，可以用于操作表头和表尾元素，可以当作堆 栈、队列和双向队列使用。 </p><h3 id="1-3-Vector"><a href="#1-3-Vector" class="headerlink" title="1.3 Vector"></a>1.3 Vector</h3><p>Vector与ArrayList一样，也是通过<strong>数组实现</strong>的，不同的是它<strong>支持线程的同步</strong>，即某一时刻只有一 个线程能够写 Vector，避免多线程同时写而引起的不一致性，但<strong>实现同步需要很高的花费，因此， 访问它比访问ArrayList慢</strong></p><h2 id="二、Set"><a href="#二、Set" class="headerlink" title="二、Set"></a>二、Set</h2><p>Set是<strong>没有顺序，且不可重复</strong>的。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200525162932"  alt="在这里插入图片描述"></p><h3 id="2-1-HashSet（哈希表）"><a href="#2-1-HashSet（哈希表）" class="headerlink" title="2.1 HashSet（哈希表）"></a>2.1 HashSet（哈希表）</h3><p><strong>Set不允许重复，底层是HashMap，无容量限制，是非线程安全的。</strong>虽然底层是HashMap但不存储键值对，值存储对象。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200525121559.png"  alt=""></p><p><strong>HashSet根据元素的哈希值来决定存储在哪个位置，哈希值相同的使用equals判断是否是同一元素，是的话插入操作失败，不是的话就在相同的哈希值下顺延</strong></p><p>HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不 同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。</p><p>元素的哈希值是通过元素的 hashcode方法来获取的, HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals方法 如果 equls结果为true ，HashSet就视为同一个元素。如果equals 为false就不是 同一个元素。 哈希值相同equals为false的元素在同样的哈希值下顺延.</p><h3 id="2-2-TreeSet"><a href="#2-2-TreeSet" class="headerlink" title="2.2 TreeSet"></a>2.2 TreeSet</h3><p><strong>基于TreeMap实现，支持排序，是非线程安全的</strong></p><p><strong>TreeSet()是使用二叉树的原理对新add()的对象按照指定的顺序排序（升序、降序），每增 加一个对象都会进行排序，将对象插入的二叉树指定的位置。</strong><br>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，自 己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使 用。<br>在覆写compare()函数时，要返回相应的值才能使TreeSet按照一定的规则来排序<br>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整 数、零或正整数</p><h3 id="2-3-LinkHashSet"><a href="#2-3-LinkHashSet" class="headerlink" title="2.3 LinkHashSet"></a>2.3 LinkHashSet</h3><p><strong>LinkHashSet(HashSet+LinkHashMap)，继承自HashSet，底层是LinkedHashMap。这样做的好处是LinkHashSet中的元素顺序是可以保证的，也就是遍历序和插入序是一样的。</strong><br>对于 LinkedHashSet 而言，它继承于 HashSet、又基于 LinkedHashMap 来实现的。 LinkedHashSet 底层使用 LinkedHashMap（有序） 来保存所有元素，它继承与 HashSet，其所有的方法 操作上又与HashSet相同，因此LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并 通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操 作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可</p><h2 id="三、Map"><a href="#三、Map" class="headerlink" title="三、Map"></a>三、Map</h2><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200525160619"  alt="在这里插入图片描述"></p><h3 id="3-1-HashMap"><a href="#3-1-HashMap" class="headerlink" title="3.1 HashMap"></a>3.1 HashMap</h3><p>1.<strong>底层是数组+链表/红黑树</strong>。</p><p>2.<strong>无序键值对集合</strong>，根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快 的访问速度。</p><p>3.<strong>HashMap多只允许一条记录的键为null，允许多条记 录的值为 null。</strong></p><p>4.<strong>HashMap 非线程安全</strong>，如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。</p><h3 id="3-2-Hashtable"><a href="#3-2-Hashtable" class="headerlink" title="3.2 Hashtable"></a>3.2 Hashtable</h3><p><strong>Hashtable 是遗留类</strong>，很多映射的常用功能与 HashMap 类似，不同的是<strong>它承自 Dictionary 类</strong>，<strong>实现Map接口</strong> 并且是<strong>线程安全的</strong>，所有的读写等操作都进行了锁（synchronized）保护，任一时间只有一个线程能写 Hashtable，<strong>并发性不如 ConcurrentHashMap</strong>， 因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全 的场合可以用HashMap替换，<strong>需要线程安全的场合可以用ConcurrentHashMap替换</strong>。 </p><h3 id="3-3-TreeMap"><a href="#3-3-TreeMap" class="headerlink" title="3.3 TreeMap"></a>3.3 TreeMap</h3><p>TreeMap <strong>实现 SortedMap 接口</strong>，能够把它<strong>保存的记录根据键排序</strong>，默认是按键值的<strong>升序排序</strong>， 也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。<br>如果使用排序的映射，建议使用TreeMap。<br>在使用 TreeMap 时，<strong>key 必须实现 Comparable 接口</strong>或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 </p><h3 id="3-4-LinkedHashMap"><a href="#3-4-LinkedHashMap" class="headerlink" title="3.4 LinkedHashMap"></a>3.4 LinkedHashMap</h3><p>LinkedHashMap 是 HashMap 的一个子类，底层结构和HashMap一样，但通过双向链表<strong>保存了记录的插入顺序</strong>，在用 Iterator 遍历 LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 </p><p><strong>注：TreeMap是按照hashcode进行排序的，LinkedHashMap是根据插入顺序进行排序</strong></p><h2 id="四、面试题"><a href="#四、面试题" class="headerlink" title="四、面试题"></a>四、面试题</h2><h3 id="4-1-list实现类之间的区别"><a href="#4-1-list实现类之间的区别" class="headerlink" title="4.1 list实现类之间的区别"></a>4.1 list实现类之间的区别</h3><p>对于需要快速插入、删除元素的场景，应该使用LinkedList</p><p>对于需要快速随机访问元素，应该使用ArrayList</p><p>对于单线程环境，应该使用非同步的类如ArrayList</p><p>对于多线程环境，应该使用同步的类如Vector</p><h3 id="4-2-ArrayList和LinkedList的区别？"><a href="#4-2-ArrayList和LinkedList的区别？" class="headerlink" title="4.2 ArrayList和LinkedList的区别？"></a>4.2 ArrayList和LinkedList的区别？</h3><p>①ArrayList和LinkedList，<strong>一个基于数组实现，一个基于链表实现</strong><br>前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列<br>②当<strong>随机访问</strong>List时（get和set操作），<strong>ArrayList比LinkedList的效率更高</strong>，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>③当对数据进行<strong>增加和删除的操作</strong>时(add和remove操作)，<strong>LinkedList比ArrayList的效率更高</strong>，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。<br><code>④</code>内存空间占用来看，<strong>ArrayList</strong>的空间浪费体现在会<strong>预留一定的容量</strong>空间，而LinkedList中存储的每个元素都需要存放前驱和后继的指针，<strong>空间占用会比ArrayList中每个元素的多</strong>。<br>⑤ArrayList和LinkedList都是<strong>线程不安全</strong>的</p><p>场景：<br>链表，插入删除快，查找修改慢。 适用于频繁增删的场景。<br>数组，查找快，插入删除慢。 适用于频繁查找和修改的场景。</p><h3 id="4-3-ArrayList和Vector的区别？"><a href="#4-3-ArrayList和Vector的区别？" class="headerlink" title="4.3 ArrayList和Vector的区别？"></a>4.3 ArrayList和Vector的区别？</h3><p>1.ArrayList是线程不安全的，Vector是线程安全的</p><p>2.在不需要保证线程安全时应使用ArrayList，因为Vector在同步操作上会消耗大量时间</p><h3 id="4-4-HashMap与HashTable区别"><a href="#4-4-HashMap与HashTable区别" class="headerlink" title="4.4 HashMap与HashTable区别"></a>4.4 HashMap与HashTable区别</h3><p>1.<strong>HashMap</strong>没有对读写等操作进行锁保护，所以是<strong>线程不安全</strong>的，在多线程场景下会出现<strong>数据不一致</strong>的问题。而<strong>HashTable是同步</strong>的，所有的读写等操作都进行了锁（synchronized）保护，在多线程环境下没有安全问题。但是<strong>锁保护也是有代价</strong>的，会对<strong>读写的效率产生较大影响</strong>。</p><p>2.<strong>HashMap允许键和值是null，而Hashtable不允许键或者值是null</strong>。</p><p>3.<strong>HashMap的迭代器（Iterator）是fail-fast迭代器，但是Hashtable的迭代器（enumerator）不是fail-fast的</strong>。如果有其它线程对HashMap进行的添加/删除元素，将会抛出<strong>ConcurrentModificationException</strong>，但迭代器本身的remove方法移除元素则不会抛出异常。</p><h3 id="4-5-Collection-和-Collections的区别"><a href="#4-5-Collection-和-Collections的区别" class="headerlink" title="4.5 Collection 和 Collections的区别?"></a>4.5 Collection 和 Collections的区别?</h3><p>Collection是集合类的上级接口，继承于他的接口主要有Set 和List.<br>Collections是针对集合类的一个<strong>辅助类</strong>，他提供一系列<strong>静态方法实现对各种集合的搜索、排序、线程安全化</strong>等操作</p><h3 id="4-6-Collection集合接口和Map接口有什么关系？"><a href="#4-6-Collection集合接口和Map接口有什么关系？" class="headerlink" title="4.6 Collection集合接口和Map接口有什么关系？"></a>4.6 Collection集合接口和Map接口有什么关系？</h3><p>没有直接关系，但是一些子类会有依赖，Collection是最基本的集合接口，声明了适用于JAVA集合（只包括Set和List）的通用方法。Map接口并不是Collection接口的子接口，但是它仍然被看作是Collection框架的一部分。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程核心概念</title>
      <link href="/2020/05/23/Java/%E6%A6%82%E5%BF%B5/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/05/23/Java/%E6%A6%82%E5%BF%B5/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-进程与线程概念"><a href="#1-进程与线程概念" class="headerlink" title="1.进程与线程概念"></a>1.进程与线程概念</h3><p><strong>进程</strong></p><p><strong>进程是程序的一次执行过程，是系统运行程序的基本单位</strong>，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程</p><p><strong>线程</strong></p><p>线程与进程相似，但<strong>线程是一个比进程更小的执行单位</strong>。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。    </p><p><strong>协程</strong></p><p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><h3 id="2-进程和线程的区别"><a href="#2-进程和线程的区别" class="headerlink" title="2.进程和线程的区别"></a>2.进程和线程的区别</h3><ol><li>进程是<strong>资源分配的最小单位</strong>，线程是程序执行的最小单位（<strong>资源调度的最小单位</strong>）</li><li><strong>进程有自己的独立地址空间</strong>，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。<br>线程是<strong>共享进程中的数据</strong>的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li><li><strong>线程之间的通信更方便</strong>，同一进程下的线程<strong>共享全局变量</strong>、静态变量等数据，而进程之间的通信需要以通信的方式（<strong>IPC</strong>)进行。</li><li>但是<strong>多进程程序更健壮</strong>，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间</li></ol><p><strong>总结：</strong></p><p>线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。</p><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</p><p>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h3 id="3-进程与线程状态转换"><a href="#3-进程与线程状态转换" class="headerlink" title="3.进程与线程状态转换"></a>3.进程与线程状态转换</h3><blockquote><p>关于状态这块，网上的说法太多了，有5种、6种的，《Java并发编程艺术》书里也没讲进程。下面是我找到的比较流行的说法，如果大家有推荐的书籍，欢迎留言告知。这里的线程指Java中的线程</p></blockquote><h4 id="进程有5种状态"><a href="#进程有5种状态" class="headerlink" title="进程有5种状态"></a>进程有5种状态</h4><ul><li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li><li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li><li><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核CPU下任意时刻只有一个进程处于运行状态)。</li><li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行</li></ul><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523155801.png"  alt=""></p><h4 id="线程有6种状态"><a href="#线程有6种状态" class="headerlink" title="线程有6种状态"></a>线程有6种状态</h4><p>线程状态这一块有点复杂，会专门出一篇研究</p><ul><li><p><strong>初始(NEW)</strong>：新创建了一个线程对象，但还没有调用start()方法。</p></li><li><p><strong>运行(RUNNABLE)</strong>：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</p></li><li><p><strong>阻塞(BLOCKED)</strong>：表示线程阻塞于锁。<strong>注意和进程的区别，进程是IO阻塞</strong></p></li><li><p><strong>等待(WAITING)</strong>：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p></li><li><p><strong>超时等待(TIMED_WAITING)</strong>：该状态不同于WAITING，它可以在指定的时间后自行返回。</p></li><li><p><strong>终止(TERMINATED)</strong>：表示该线程已经执行完毕。</p></li></ul><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523161825"  alt="线程状态图"></p><h3 id="4-进程与线程的通信方式"><a href="#4-进程与线程的通信方式" class="headerlink" title="4.进程与线程的通信方式"></a>4.进程与线程的通信方式</h3><h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><p>大概有 7 种常见的进程间的通信方式。</p><ol><li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。只存在于内存中的文件</li><li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循<strong>先进先出(first in first out)</strong>。有名管道以<strong>磁盘文件</strong>的方式存在，可以实现本机任意两个进程通信。</li><li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li><strong>消息队列(Message Queuing)</strong> ：消息队列是<strong>消息的链表</strong>,具有特定的格式,存放在内存中并由<strong>消息队列标识符标识</strong>。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是<strong>消息队列存放在内核中</strong>，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。</strong></li><li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要<strong>依靠某种同步操作，如互斥锁和信号量</strong>等。可以说这是最有用的进程间通信方式。</li><li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ol><h4 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h4><p>线程间的通信有JMM内存模型控制，共享变量存储在主内存中，每个线程可以将其拷贝到自己的本地内存中，在本地内存中更新过的共享变量刷新会刷新到主内存，另一线程在从主内存中读取更新后的共享变量。</p><ol><li><p><strong>volatile与synchronize关键字</strong></p><p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对<strong>该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存</strong>，它能保证所有线程对变量访问的可见性。</p><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要<strong>确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中</strong>，它保证了线程对变量访问的可见性和排他性。</p></li><li><p><strong>等待/通知机制</strong>：是指一个<strong>线程A调用了对象O的wait()方法进入等待</strong>状态，而另一个<strong>线程B 调用了对象O的notify()</strong>或者notifyAll()方法，线程A<strong>收到通知后从对象O的wait()方法返回</strong>，进而 执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p><p>补充：</p><p>1）使用wait()、notify()和notifyAll()时需要<strong>先对调用对象加锁</strong>（在synchronized中调用）。<br>2）调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。<br>3）notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或 notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。<br>4）notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll() 方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为 BLOCKED。<br>5）从wait()方法返回的前提是获得了调用对象的锁。<br>从上述细节中可以看到，等待/通知机制依托于同步机制，其目的就是确保等待线程从 wait()方法返回时能够感知到通知线程对变量做出的修改。</p></li><li><p><strong>管道输入/输出流</strong>：和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p></li><li><p><strong>Thread.join()</strong>：如果一个线程A执行了thread.join(B)语句，其含义是：当前线程A等待thread B线程终止之后才继续执行。</p></li><li><p><strong>ThreadLocal</strong>，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这 个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学生成绩管理系统（C语言）</title>
      <link href="/2020/05/23/%E9%A1%B9%E7%9B%AE/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F(C%E7%89%88%E6%9C%AC)/"/>
      <url>/2020/05/23/%E9%A1%B9%E7%9B%AE/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F(C%E7%89%88%E6%9C%AC)/</url>
      
        <content type="html"><![CDATA[<h2 id="一、系统背景"><a href="#一、系统背景" class="headerlink" title="一、系统背景"></a>一、系统背景</h2><p><strong>系统名称</strong>：学生成绩管理系统</p><p>该系统采用C语言实现，完成学生成绩记录的查看、录入、查询、修改、删除、排序、统计等功能，在记录的存储上采用了哈希表的数据结构，即数组+链表的形式进行存储，可以加快查询的速度，也使用了堆排序算法来完成排序功能。</p><p>不足：没有持久化存储机制，可以采用文件的方式进行存储。</p><h2 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h2><p><strong>菜单</strong></p><p>基本功能以菜单形式提供，可反复使用各项功能</p><p><strong>学生信息及成绩的录入</strong></p><p>要求包括的学生信息有：学号、姓名、性别、出生日期及某科目成绩；</p><p>录入的学生按学号散列存储, 采用链表法解决冲突。</p><p><strong>学生成绩的查询</strong> </p><p>根据提供的学号完成学生成绩的查询。</p><p><strong>学生成绩的分段统计和排序输出</strong> </p><p>可以统计出各分数段学生人数；采用堆排序, 将学生成绩从高到低排序输出。</p><p><strong>学生成绩记录的删除</strong></p><p>可以删除学生成绩记录</p><h2 id="三、模块设计"><a href="#三、模块设计" class="headerlink" title="三、模块设计"></a>三、模块设计</h2><table><thead><tr><th><strong>功能</strong></th><th><strong>函数原型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>1、菜单</td><td>Menu()</td><td>程序的入口，拥有学生成绩查看、录入、查找、排序统计、修改、删除等操作。</td></tr><tr><td>2、学生成绩查看</td><td>doViewall()</td><td>将文件中学生的成绩按学号顺序以列表陈列。</td></tr><tr><td>3、学生成绩录入</td><td>doInsert()</td><td>将学生成绩按学号散列存储，并采用链表法解决冲突。</td></tr><tr><td>4、学生成绩查找</td><td>doSearch()</td><td>输入学号，查找出学生信息，以及询问是否修改删除或继续查找。</td></tr><tr><td>5、学生成绩排序</td><td>doSort()</td><td>采用堆排序将学生成绩从高到低排序。</td></tr><tr><td>6、学生成绩统计</td><td>Statistics()</td><td>统计各分数段学生人数。</td></tr><tr><td>7、学生成绩修改</td><td>doModify()</td><td>对学生的信息进行修改。输入学号，程序会跳出学生的详细信息，确认是否修改。</td></tr><tr><td>8、学生成绩删除</td><td>doClear()</td><td>对学生的信息进行删除操作。</td></tr></tbody></table><h2 id="四、数据流程图"><a href="#四、数据流程图" class="headerlink" title="四、数据流程图"></a>四、数据流程图</h2><p>流程图这块就不放上来了，系统业务本身并不复杂，代码是很容易懂的。</p><h2 id="五、模块实现"><a href="#五、模块实现" class="headerlink" title="五、模块实现"></a>五、模块实现</h2><h3 id="5-1-查看学生信息"><a href="#5-1-查看学生信息" class="headerlink" title="5.1 查看学生信息"></a>5.1 查看学生信息</h3><p>将全部学生的数据条按照存储数据排列输出。由于hash表的结构是数组+链表，故遍历数组的时候，如果数组中元素后跟着链表则遍历链表输出。</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doViewall</span><span class="params">(Hash *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu t;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=================================================================\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"学号\t姓名\t性别\t生日\t\t民族\t科目成绩\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (t = H[i]; t != <span class="literal">NULL</span>; t = t-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">doDisplay(H, t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n=================================================================\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-录入学生信息"><a href="#5-2-录入学生信息" class="headerlink" title="5.2 录入学生信息"></a>5.2 录入学生信息</h3><p>使用哈希表（散列表）的存储形式。散列表是在存储元素时通过计算关键码的散列函数（关键码和存储位置之间的对应函数是散列函数）值确定存储地址。通过选择适当的正整数p，按计算公式H(K)=Kmodp来计算关键码K的散列地址。若关键码个数为n，散列表表长为m（一般m&gt;=n），通常选p为小于或等于表长m的最大素数或不包含小于20的质因子的合数，一般也要求p&gt;=n。在此题要求p = 5。散列表特点就是在当散列地址相同时会出现冲突。如：取余的余数为5，当要输入学号1时，就存储在H[1]中，但若要在输入一个学号为6的学生，那么6%5=1就会和存储在H[1]的学号1的学生产生冲突。</p><p>解决冲突使用拉链法。将所有散列地址相同的记录存储在同一个单链表中。该单链表头指针存储在散列表中。散列表就是个指针数组，下标就是由关键码用散列函数计算出的散列地址。初始，指针数组每个元素为空指针，相当于所有单链表头指针为空，以后每扫描到一条记录，按其关键码的散列地址，在相应的单链表中加入含该记录的节点。</p><p>采用数组和链表相结合的办法，将Hash地址相同的记录存储在一张线性表中，而每张表的表头的序号即为计算得到的Hash地址。比如学号为1的就存在H[1]当作表头，H[n]数组包括学号num,姓名name等信息，还包括类似链表的指向下一个结点的next指针。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Build_Hash</span><span class="params">(Hash *H,stu s)</span><span class="comment">//输入一组关键字,建立Hash表,表长为m,用链地址法处理冲突.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stu p;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">    n=s-&gt;num%<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(H[n]==<span class="literal">NULL</span>) </span><br><span class="line">H[n]=s; <span class="comment">//作为链表的第一个结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(p=H[n];p-&gt;next;p=p-&gt;next);</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;num==s-&gt;num)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"已存在该学号的学生，添加学生信息出错!\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;next=s; <span class="comment">//插入链表尾部.本算法不考虑排序问题.</span></span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//Build_Hash</span></span><br></pre></td></tr></table></figure><h3 id="5-3-查找学生信息"><a href="#5-3-查找学生信息" class="headerlink" title="5.3 查找学生信息"></a>5.3 查找学生信息</h3><p>采取散列查找。散列查找也如同散列存储一样，会出现冲突的问题，解决方法也是采用拉链法的形式，具体操作如上。根据关键值计算出散列地址。散列地址即散列表的下标，在其相应单链表找出该结点。</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成绩查询</span></span><br><span class="line"><span class="function">Status <span class="title">Search</span><span class="params">(Hash *H,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">stu t;</span><br><span class="line">n=key%<span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(H[n])</span><br><span class="line">&#123;</span><br><span class="line">t = H[n];</span><br><span class="line"><span class="keyword">if</span>(EQ(H[n]-&gt;num,key))<span class="comment">//在表头</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=============================================================\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"学号\t姓名\t性别\t生日\t\t民族\t数构成绩\n"</span>);</span><br><span class="line">doDisplay(H, t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n=============================================================\n"</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//探测下一个地址，在链表中是查找</span></span><br><span class="line">&#123;</span><br><span class="line">t=H[n]-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(EQ(t-&gt;num,key))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"=============================================================\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"学号\t姓名\t性别\t生日\t\t民族\t数构成绩\n"</span>);</span><br><span class="line">doDisplay(H, t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n=============================================================\n"</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">t=t-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-学生信息排序"><a href="#5-4-学生信息排序" class="headerlink" title="5.4 学生信息排序"></a>5.4 学生信息排序</h3><p>核心算法是堆排序。堆是一棵顺序存储的完全二叉树。其中每个结点的关键字都不大于其孩子结点的关键字，这样的堆称为小根堆。其中每个结点的关键字都不小于其孩子结点的关键字，这样的堆称为大根堆。这里我们采用的是大根堆。其算法思想即是</p><p>（1）根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。</p><p>（2）每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为大根堆。</p><p>如此反复，这个数组已经是顺序排列了。</p><p>为方便理解，引用网上图片</p><p>构建初始堆的过程如下图：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523211836.jpg"  alt="img"></p><p>​                                                     ——<strong>来源技术博客</strong></p><p>​    堆排序过程如下图</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523211844.jpg"  alt="img"></p><p>​                                                                                                                                                ——<strong>来源于网上博客</strong></p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(HeapType &amp;H, <span class="keyword">int</span> i, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// 已知 R[s..m]中记录的关键字除 R[i] 之外均</span></span><br><span class="line"><span class="comment">// 满足堆的特征，本函数自上而下调整 R[i] 的</span></span><br><span class="line"><span class="comment">// 关键字，使 R[i..m] 也成为一个大顶堆。</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">temp = H.r[i];    <span class="comment">// 暂存 R[s] </span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">2</span> * i; j &lt;= m; j *= <span class="number">2</span>) &#123; <span class="comment">// j 初值指向左孩子</span></span><br><span class="line"><span class="comment">//自上而下的筛选过程;</span></span><br><span class="line"><span class="keyword">if</span> (j&lt;m &amp;&amp; LT(H.r[j], H.r[j + <span class="number">1</span>]))  ++j;</span><br><span class="line"><span class="comment">// 左/右“子树根”之间先进行相互比较</span></span><br><span class="line"><span class="comment">// 令 j 指示关键字较大记录的位置</span></span><br><span class="line"><span class="keyword">if</span> (!LT(temp, H.r[j]))  <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 再作“根”和“子树根”之间的比较，</span></span><br><span class="line"><span class="comment">// 若“&gt;=”成立，则说明已找到 temp 的插</span></span><br><span class="line"><span class="comment">// 入位置 i ，不需要继续往下调整</span></span><br><span class="line">H.r[i] = H.r[j];   i = j;</span><br><span class="line"><span class="comment">// 否则记录上移，尚需继续往下调整</span></span><br><span class="line">&#125;</span><br><span class="line">H.r[i] = temp;  <span class="comment">// 将调整前的堆顶记录插入到 i 位置</span></span><br><span class="line">&#125; <span class="comment">// HeapAdjust</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(HeapType &amp;H)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 对顺序表 H 进行堆排序。</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = H.length / <span class="number">2</span>; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">HeapAdjust(H, i, H.length);    <span class="comment">// 建大顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = H.length; i&gt;<span class="number">1</span>; --i) &#123;</span><br><span class="line"><span class="comment">//H.r[1]←→H.r[i];    </span></span><br><span class="line">temp = H.r[<span class="number">1</span>];</span><br><span class="line">H.r[<span class="number">1</span>] = H.r[i];</span><br><span class="line">H.r[i] = temp;</span><br><span class="line"><span class="comment">// 将堆顶记录当前未经排序子序列</span></span><br><span class="line"><span class="comment">//  H.r[1..i]中最后一个记录相互交换</span></span><br><span class="line">HeapAdjust(H, <span class="number">1</span>, i - <span class="number">1</span>);  <span class="comment">// 对 H.r[1] 进行筛选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// HeapSort</span></span><br></pre></td></tr></table></figure><h3 id="5-5-学生成绩统计"><a href="#5-5-学生成绩统计" class="headerlink" title="5.5 学生成绩统计"></a>5.5 学生成绩统计</h3><p>遍历学生成绩，分段统计</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计各个分数段的人数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Calculate</span><span class="params">(HeapType h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b, c, d, e;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">a = b = c = d = e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= h.length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (h.r[i] &gt;= <span class="number">90</span>)</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (h.r[i] &gt;= <span class="number">80</span>)</span><br><span class="line">b++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (h.r[i]&gt;<span class="number">70</span>)</span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (h.r[i]&gt;<span class="number">60</span>)</span><br><span class="line">d++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">e++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t科目成绩\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"91-100分：%d人\n"</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"81-90分： %d人\n"</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"71-80分： %d人\n"</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"61-70分： %d人\n"</span>, d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"60分以下：%d人\n"</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-修改学生信息"><a href="#5-6-修改学生信息" class="headerlink" title="5.6 修改学生信息"></a>5.6 修改学生信息</h3><p>就是需要找到要修改的数据存储地址，在这个存储地址上通过输入数据覆盖原先的数据。在修改功能里，加入判断，可以实现只修改学生的个别信息，而不是重新输入学生全部信息。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(t-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(EQ(t-&gt;next-&gt;num,key))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n&gt;&gt;是否修改姓名?(Y/N):"</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);<span class="comment">//把scanf的输入流自动清除</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;cmd);</span><br><span class="line"><span class="keyword">if</span> (cmd == <span class="string">'y'</span> || cmd == <span class="string">'Y'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&gt;&gt;请输入要修改的姓名\n"</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);<span class="comment">//把scanf的输入流自动清除</span></span><br><span class="line">gets(t-&gt;name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n&gt;&gt;是否修改性别?(Y/N):"</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);<span class="comment">//把scanf的输入流自动清除</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;cmd);</span><br><span class="line"><span class="keyword">if</span> (cmd == <span class="string">'y'</span> || cmd == <span class="string">'Y'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&gt;&gt;请输入修改的性别[F/M]\n"</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);<span class="comment">//把scanf的输入流自动清除</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;t-&gt;sex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n&gt;&gt;是否修改出生年月?(Y/N):"</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);<span class="comment">//把scanf的输入流自动清除</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;cmd);</span><br><span class="line"><span class="keyword">if</span> (cmd == <span class="string">'y'</span> || cmd == <span class="string">'Y'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&gt;&gt;请输入修改的出生年月\n"</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);<span class="comment">//把scanf的输入流自动清除</span></span><br><span class="line">gets(t-&gt;birthday);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n&gt;&gt;是否修改民族?(Y/N):"</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);<span class="comment">//把scanf的输入流自动清除</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;cmd);</span><br><span class="line"><span class="keyword">if</span> (cmd == <span class="string">'y'</span> || cmd == <span class="string">'Y'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&gt;&gt;请输入修改的民族\n"</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);<span class="comment">//把scanf的输入流自动清除</span></span><br><span class="line">gets(t-&gt;folk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n&gt;&gt;是否修改数据结构的成绩?(Y/N):"</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);<span class="comment">//把scanf的输入流自动清除</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;cmd);</span><br><span class="line"><span class="keyword">if</span> (cmd == <span class="string">'y'</span> || cmd == <span class="string">'Y'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&gt;&gt;请输入修改的数据结构成绩\n"</span>);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);<span class="comment">//把scanf的输入流自动清除</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">H[n]-&gt;s.DataStructure=k;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&gt;&gt;请按回车键返回主菜单..."</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n========================================================\n"</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">t=t-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-7-删除学生信息"><a href="#5-7-删除学生信息" class="headerlink" title="5.7 删除学生信息"></a>5.7 删除学生信息</h3><p>与修改功能相似。找到目的数据的存储地址，将前一个元素的next指针指向当前元素的下一个。同时需要释放删除元素的空间。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">doClear</span><span class="params">(Hash *H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> cmd;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">stu t;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&gt;&gt;请输入要删除学生的学号:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;key);</span><br><span class="line">n=key%<span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(!Search(H,key))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在该学生的信息..."</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span>(H[n])</span><br><span class="line">&#123;</span><br><span class="line">t=H[n];</span><br><span class="line"><span class="keyword">if</span>(EQ(H[n]-&gt;num,key))</span><br><span class="line">&#123;</span><br><span class="line">H[n]=H[n]-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除成功！\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n========================================================\n"</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">t = H[n];</span><br><span class="line"><span class="keyword">while</span> (t-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (EQ(t-&gt;next-&gt;num, key))</span><br><span class="line">&#123;</span><br><span class="line">t-&gt;next = t-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除成功！\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n========================================================\n"</span>);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、数据介绍"><a href="#六、数据介绍" class="headerlink" title="六、数据介绍"></a>六、数据介绍</h2><p>系统运行用到的数据在启动的时候通过函数进行载入内存。预先读取代码存储的数据，将数据存入Hash表中，之后的添加删除操作也都在Hash表上操作。数据字段包含学号、姓名、性别、出生日期及某科目成绩。</p><h2 id="七、运行结果截图"><a href="#七、运行结果截图" class="headerlink" title="七、运行结果截图"></a>七、运行结果截图</h2><p><strong>菜单</strong></p><p>启动程序，即弹出菜单，一个操作完成也会弹出菜单方便下一次选择</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523221608.jpg"  alt="img"></p><p>【1<strong>】学生成绩查看</strong></p><p>列出所有的学生记录</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523221613.jpg"  alt="img"></p><p>【2<strong>】学生成绩录入</strong></p><p>分别录入字段，并存入hash表中</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523221618.jpg"  alt="img"></p><p>【3<strong>】学生成绩查询</strong></p><p>输入学生学号即可查询该生成绩</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523221623.jpg"  alt="img"></p><p>【4<strong>】学生成绩排序</strong></p><p>将学生记录按照成绩高低进行排序</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523221626.jpg"  alt="img"></p><p>【5<strong>】学生成绩统计</strong></p><p>将学生按照成绩进行分段统计</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523221630.jpg"  alt="img"></p><p>【6<strong>】学生成绩修改</strong></p><p>输入学生学号，进行修改该生信息，修改完成后可以选择是否继续修改</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523221634.jpg"  alt="img"></p><p>【7<strong>】学生成绩删除</strong></p><p>输入学生学号，进行删除学生记录</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523221638.jpg"  alt="img"></p><p>删除学号为4的学生后，记录中就不再有该生</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523221641.jpg"  alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ六种工作模式</title>
      <link href="/2020/05/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/05/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、RabbitMQ六种工作模式"><a href="#一、RabbitMQ六种工作模式" class="headerlink" title="一、RabbitMQ六种工作模式"></a>一、RabbitMQ六种工作模式</h2><h3 id="1-1-simple简单模式"><a href="#1-1-simple简单模式" class="headerlink" title="1.1 simple简单模式"></a>1.1 simple简单模式</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523113504.png"  alt="在这里插入图片描述"></p><ol><li>消息产生者将消息放入队列</li><li>消息的消费者(consumer) 监听(while) 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失)</li><li>应用场景:聊天(中间有一个过度的服务器;p端,c端)</li></ol><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();<span class="comment">//创建连接</span></span><br><span class="line">        Channel channel = connection.createChannel();<span class="comment">//创建通道</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列名\是否持久化\是否排外\是否自动删除\消费完删除</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">        String message = <span class="string">"错的不是我，是这个世界~"</span>;<span class="comment">//消息内容</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 交换机\队列名\其他属性(路由)\消息body</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"> </span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//该方法会阻塞</span></span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-work工作模式-资源的竞争"><a href="#1-2-work工作模式-资源的竞争" class="headerlink" title="1.2 work工作模式(资源的竞争)"></a>1.2 work工作模式(资源的竞争)</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523113433.png"  alt="在这里插入图片描述"></p><ol><li>消息产生者将消息放入队列</li><li>消费者可以有多个,消费者1,消费者2,同时监听同一个队列；C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患,高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize,与同步锁的性能不一样) 保证一条消息只能被一个消费者使用)</li><li>应用场景:红包;大项目中的资源调度(任务分配系统不需知道哪一个任务执行系统在空闲,直接将任务扔到消息队列中,空闲的系统自动争抢)</li></ol><h3 id="1-3-publish-subscribe发布订阅-共享资源"><a href="#1-3-publish-subscribe发布订阅-共享资源" class="headerlink" title="1.3 publish/subscribe发布订阅(共享资源)"></a>1.3 publish/subscribe发布订阅(共享资源)</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523114731.png"  alt="在这里插入图片描述"></p><ol><li>消息产生者将消息放入交换机X</li><li>交换机发布订阅把消息发送到所有消息队列中</li><li>对应消息队列的消费者拿到消息进行消费</li><li>相关场景:邮件群发,群聊天,广播(广告)</li></ol><h3 id="1-4-routing路由模式"><a href="#1-4-routing路由模式" class="headerlink" title="1.4 routing路由模式"></a>1.4 routing路由模式</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523114737.png"  alt="在这里插入图片描述"></p><ol><li>消息生产者将消息发送给交换机，当前产生的消息携带路由字符(对象的方法)</li><li>交换机按照路由的key判断，将消息按照key放到对应的队列</li><li>消费者从队列中消费消息</li><li>业务场景:可将不同类型的消息放到不同队列，并有对应的消费者处理</li></ol><h3 id="1-5-topic-主题模式-路由模式的一种"><a href="#1-5-topic-主题模式-路由模式的一种" class="headerlink" title="1.5 topic 主题模式(路由模式的一种)"></a>1.5 topic 主题模式(路由模式的一种)</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523115431.png"  alt="在这里插入图片描述"></p><ol><li>星号井号代表通配符</li><li>星号代表多个单词,井号代表一个单词</li><li>路由功能添加模糊匹配</li><li>消息产生者产生消息,把消息交给交换机</li><li>交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费</li></ol><h3 id="1-6-RPC模式"><a href="#1-6-RPC模式" class="headerlink" title="1.6 RPC模式"></a>1.6 RPC模式</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200523120130"  alt="img"></p><ol><li><p>客户端通过RPC向服务端发出请求，携带着correlation_id：这是我的请求标识，erply_to：你处理完过后把结果返回到这个队列中</p></li><li><p>服务端拿到了请求，开始处理并返回</p></li><li><p>客户端用自己的correlation_id与服务端返回的id进行对比；是我的，就接收。从发送到接收客户端是阻塞的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解Lock</title>
      <link href="/2020/05/22/Java/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3Lock/"/>
      <url>/2020/05/22/Java/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3Lock/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h3 id="Lock、AQS、锁之间的关系"><a href="#Lock、AQS、锁之间的关系" class="headerlink" title="Lock、AQS、锁之间的关系"></a>Lock、AQS、锁之间的关系</h3><p>Java 5之后新增了Lock接口，自定义类可实现Lock接口，并通过内部静态类继承AQS抽象类的方式实现独占锁、共享锁。<strong>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作</strong>。用户调用子类实现的Lock接口中提供的方法，而这些方法又调用同步器的方法来实现具体的功能。</p><h3 id="AQS实现原理"><a href="#AQS实现原理" class="headerlink" title="AQS实现原理"></a>AQS实现原理</h3><p>AQS是一个Java提供的底层同步工具类，用一个int类型的变量state表示同步状态，并使用CAS操作来管理这个同步状态。同时，它还实现了一个FIFO的队列，底层采用双向链表实现，并有head和tial指针指向头和尾。</p><p>当一个线程获取到锁之后，通过CAS将state设置为1代表线程获取到锁；如果这时候有其它的线程在竞争锁，那么在失败后其它将会被加入队列尾部，并且自旋判断其<strong>前驱节点为头节点&amp;是否成功获取同步状态</strong>，两个条件都成立，则将当前线程设置为头节点，如果不是，则用<strong>LockSupport.park(this)将当前线程挂起 ,等待前驱节点释放unpark唤醒自己</strong>。</p><h3 id="ReentrantLock实现原理"><a href="#ReentrantLock实现原理" class="headerlink" title="ReentrantLock实现原理"></a>ReentrantLock实现原理</h3><p>ReentrantLock是可重入锁，通过判断上次获取锁的线程是否为当前线程(<code>current == getExclusiveOwnerThread()</code>)，如果是则可再次进入临界区并且增加同步状态值返回最后true，如果不是，则返回false。当释放锁时也要减小同步状态值。</p><p>ReentrantLock可实现公平锁，通过构造传参的方式。在非公平锁的基础上加入了对<strong>同步队列中当前节点是否有前驱节点的判断</strong>，如果该 方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p><h2 id="一、Lock"><a href="#一、Lock" class="headerlink" title="一、Lock"></a>一、Lock</h2><p>锁是用来控制多个线程访问共享资源的方式。在Lock接 口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增 了Lock接口（以及相关实现类）用来实现锁功能，它提供了synchronized关键字类似的同步功 能，只是在使用时需要显式地获取和释放锁。</p><p>来看看源码以及方法，这些方法都是由子类具体实现的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200522164653.png"  alt=""></p><h3 id="与Synchronized锁区别"><a href="#与Synchronized锁区别" class="headerlink" title="与Synchronized锁区别"></a>与Synchronized锁区别</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200522164846.png"  alt=""></p><h2 id="二、什么是AQS"><a href="#二、什么是AQS" class="headerlink" title="二、什么是AQS"></a>二、什么是AQS</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>AQS是AbustactQueuedSynchronizer（队列同步器）的简称，它是一个Java提供的底层同步工具类，用一个int类型的变量表示同步状态，并提供了一系列的CAS操作来管理这个同步状态。</p><p>AQS的主要作用是为Java中的<strong>并发同步组件提供统一的底层支持</strong>，例如ReentrantLock，CountdowLatch就是基于AQS实现的，用法是通过<strong>继承AQS实现其模版方法</strong>，然后将<strong>子类作为同步组件的内部类</strong>。</p><p>AQS中可重写的方法分为独占式与共享式的</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200522162428.png"  alt=""></p><p>可以直接调用的模板方法有</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200522162647.png"  alt=""></p><p>同步器提供的如下3个方法来访问或修改同步状态。<br>·getState()：获取当前同步状态。<br>·setState(int newState)：设置当前同步状态。<br>·compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。</p><h3 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h3><h4 id="2-2-1-同步队列"><a href="#2-2-1-同步队列" class="headerlink" title="2.2.1 同步队列"></a>2.2.1 同步队列</h4><p>同步队列是AQS很重要的组成部分，它是一个<strong>双端队列</strong>，遵循FIFO原则，主要作用是用来存放在锁上阻塞的线程，当一个线程尝试获取锁时，如果已经被占用，<strong>获取锁失败</strong>那么当前线程就会<strong>被构造成一个Node节点</strong>加入到同步队列的尾部，队列的<strong>头节点是成功获取锁的节点</strong>，当头节点线程释放锁时，会<strong>唤醒后面的节点并释放当前头节点的引用</strong></p><p>同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和 后继节点</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200522172923.png"  alt=""></p><p>使用CAS将节点插入到尾部，并用tail指向该结点</p><p>####2.2.2 独占锁的获取和释放流程<br><strong>获取</strong></p><ul><li><p>调用入口方法acquire(arg)</p></li><li><p>调用模版方法tryAcquire(arg)尝试获取锁，若成功则返回，若失败则走下一步</p></li><li><p>将当前线程构造成一个Node节点，并利用addWaiter(Node node) 将其加入到同步队列尾部</p></li><li><p>调用acquireQueued(Node node,int arg)方法，使得该 节点以“死循环”的方式获取同步状态</p></li><li><p>自旋时，首先判断其<strong>前驱节点为头节点且释放&amp;是否成功获取同步状态</strong>，两个条件都成立，则将当前线程的节设置为头节点，如果不是，则利用<strong>LockSupport.park(this)将当前线程挂起 ,等待前驱节点释放唤醒自己</strong>，之后继续判断。</p></li></ul><p><strong>释放</strong></p><ul><li>调用入口方法release(arg)</li><li>调用模版方法tryRelease(arg)释放同步状态</li><li>利用LockSupport.unpark(currentNode.next.thread)唤醒后继节点（接获取的第五步）</li></ul><p>####2.2.3 共享锁的获取和释放流程</p><p><strong>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态</strong></p><p><strong>获取锁</strong></p><ul><li>在acquireShared(int arg)方法中，同步器调用tryAcquireShared(int arg)方法尝试获取同步状态</li><li>tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是 <strong>tryAcquireShared(int arg)方法返回值大于等于0</strong>。</li><li>可以看到，在doAcquireShared(int arg)方法的自 旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。</li></ul><p><strong>释放锁</strong></p><ul><li>调用releaseShared(arg)模版方法释放同步状态</li><li>调用模版方法tryReleaseShard(arg)释放同步状态</li><li>如果释放成功，则<strong>遍历整个队列，利用LockSupport.unpark(nextNode.thread)唤醒所有后继节点</strong></li><li>与独占式区别在于<strong>线程安全释放，通过循环和CAS保证</strong>，因为释放同步状态的操作会同时来自多个线程</li></ul><h4 id="2-2-4-独占锁和共享锁在实现上的区别"><a href="#2-2-4-独占锁和共享锁在实现上的区别" class="headerlink" title="2.2.4 独占锁和共享锁在实现上的区别"></a>2.2.4 独占锁和共享锁在实现上的区别</h4><ul><li>独占锁的同步状态值为1，即同一时刻只能有一个线程成功获取同步状态；共享锁的同步状态&gt;1，取值由上层同步组件确定</li><li>独占锁队列中头节点运行完成后释放它的直接后继节点；共享锁队列中头节点运行完成后释放它后面的所有节点</li><li>共享锁中会出现多个线程（即同步队列中的节点）同时成功获取同步状态的情况</li></ul><h4 id="2-2-5-重入锁"><a href="#2-2-5-重入锁" class="headerlink" title="2.2.5 重入锁"></a>2.2.5 重入锁</h4><p>重入锁指的是当前线程成功获取锁后，如果再次访问该临界区，则不会对自己产生互斥行为。Java中ReentrantLock和synchronized都是可重入锁，synchronized由JVM偏向锁实现可重入锁，ReentrantLock可重入性基于AQS实现。</p><p>重入锁的基本原理是<strong>判断上次获取锁的线程是否为当前线程</strong>(<code>current == getExclusiveOwnerThread()</code>)，如果是则可再次进入临界区，如果不是，则阻塞。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//通过AQS获取同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//同步状态为0，说明临界区处于无锁状态，</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//修改同步状态，即加锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//将当前线程设置为锁的owner</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果临界区处于锁定状态，且上次获取锁的线程为当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">//则递增同步状态</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是获取锁的线程再次请求，则将同步状态值进行增加并返回 true，表示获取同步状态成功。</p><p>成功获取锁的线程再次获取锁，只是增加了同步状态值，这也就要求ReentrantLock在释放 同步状态时减少同步状态值</p><h4 id="2-2-6-公平锁和非公平锁"><a href="#2-2-6-公平锁和非公平锁" class="headerlink" title="2.2.6 公平锁和非公平锁"></a>2.2.6 公平锁和非公平锁</h4><p>对于非公平锁，其它线程可以和同步队列中的锁进行竞争，只要CAS设置 同步状态成功，则表示当前线程获取了锁，而公平锁则不同</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//此处为公平锁的核心，即判断同步队列中当前节点是否有前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了 hasQueuedPredecessors()方法，即加入了<strong>同步队列中当前节点是否有前驱节点的判断</strong>，如果该 方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p><h4 id="2-2-7-读写锁"><a href="#2-2-7-读写锁" class="headerlink" title="2.2.7 读写锁"></a>2.2.7 读写锁</h4><p>Java提供了一个基于AQS到读写锁实现<code>ReentrantReadWriteLock</code>，该读写锁到实现原理是：<strong>将同步变量state按照高16位和低16位进行拆分，高16位表示读锁，低16位表示写锁</strong>。</p><p><strong>写锁的获取与释放</strong><br>写锁是一个独占锁，所以我们看一下ReentrantReadWriteLock中tryAcquire(arg)的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               <span class="comment">// Reentrant acquire</span></span><br><span class="line">               setState(c + acquires);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">               !compareAndSetState(c, c + acquires))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           setExclusiveOwnerThread(current);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>上述代码的处理流程已经非常清晰：</p><ul><li>获取同步状态，并从中分离出低16位的写锁状态</li><li>如果同步状态不为0，说明存在读锁或写锁</li><li>如果存在读锁（c ！=0 &amp;&amp; w == 0），则不能获取写锁（保证写对读的可见性）</li><li>如果当前线程不是上次获取写锁的线程，则不能获取写锁（写锁为独占锁）</li><li>如果以上判断均通过，则在低16为写锁同步状态上利用CAS进行修改（增加写锁同步状态，实现可重入）<br>将当前线程设置为写锁的获取线程</li></ul><p>写锁的释放过程与独占锁基本相同：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">           <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (free)</span><br><span class="line">               setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           setState(nextc);</span><br><span class="line">           <span class="keyword">return</span> free;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>在释放的过程中，不断减少读锁同步状态，只为同步状态为0时，写锁完全释放。</p><p><strong>读锁的获取与释放</strong></p><p>读锁是一个共享锁，获取读锁的步骤如下：</p><ul><li>获取当前同步状态</li><li>计算高16为读锁状态+1后的值</li><li>如果大于能够获取到的读锁的最大值，则抛出异常</li><li>如果存在写锁并且当前线程不是写锁的获取者，则获取读锁失败</li><li>如果上述判断都通过，则利用CAS重新设置读锁的同步状态</li></ul><p>读锁的释放步骤与写锁类似，即不断的释放写锁状态，直到为0时，表示没有线程获取读锁。</p><h2 id="三、使用AQS与Lock自定义一个锁"><a href="#三、使用AQS与Lock自定义一个锁" class="headerlink" title="三、使用AQS与Lock自定义一个锁"></a>三、使用AQS与Lock自定义一个锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;            </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 是否处于占用状态            </span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;                    </span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;            </span><br><span class="line">        &#125;            </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当状态为0的时候获取锁            </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;                    </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;   </span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread()); </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;                    </span><br><span class="line">            &#125;                    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;            </span><br><span class="line">        &#125;            </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放锁，将状态设置为0            </span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;                    </span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();            </span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);                    </span><br><span class="line">            setState(<span class="number">0</span>);                    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;            </span><br><span class="line">        &#125;            </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列            </span></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 仅需要将操作代理到Sync上即可    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        sync.acquire(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        sync.release(<span class="number">1</span>); </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> sync.newCondition(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;            </span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程：</p><ul><li><p>这个自定义类Mutex首先实现了Lock接口，</p></li><li><p>内部静态类Sync继承了AQS抽象类，并重写了独占式的tryAcquire和tryRelease方法，</p></li><li><p>接着Mutex实例化Sync内部类，</p></li><li><p>Mutex类重写Lock接口的方法，如lock、tryLock、unlock等方法，具体实现是通过调用Sync类中的重写的方法（tryAcquire）以及模板方法（acquire）等</p></li><li><p>用户使用Mutex时调用Mutex提供的方法，在Mutex的实现中，调用同步器的模板方法acquire(int args)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lock </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring核心概念</title>
      <link href="/2020/05/22/Java/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E9%94%A6%E9%9B%86/"/>
      <url>/2020/05/22/Java/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E9%94%A6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面试题锦集系列专注于面试题，为的只是回答面试题的时候能组织好语言，所以说明的不会很详细，不过建议需要了解原理，只背面试题可不行。如果需要更详细的内容，可以看我的其他博客</p></blockquote><h2 id="说说Spring的三大核心思想"><a href="#说说Spring的三大核心思想" class="headerlink" title="说说Spring的三大核心思想"></a>说说Spring的三大核心思想</h2><p>IOC ：控制反转，将对象的创建权交给Spring管理</p><p>DI ： 依赖注入，将对象的属性赋值，对象依赖关系维护交给Spring</p><p>AOP ：面向切面编程，将重复代码与业务逻辑分离</p><h2 id="IOC与DI"><a href="#IOC与DI" class="headerlink" title="IOC与DI"></a>IOC与DI</h2><p>Spring的核心思想之一：<strong>Inversion of Control , 控制反转 IOC</strong></p><p><strong>对象的创建交给外部容器完成，这个就做控制反转</strong>，可以解决手动创建对象以及对象依赖问题。</p><p>对象间的依赖关系采用<strong>依赖注入：dependency injection.</strong>来解决</p><p>好处：</p><p><strong>第一，资源集中管理，实现资源的可配置和易管理</strong>。<strong>第二，降低了耦合度</strong>。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><strong>Aop： aspect object programming  面向切面编程</strong>，将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><p>简单来讲就是将重复代码与业务逻辑分离</p><p>面向切面编程：<strong>对很多功能都有的重复的代码抽取，再在运行的时候往业务方法上动态植入“切面类代码”</strong></p><h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ 。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><h3 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些?"></a>Spring 中的 bean 的作用域有哪些?</h3><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li><li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li><li>global-session：全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。</li></ul><h3 id="Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗？"></a>Spring 中的单例 bean 的线程安全问题了解吗？</h3><p>单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的<strong>非静态成员变量</strong>的写操作会存在线程安全问题。</p><p>常见的有两种解决办法：</p><ol><li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li><li>在类中<strong>定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal</strong> 中（推荐的一种方式）。</li></ol><h2 id="SpringMVC流程"><a href="#SpringMVC流程" class="headerlink" title="SpringMVC流程"></a>SpringMVC流程</h2><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200522150426.png"  alt=""></p><p>纠正： <code>DispatcherServlet</code> 的作用是接收请求，响应结果。</p><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li><li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li><li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol><h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h2><ul><li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h2 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h2><ol><li>编程式事务，在代码中硬编码。(不推荐使用)</li><li>声明式事务，在配置文件中配置（推荐使用）<ol><li>基于XML的声明式事务</li><li>基于注解的声明式事务</li></ol></li><li>基于Aspectj AOP配置事务</li></ol><h2 id="Spring如何控制事务"><a href="#Spring如何控制事务" class="headerlink" title="Spring如何控制事务"></a>Spring如何控制事务</h2><h3 id="循环依赖、三级缓存"><a href="#循环依赖、三级缓存" class="headerlink" title="循环依赖、三级缓存"></a>循环依赖、三级缓存</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot核心概念</title>
      <link href="/2020/05/22/Java/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98%E9%94%A6%E9%9B%86/"/>
      <url>/2020/05/22/Java/SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98%E9%94%A6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1、什么是-Spring-Boot？"><a href="#1、什么是-Spring-Boot？" class="headerlink" title="1、什么是 Spring Boot？"></a>1、什么是 Spring Boot？</h2><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手</p><h2 id="2、自动装配原理"><a href="#2、自动装配原理" class="headerlink" title="2、自动装配原理"></a>2、自动装配原理</h2><p>在SpringBoot启动类中会加注解<code>@SpringBootApplication</code></p><p>点入注解之后会发现封装了<code>@ComponentScan</code>、<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>注解</p><p><code>@ComponentScan</code>：自动扫描并加载符合条件的Bean到容器中</p><p><code>@SpringBootConfiguration</code>：对<code>Configuration</code>注解的一个封装，指明是配置类</p><p><code>@EnableAutoConfiguration</code>：是主要的，利用<code>@Import</code>注解，将所有符合自动装配条件的bean注入到IOC容器中</p><p>总结：</p><p>@EnableAutoConfiguration作用就是从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。这些功能配置类要生效的话，会去classpath中找是否有该类的依赖类（也就是pom.xml必须有对应功能的jar包才行）并且配置类里面注入了默认属性值类，功能类可以引用并赋默认值。生成功能类的原则是自定义优先，没有自定义时才会使用自动装配类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>AutoConfigurationImportSelector.class</code>类中有个方法<code>selectImports</code>，首先判断是否禁用了自动配置，没有的话就执行以下步骤：</p><ol><li><p>加载META-INF/spring-autoconfigure-metadata.properties文件</p></li><li><p>获取注解的属性及其值（PS：注解指的是@EnableAutoConfiguration注解）</p></li><li><p>在classpath下所有的META-INF/spring.factories文件中查找org.springframework.boot.autoconfigure.EnableAutoConfiguration的值，并将其封装到一个List中返回</p></li><li><p>对上一步返回的List中的元素去重、排序</p></li><li><p>依据第2步中获取的属性值排除一些特定的类</p></li><li><p>对上一步中所得到的List进行过滤，过滤的依据是条件匹配。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="keyword">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础核心概念</title>
      <link href="/2020/05/22/Java/%E6%A6%82%E5%BF%B5/Java%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/05/22/Java/%E6%A6%82%E5%BF%B5/Java%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章专注于Java基础知识，不涉及List、Map、多线程、锁相关的内容，需要的可以查看我的其他博客</p></blockquote><h2 id="JDK-amp-JRE-amp-JVM"><a href="#JDK-amp-JRE-amp-JVM" class="headerlink" title="JDK&amp;JRE&amp;JVM"></a>JDK&amp;JRE&amp;JVM</h2><p>JDK（Java Development Kit）是针对 Java 开发员的产品，是整个 Java 的核心，<strong>包括了 Java 运行环境 JRE、Java 工具（编译、开发工具）和 Java 核心类库</strong>。</p><p>Java Runtime Environment（JRE）是运行 JAVA 程序所必须的环境的集合，<strong>包含 JVM 标准实 现及 Java 核心类库。</strong> </p><p>JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，是整个 java 实现跨平台的最核心的部 分，能够<strong>运行以 Java 语言写作的软件程序</strong></p><h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3><p><strong>字节码是在虚拟机上运行的，而不是编译器。换而言之，是因为 JVM 能跨平台安装，所以 相应JAVA字节码便可以跟着在任何平台上运行。</strong>只要JVM自身的代码能在相应平台上运行， 即 JVM 可行，则 JAVA 的程序员就可以不用考虑所写的程序要在哪里运行，反正都是在虚拟 机上运行，然后变成相应平台的机器语言，而这个转变并不是程序员应该关心的</p><h2 id="一、基本数据类型"><a href="#一、基本数据类型" class="headerlink" title="一、基本数据类型"></a>一、基本数据类型</h2><h3 id="0-1-3精度问题-6-6f-1-3f"><a href="#0-1-3精度问题-6-6f-1-3f" class="headerlink" title="0.1*3精度问题(6.6f+1.3f)"></a>0.1*3精度问题(6.6f+1.3f)</h3><p>可参考这篇：<a href="https://mp.weixin.qq.com/s?__biz=MzIwNTk5NjEzNw==&amp;mid=2247490447&amp;idx=2&amp;sn=ef68a5adbad88fe4012b78356a25bdf5&amp;chksm=97293289a05ebb9f29e9d6c96d9f86d4f4a7bd69c47d6fe92a3591d3c3ab76701b40f544d4e8&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1590383496510&amp;sharer_shareid=d476d18cbe4a83b141ea1ff413565f8c#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIwNTk5NjEzNw==&amp;mid=2247490447&amp;idx=2&amp;sn=ef68a5adbad88fe4012b78356a25bdf5&amp;chksm=97293289a05ebb9f29e9d6c96d9f86d4f4a7bd69c47d6fe92a3591d3c3ab76701b40f544d4e8&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1590383496510&amp;sharer_shareid=d476d18cbe4a83b141ea1ff413565f8c#rd</a></p><h2 id="二、包装类"><a href="#二、包装类" class="headerlink" title="二、包装类"></a>二、包装类</h2><h3 id="2-1-为什么需要包装类"><a href="#2-1-为什么需要包装类" class="headerlink" title="2.1 为什么需要包装类"></a>2.1 为什么需要包装类</h3><p>由于基本数据类型不是对象，所以 java 并不是纯面向对象的语言，好处是效率较高（全部 包装为对象效率较低）。 Java 是一个面向对象的编程语言，<strong>基本类型并不具有对象的性质，为了让基本类型也具有 对象的特征，就出现了包装类型</strong>（如我们在使用集合类型 Collection 时就一定要使用包装类 型而非基本类型），使得它具有了对象的性质，并且<strong>为其 添加了属性和方法，丰富了基本类型的操作</strong>。 </p><h3 id="2-2-自动装箱、自动拆箱（编译器行为）"><a href="#2-2-自动装箱、自动拆箱（编译器行为）" class="headerlink" title="2.2 自动装箱、自动拆箱（编译器行为）"></a>2.2 自动装箱、自动拆箱（编译器行为）</h3><p>自动装箱：可以将基础数据类型包装成对应的包装类</p><p>自动拆箱：可以将包装类转为对应的基础数据类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">10000</span>; <span class="comment">// 编译器会改为 new Integer(10000) </span></span><br><span class="line"><span class="keyword">int</span> i = <span class="keyword">new</span> Integer(<span class="number">1000</span>);<span class="comment">//编译器会修改为 int i = new Integer(1000).intValue();</span></span><br></pre></td></tr></table></figure><p>自动拆箱时如果包装类是 null，那么会抛出 NPE</p><h3 id="2-3-Integer数组范围（-128-127）"><a href="#2-3-Integer数组范围（-128-127）" class="headerlink" title="2.3 Integer数组范围（-128~127）"></a>2.3 Integer数组范围（-128~127）</h3><p>java中如果Integer不是new出Integer对象,而是Integer.valueOf或者直接赋值如：</p><p>​       Integer b1 = 12;</p><p>​       Integer b2 = 12;</p><p>这种情况是在<strong>常量池</strong>中开辟出同一个空间来存储12，所以<strong>b1和b2都指向12</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200522104159.png"  alt=""></p><p>接下来说说，Integer的缓冲范围，因为<strong>不是在堆区new一个对象</strong>，那么在<strong>常量池中就必须对其的大小范围做出一个规定</strong>，就是数值多少的可以存放在缓存内</p><p>如果超出了范围，会从堆区new一个Integer对象来存放值</p><p>源码中static final int low = -128;规定了下限为-128，但是最大范围没有确定下来，上限可以通过设置JDK的AutoBoxCacheMax参数调整。</p><p><strong>所以在比较-128~127内的两个Integer数据时因为都是常量池的对象，所以==或equals都是true；超过这个范围会在堆中new 对象，==比较的是内存地址，返回 false</strong>。</p><h3 id="2-4-与-equals的区别"><a href="#2-4-与-equals的区别" class="headerlink" title="2.4 == 与 equals的区别"></a>2.4 == 与 equals的区别</h3><p>如果两个引用类型变量使用<strong>==运算符</strong>，那么<strong>比较的是地址</strong>，它们分别指向的是否是同一地 址的对象。要求是两个对象都不是空值，与空值比较返回 false。 ==不能实现比较对象的值是否相同(无法重写)。 </p><p>所有对象都有 equals 方法，<strong>默认是 Object 类的 equals</strong>，其<strong>结果与==一样</strong>。 如果希望比较<strong>对象的值相同，必须重写 equals 方法</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-hashCode-与-equals的区别"><a href="#2-5-hashCode-与-equals的区别" class="headerlink" title="2.5 hashCode 与 equals的区别"></a>2.5 hashCode 与 equals的区别</h3><p>Object 中的 equals: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>equals 方法要求满足： </p><p>自反性 a.equals(a) </p><p>对称性 x.equals(y) ==y.equals(x) </p><p>一致性 x.equals(y)     多次调用结果一致 </p><p>对于任意非空引用 x，x.equals(null) 应该返回 false</p><p>Object 中的 hashCode: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>它是一个本地方法，它的实现与本地机器有关，这里我们暂且认为他返回的是对象存储的物理位置。 </p><p>当 equals 方法被重写时，通常有必要重写 hashCode 方法，以维护 <strong>hashCode 方法的常规约定：值相同的对象必须有相同的 hashCode</strong>。 </p><p>object1.equals(object2)为 true，hashCode 也相同； </p><p>hashCode 不同时，object1.equals(object2)为 false； </p><p>hashCode 相同时，object1.equals(object2)不一定为 true；    // 多个key的hash值相同</p><h3 id="2-6-hashCode-与-equals重写问题"><a href="#2-6-hashCode-与-equals重写问题" class="headerlink" title="2.6 hashCode 与 equals重写问题"></a>2.6 hashCode 与 equals重写问题</h3><p>向一个 Hash 结构的集合中添加某个元素时，先调用 hashCode，唯一则存储，不唯一则再调用 equals，结果相同则不再存储，结果不同则散列到其他位置。</p><h4 id="2-6-1-为什么要重写equals-方法？"><a href="#2-6-1-为什么要重写equals-方法？" class="headerlink" title="2.6.1 为什么要重写equals()方法？"></a>2.6.1 为什么要重写equals()方法？</h4><p>因为object中的equals()方法比较的是对象的引用地址是否相等，如果你需要判断对象里的内容是否相等，则需要重写equals()方法。</p><h4 id="2-6-2-为什么改写了equals-，也需要改写hashcode"><a href="#2-6-2-为什么改写了equals-，也需要改写hashcode" class="headerlink" title="2.6.2 为什么改写了equals()，也需要改写hashcode()"></a>2.6.2 为什么改写了equals()，也需要改写hashcode()</h4><p>如果你重写了equals，比如说是基于对象的内容实现的，而保留hashCode的实现（基于内存地址的hash值）不变，那么在添加进map中时需要比对hashcode，很可能某两个对象明明是“相等”，而hashCode却不一样。</p><h4 id="2-6-3-为什么改写了hashcode-，也需要改写equals"><a href="#2-6-3-为什么改写了hashcode-，也需要改写equals" class="headerlink" title="2.6.3 为什么改写了hashcode()，也需要改写equals()"></a>2.6.3 为什么改写了hashcode()，也需要改写equals()</h4><p>改写hashcode()方法是为了让两个值相同的对象hashcode也一样，而不再是基于内存地址，在map中表现为可能是存储在同一位置的一个对象。而如果不改写equals，还是基于内存地址进行比较，这样的话，两个值相同的对象就不被映射到同一位置。</p><p>Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写。</p><h3 id="2-7-String"><a href="#2-7-String" class="headerlink" title="2.7 String"></a>2.7 String</h3><p>String 是 <strong>final 类，不可被继承，也不可重写一个 java.lang.String</strong>（类加载机制）。 一般是使用 StringUtils 来增强 String 的功能。</p><p>字符串<strong>修改的时候会创建一个新的字符串，编译时会将+转为 StringBuilder 的 append 方法</strong>。 注意新的字符串是在运行时在<strong>堆里创建</strong>的。</p><p>String#intern（JDK1.7 之后）<br>JDK1.7 之后 JVM 里字符串常量池放入了堆中，之前是放在方法区。<br><strong>intern()方法设计的初衷，就是重用 String 对象</strong>，以节省内存消耗。 一定是 <strong>new 得到的字符串才会调用 intern</strong>，字符串常量没有必要去 intern。 当调用 intern 方法时，如果<strong>池已经包含</strong>一个等于此 String 对象的字符串（该对象由equals(Object) 方法确定），则<strong>返回池中的字符串</strong>。否则，<strong>常量池中直接存储堆中该字符串 的引用</strong>（1.7 之前是常量池中再保存一份该字符串）。</p><h3 id="2-8-StringBuffer与StringBuilder"><a href="#2-8-StringBuffer与StringBuilder" class="headerlink" title="2.8 StringBuffer与StringBuilder"></a>2.8 StringBuffer与StringBuilder</h3><p>StringBuffer 是线程安全的，StringBuilder 不是线程安全的，但它们两个中的所有方法都是 相同的。StringBuffer 在 StringBuilder 的方法之上添加了 synchronized，保证线程安全。 </p><p>StringBuilder 比 StringBuffer 性能好10%-15%。 </p><h2 id="三、关键字"><a href="#三、关键字" class="headerlink" title="三、关键字"></a>三、关键字</h2><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>可以修饰类，函数，变量。</p><p>被final修饰的类不可以被继承，final类中的方法默认是final的</p><p>被final修饰的方法不能被重写</p><p>被final修饰的变量是一个常量只能赋值一次</p><h3 id="Java中final、finally、finalize的区别与用法"><a href="#Java中final、finally、finalize的区别与用法" class="headerlink" title="Java中final、finally、finalize的区别与用法"></a>Java中final、finally、finalize的区别与用法</h3><p><strong>final：java中的关键字，修饰符。</strong><br>A).如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。<br>B).如果将变量或者方法声明为final，可以保证它们在使用中不被改变.<br>　　1)被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。<br>　　2)被声明final的方法只能使用，不能重载。<br><strong>finally：java的一种异常处理机制。</strong><br>finally是对Java异常处理模型的最佳补充。<strong>finally结构使代码总会执行，而不管无异常发生</strong>。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。<br><strong>finalize：Java中的一个方法名。</strong><br>Java技术使用finalize()方法在<strong>垃圾收集器将对象从内存中清除出去前，做必要的清理工作</strong>。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>一句话来概括：<strong>方便在没有创建对象的情况下来进行调用</strong>。</p><p><strong>修饰内部类、成员变量、成员方法、代码块</strong></p><p><strong>1、static关键字修饰内部类</strong></p><p>java里面static一般用来修饰成员变量或函数。但有一种特殊用法是用<strong>static修饰内部类</strong>，普通类是不允许声明为静态的，只有内部类才可以。下面看看如何使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//static关键字修饰内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">       InnerClass()&#123;</span><br><span class="line">           System.out.println(<span class="string">"====== 静态内部类======"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InnerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"===== 静态内部方法====="</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接通过StaticTest类名访问静态内部类InnerClass</span></span><br><span class="line">        InnerClass inner=<span class="keyword">new</span> StaticTest.InnerClass();</span><br><span class="line">        <span class="comment">//静态内部类可以和普通类一样使用</span></span><br><span class="line">        inner.InnerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出是</span></span><br><span class="line"><span class="comment">* ============= 静态内部类=============</span></span><br><span class="line"><span class="comment">* ============= 静态内部方法=============</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果没有用static修饰InterClass，则只能new 一个外部类实例。再通过外部实例创建内部类。</p><p><strong>成员内部类和静态内部类的区别：</strong> </p><p>1）前者只能拥有非静态成员；后者既可拥有静态成员，又可拥有非静态成员 </p><p>2）前者持有外部类的引用，可以访问外部类的静态成员和非静态成员；后者不持有外部 类的引用，只能访问外部类的静态成员 </p><p>3）前者不能脱离外部类而存在；后者可以</p><p><strong>2、static关键字修饰方法</strong></p><p>修饰方法的时候，其实跟类一样，可以直接通过类名来进行调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"======= 静态方法===="</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方式一：直接通过类名</span></span><br><span class="line">        StaticMethod.test();</span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">        StaticMethod fdd=<span class="keyword">new</span> StaticMethod();</span><br><span class="line">        fdd.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在静态方法中不能访问类的非静态成员变量和非静态成员方法； 在非静态成员方法中是可以访问静态成员方法/变量的； 即使没有显式地声明为 static，类的构造器实际上也是静态方法 </p><p><strong>3、static关键字修饰变量</strong></p><p>被static修饰的成员变量叫做静态变量，也叫做类变量，说明这个变量是属于这个类的，而不是属于是对象，没有被static修饰的成员变量叫做实例变量，说明这个变量是属于某个具体的对象的。</p><p>我们同样可以使用上面的方式进行调用变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticVar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name=<span class="string">"java的架构师技术栈"</span>；</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接通过类名</span></span><br><span class="line">        StaticVar.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态变量和非静态变量的区别是</strong>：静态变量被所有的对象所共享，在内存中只有一个副本， 它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候 被初始化，存在多个副本，各个对象拥有的副本互不影响。<br><strong>静态成员变量并发下不是线程安全的，并且对象是单例的情况下，非静态成员变量也不是线 程安全的</strong>。<br>怎么保证变量的线程安全? 只有一个线程写，其他线程都是读的时候，加 volatile；线程既读又写，可以考虑 Atomic 原 子类和线程安全的集合类；或者考虑 ThreadLocal</p><p><strong>4、static关键字修饰代码块</strong></p><p>用来<strong>构造静态代码块以优化程序性能</strong>。static 块可以置于类中的任何地方，类中可以有多个 static 块。在类初次被加载的时候，会按照 static 块的顺序来执行每个 static 块，并且只会执 行一次。</p><p>静态代码块在类第一次被载入时执行，在这里主要是想验证一下，类初始化的顺序。</p><ul><li>父类静态变量、父类静态代码块</li><li>子类静态变量、子类静态代码块</li><li>父类普通变量、父类普通代码块、父类构造函数</li><li>子类普通变量、子类普通代码块、子类构造函数</li></ul><h2 id="四、面向对象"><a href="#四、面向对象" class="headerlink" title="四、面向对象"></a>四、面向对象</h2><h3 id="4-1-面向对象与面向过程的本质的区别"><a href="#4-1-面向对象与面向过程的本质的区别" class="headerlink" title="4.1 面向对象与面向过程的本质的区别"></a>4.1 面向对象与面向过程的本质的区别</h3><p>在于考虑问题的出发点不同，</p><p>面向过程是以事件流程为考虑问题的出发点，</p><p>而面向对象则是以参与事件的角色（对象）为考虑问题的出发点</p><h3 id="4-2-抽象类与接口"><a href="#4-2-抽象类与接口" class="headerlink" title="4.2 抽象类与接口"></a>4.2 抽象类与接口</h3><p>区别： </p><p>1)抽象类中方法可以不是抽象的；接口中的方法必须是抽象方法； </p><p>2)抽象类中可以有普通的成员变量；接口中的变量必须是 static final 类型的，必须被初始 化 , 接口中只有常量，没有变量。 </p><p>3)抽象类只能单继承，接口可以继承多个父接口； </p><p>4)Java8 中接口中会有 default 方法，即方法可以被实现。</p><p>使用场景： </p><p>如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。 </p><p>如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有 方法定义和成员变量的时候，才应该选择抽象类。</p><p>因为抽象类中允许存在一个或多个被具体 实现的方法，只要方法没有被全部实现该类就仍是抽象类</p><h3 id="4-3-对象三大特性"><a href="#4-3-对象三大特性" class="headerlink" title="4.3 对象三大特性"></a>4.3 对象三大特性</h3><p>面向对象的三个特性：封装；继承；多态 </p><p>封装：将数据与操作数据的方法绑定起来，隐藏实现细节，对外提供接口。 </p><p>继承：代码重用；可扩展性 </p><p>多态：允许不同子类对象对同一消息做出不同响应<br>多态的三个必要条件：<strong>继承、方法的重写、父类引用指向子类对象</strong></p><p><strong>封装</strong><br>封装是指将某事物的属性和行为包装到对象中，这个对象只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p><strong>继承</strong><br>子类继承父类的特征和行为，子类可以有父类的方法和属性，子类也可以对父类进行扩展，也可以提供重写的方法；继承的方式有两种：实现继承和接口继承</p><p><strong>多态</strong><br>多态就是指<strong>多种状态，就是说当一个操作在不同的对象时，会产生不同的结果</strong>。<br>多态分为编译时多态和运行时多态，编译时多态主要指方法的重载，运行时多态指程序中定义的<strong>对象引用所指向的具体类型</strong>在运行期间才确定，运行时多态主要通过重写来实现。<br>多态的作用：消除类型之间的耦合关系。</p><p><strong>那么JAVA的多态是怎么实现的？</strong><br>接口实现、抽象类、继承父类进行方法重写、同一个类中进行方法重载。</p><h3 id="4-4-JAVA中重载与重写的概念？"><a href="#4-4-JAVA中重载与重写的概念？" class="headerlink" title="4.4 JAVA中重载与重写的概念？"></a>4.4 JAVA中重载与重写的概念？</h3><p>（Overload）重载：发生在同一个类之中，<strong>方法名相同、参数列表不同</strong>，与返回值无关、与final无关、与修饰符无关、与异常无关。<br>（Override）重写：发生在子类和父类之间，方法名相同、参数列表相同、返回值相同、不能是final的方法、重写的方法不能有比父类方法更为严格的修饰符权限、重写的方法所抛出的异常不能比父类的更大。</p><h2 id="五、引用"><a href="#五、引用" class="headerlink" title="五、引用"></a>五、引用</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>StringReference GC 时不回收 当内存空间不足，Java 虚拟机<strong>宁愿抛出 OutOfMemoryError 错误</strong>，使程序异常终止，也不会 靠<strong>随意回收具有强引用的对象</strong>来解决内存不足问题。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>SoftReference GC 时如果 JVM <strong>内存不足时会回收 软引用</strong>可用来<strong>实现内存敏感的高速缓存</strong>。 软引用可以和一个引用队列（ReferenceQueue） 联合使用，如果软引用所引用的对象被垃圾回收，Java 虚拟机就会把这个软引用加入到与 之关联的引用队列中。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>WeakReference <strong>GC 时立即回收</strong> 弱引用与软引用的区别在于：<strong>只具有弱引用的对象拥有更短暂的生命周期</strong>。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃 圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>PhantomReference 如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在<strong>任何时候都可能被垃圾回收</strong>。 虚引用主要用来<strong>跟踪对象被垃圾回收的活动</strong>。虚引用与软引用和弱引用的一个区别在于：<strong>虚 引用必须和引用队列（ReferenceQueue）联合使用</strong>。当垃圾回收器准备回收一个对象时， 如果发现它还有虚引用，就会<strong>在回收对象的内存之前，把这个虚引用加入到与之关联的引用 队列中</strong>。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将 要被垃圾回收。<strong>程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对 象的内存被回收之前采取必要的行动</strong>。 </p><h2 id="六、ThreadLocal"><a href="#六、ThreadLocal" class="headerlink" title="六、ThreadLocal"></a>六、ThreadLocal</h2><p>在线程之间共享变量是存在风险的，有时可能要避免共享变量，使用 ThreadLocal 辅助类为 各个线程提供各自的实例。 </p><p>每个线程内部都会维护一个类似 HashMap 的对象，称为 <strong>ThreadLocalMap</strong>，里边会包含 若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程； Entry 的 <strong>Key 是一个 ThreadLocal 实例</strong>，Value 是一个<strong>线程特有对象</strong>。Entry 的作用即是： 为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系； <strong>Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用</strong>。</p><p><strong>ThreadLocalMap 的 Key 是弱引用</strong>，如果是强引用，ThreadLocal 将无法被释放内存。 因为如果这里使用普通的 key-value 形式来定义存储结构，实质上就会造成节点的生命周期 与线程强绑定，<strong>只要线程没有销毁，那么节点在 GC 分析中一直处于可达状态，没办法被回 收</strong>，而程序本身也无法判断是否可以清理节点。弱引用是 Java 中四档引用的第三档，比软 引用更加弱一些，如果一个对象没有强引用链可达，那么一般活不过下一次 GC。当某个 ThreadLocal 已经没有强引用可达，则随着它被垃圾回收，在 ThreadLocalMap 里对应的 Entry 的键值会失效，这为 ThreadLocalMap 本身的垃圾清理提供了便利</p><h2 id="七、异常"><a href="#七、异常" class="headerlink" title="七、异常"></a>七、异常</h2><h3 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p>会执行</p><p>1、不管有没有异常，finally中的代码都会执行<br>2、当try、catch中有return时，finally中的代码依然会继续执行<br>3、finally是在return后面的表达式运算之后执行的，此时并<strong>没有return运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值</strong>。也就是说方法的返回值是在finally运算之前就确定了的。<br>4、如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，<strong>try中的return语句返回的就是在finally中改变后的该属性的值</strong>。<br>5、finally代码中最好不要包含return，<strong>程序会提前退出，也就是说返回的值不是try或catch中的值</strong></p><h2 id="八、反射"><a href="#八、反射" class="headerlink" title="八、反射"></a>八、反射</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Java 中的反射机制是指<strong>在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；</strong>这种动态获取信息以及动态调用对象方 法的功能称为Java 语言的反射机制</p><h3 id="Java反射机制的作用？"><a href="#Java反射机制的作用？" class="headerlink" title="Java反射机制的作用？"></a>Java反射机制的作用？</h3><p>应用场合：在Java程序中许多对象在运行是都会出现两种类型：<strong>编译时类型和运行时类型</strong>。 编译时的类型由 声明对象时用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如Person p=new Student();<br>其中编译时类型为Person，运行时类型为Student</p><p>程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为 Object,但是程序有需要调用 该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。 此时就必须使用到反射了 。</p><p><strong>总结</strong></p><ol><li><p>在运行时能够判断任意一个对象所属的类、创建新类对象</p></li><li><p>在运行时构造任意一个类的对象、判断任意一个类所具有的成员变量和方法</p></li><li><p>在运行时调用任一对象的方法</p></li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>JDBC中，利用反射动态加载了数据库驱动程序。</p><p>很多框架都用到反射机制，注入属性，调用方法，如Spring。</p><p>Web服务器中利用反射调用了Sevlet的服务方法。</p><p>读取配置文件</p><h3 id="如何使用Java的反射"><a href="#如何使用Java的反射" class="headerlink" title="如何使用Java的反射?"></a>如何使用Java的反射?</h3><p><strong>获得Class对象的三种方法</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200526181429"  alt="在这里插入图片描述"></p><p><strong>创建对象的两种方法</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200526181457"  alt="在这里插入图片描述"></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200526183203"  alt="在这里插入图片描述"></p><h3 id="反射机制的优缺点？"><a href="#反射机制的优缺点？" class="headerlink" title="反射机制的优缺点？"></a>反射机制的优缺点？</h3><p><strong>优点</strong>：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了java的灵活性。<br><strong>缺点</strong>：对性能有影响，这类操作总是慢于直接执行java代码。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组题目合集</title>
      <link href="/2020/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/"/>
      <url>/2020/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="使奇数在前，偶数在后"><a href="#使奇数在前，偶数在后" class="headerlink" title="使奇数在前，偶数在后"></a><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">使奇数在前，偶数在后</a></h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p>解法：遍历一遍获取奇数个数oddCount；新建一个数组，第二次遍历遇到偶数则从数组oddCount位置开始存偶数；最后赋值回原数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>||array.length==<span class="number">1</span>)&#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> oddCount=<span class="number">0</span>,oddBegin=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                oddCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((array[i]&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                newArray[oddBegin++]=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                newArray[oddCount++]=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            array[i]=newArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转数组的最小元素"><a href="#旋转数组的最小元素" class="headerlink" title="旋转数组的最小元素"></a>旋转数组的最小元素</h3><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote><p>要注意的是12行的判断条件，<code>array[mid] &lt;= array[right]</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &lt;= array[right])&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h3><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）</p></blockquote><p>剑指的思路： </p><p>  <strong>B[i]的值可以看作下图的矩阵中每行的乘积。</strong></p><p>  下三角用连乘可以很容求得，上三角，从下向上也是连乘。 </p><p>  因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200601224653"  alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] * A[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = len - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            temp = temp * A[j+<span class="number">1</span>];</span><br><span class="line">            B[j] = B[j] * temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表题目总结</title>
      <link href="/2020/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="链表倒数第k个结点"><a href="#链表倒数第k个结点" class="headerlink" title="链表倒数第k个结点"></a>链表倒数第k个结点</h3><p>输入一个链表，输出该链表中倒数第k个结点。</p><p>解法：声明两个指针都指向头结点，其中一个指针cur在前一个指针pre走了k个之后在走，这样当前一个指针pre到达尾巴了，当前指针cur也就到了-k个位置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode pre = head;    </span><br><span class="line">        ListNode out = head;    <span class="comment">// 头结点存有元素</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="keyword">null</span>)&#123;    </span><br><span class="line">            count++;</span><br><span class="line">            pre = pre.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count &gt; k)&#123;    <span class="comment">// 让pre先走了count步后，out才开始走</span></span><br><span class="line">                out = out.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || k &gt; count)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从头到尾打印链表"><a href="#从头到尾打印链表" class="headerlink" title="从头到尾打印链表"></a><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">从头到尾打印链表</a></h3><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>递归法，需要注意的是list不能用static声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈存放</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode p = listNode;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(p.val);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            list.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">反转链表</a></h3><p>输入一个链表，反转链表后，输出新链表的表头。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里有个需要注意的地方，就是如果两个判断合在一起</span></span><br><span class="line">        <span class="comment">// 即if(head == null || head.next == null) return head</span></span><br><span class="line">        <span class="comment">// head == null 需要在前！如果head已经是null了，它的next肯定也是null，只不过好像返回值不同</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = p.next;</span><br><span class="line">            p.next = q;</span><br><span class="line">            q = p;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈单点登录</title>
      <link href="/2020/05/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/%E8%B0%88%E8%B0%88%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2020/05/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/%E8%B0%88%E8%B0%88%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 转载自<a href="https://zhuanlan.zhihu.com/p/66037342" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66037342</a></p></blockquote><h2 id="一、单系统登录"><a href="#一、单系统登录" class="headerlink" title="一、单系统登录"></a>一、单系统登录</h2><p>HTTP是<strong>无状态</strong>的协议，这意味着<strong>服务器无法确认用户的信息</strong>。于是，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是<strong>Cookie</strong>。</p><p>如果说Cookie是检查用户身上的”通行证“来确认用户的身份，那么Session就是通过检查服务器上的”客户明细表“来确认用户的身份的。<strong>Session相当于在服务器中建立了一份“客户明细表”</strong>。</p><p>HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一个用户。于是服务器向用户浏览器发送了一个名为JESSIONID的Cookie，它的值是Session的id值。<strong>其实Session是依据Cookie来识别是否是同一个用户</strong>。</p><p>所以，一般我们单系统实现登录会这样做：</p><ul><li><p><strong>登录</strong>：将用户信息保存在Session对象中</p></li><li><ul><li>如果在Session对象中能查到，说明已经登录</li><li>如果在Session对象中查不到，说明没登录（或者已经退出了登录）</li></ul></li><li><p><strong>注销（退出登录）</strong>：从Session中删除用户的信息</p></li><li><p><strong>记住我（关闭掉浏览器后，重新打开浏览器还能保持登录状态）</strong>：配合Cookie来用</p></li></ul><h2 id="二、单点登录"><a href="#二、单点登录" class="headerlink" title="二、单点登录"></a>二、单点登录</h2><p>单点登录要解决的问题就是一个子系统登录了，其它子系统就不必再登陆。</p><p>之前的做法是判断session里有没有用户信息了，有就说明已经登录了；没有就说明没有登录。单登陆系统因为Session是存在一台服务器上的，所以只有一个Session，但分布式系统有多个Session，需要让多个子系统共用一个Session才行，这能做到但是不合理。</p><p>于是就采用将登陆功能单独抽取出来，每个子系统登陆都把请求发送到该登陆系统。登陆系统在用户第一次登陆之后，随机生成uuid作为key，user信息作为value存入redis，设置过期时间，这样就保留了这次的登陆信息，同时把这个uuid写入客户端的Cookie。之后其它子系统在发起请求时携带着cookie，会先向登陆系统发起请求，如果登陆系统中的redis存在这条uuid对应的用户信息，说明目前已经登录了，则放行直接登陆，否则重定向到登陆页面。</p><h3 id="2-1-Session不共享问题"><a href="#2-1-Session不共享问题" class="headerlink" title="2.1 Session不共享问题"></a>2.1 Session不共享问题</h3><p>以往单系统登录功能主要是用Session保存用户信息来实现的，但我们清楚的是：多系统即可能有多个Tomcat，而Session是依赖当前系统的Tomcat，所以系统A的Session和系统B的Session是<strong>不共享</strong>的。那么就需要有一个机制能够做到<strong>一个系统登录后，其它系统不用再重复登录</strong>。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521145550.png"  alt="img"></p><p>解决系统之间Session不共享问题有一下几种方案：</p><ul><li>Tomcat集群Session全局复制（集群内每个tomcat的session完全同步）【会影响集群的性能呢，不建议】</li><li>根据请求的IP进行<strong>Hash映射</strong>到对应的机器上（这就相当于请求的IP一直会访问同一个服务器）【如果服务器宕机了，会丢失了一大部分Session的数据，不建议】</li><li>把Session数据放在Redis中（使用Redis模拟Session）【<strong>建议</strong>】</li></ul><p>我们可以将登录功能<strong>单独抽取</strong>出来，做成一个子系统。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521145732.png"  alt=""></p><p>这样，当登录SSO系统的时候，验证核对密码后，将随机生成的token作为key，以及用户信息作为value写入redis。这样服务器就会保留这次的登陆信息。</p><p>其它子系统登录时，将请求转发给SSO进行登陆，因为SSO系统的redis有存token以及用户信息，所以验证之后可以得到token，再把token写入到子系统的cookie中（或者在上一步骤服务器就把token写入客户端也行，这次就直接携带含token的cookie就行；在这一步写cookie的话，需要在请求中携带用户名，密码用于验证，验证通过才写入Cookie）</p><p>此后，每次请求时，Cookie都会带上token，拦截器得到token，判断是否已经登录</p><p>到这里，其实我们会发现其实就两个变化：</p><ul><li>将登陆功能抽取为一个系统（SSO），其他系统请求SSO进行登录</li><li>本来将用户信息存到Session，现在将用户信息存到Redis</li></ul><h3 id="2-2-Cookie跨域的问题"><a href="#2-2-Cookie跨域的问题" class="headerlink" title="2.2 Cookie跨域的问题"></a>2.2 Cookie跨域的问题</h3><p>上面我们解决了Session不能共享的问题，但其实还有另一个问题。<strong>Cookie是不能跨域的</strong></p><p>比如说，我们请求<code>https://www.google.com/</code>时，浏览器会自动把<code>google.com</code>的Cookie带过去给<code>google</code>的服务器，而不会把<code>https://www.baidu.com/</code>的Cookie带过去给<code>google</code>的服务器。</p><p>这就意味着，<strong>由于域名不同</strong>，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。</p><p>针对Cookie存在跨域问题，有几种解决方案：</p><ol><li>服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了</li><li><strong>多个域名共享Cookie，在写到客户端的时候设置Cookie的domain</strong>。</li><li>将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了）</li></ol><p>到这里，我们已经可以实现单点登录了。</p><h3 id="2-3-CAS原理"><a href="#2-3-CAS原理" class="headerlink" title="2.3 CAS原理"></a>2.3 CAS原理</h3><p>说到单点登录，就肯定会见到这个名词：CAS （Central Authentication Service），下面说说CAS是怎么搞的。</p><p><strong>如果已经将登录单独抽取成系统出来</strong>，我们还能这样玩。现在我们有两个系统，分别是<code>www.java3y.com</code>和<code>www.java4y.com</code>，一个SSO<code>www.sso.com</code></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521162524.png"  alt="img"></p><p>首先，用户想要访问系统A<code>www.java3y.com</code>受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统A<code>www.java3y.com</code>发现用户并没有登录，于是<strong>重定向到sso认证中心，并将自己的地址作为参数</strong>。请求的地址如下：</p><ul><li><code>www.sso.com?service=www.java3y.com</code></li></ul><p>sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立<strong>全局会话（生成一份Token，写到Cookie中，保存在浏览器上）</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521162601.png"  alt="img"></p><p>随后，认证中心<strong>重定向回系统A</strong>，并把Token携带过去给系统A，重定向的地址如下：</p><ul><li><code>www.java3y.com?token=xxxxxxx</code></li></ul><p>接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（<strong>创建Session</strong>）。到此，系统A和用户已经是登录状态了。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521162619.png"  alt="img"></p><p>此时，用户想要访问系统B<code>www.java4y.com</code>受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统B<code>www.java4y.com</code>发现用户并没有登录，于是<strong>重定向到sso认证中心，并将自己的地址作为参数</strong>。请求的地址如下：</p><ul><li><code>www.sso.com?service=www.java4y.com</code></li></ul><p>注意，因为之前用户与认证中心<code>www.sso.com</code>已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B<strong>重定向</strong>到认证中心<code>www.sso.com</code>是可以带上Cookie的。</p><p>认证中心<strong>根据带过来的Cookie</strong>发现已经与用户建立了全局会话了，认证中心<strong>重定向回系统B</strong>，并把Token携带过去给系统B，重定向的地址如下：</p><ul><li><code>www.java4y.com?token=xxxxxxx</code></li></ul><p>接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（<strong>创建Session</strong>）。到此，系统B和用户已经是登录状态了。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521162639.png"  alt="img"></p><p>看到这里，其实SSO认证中心就类似一个<strong>中转站</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解同步、异步、阻塞和非阻塞</title>
      <link href="/2020/05/21/Java/Java%20IO%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/21/Java/Java%20IO%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="理解同步、异步、阻塞和非阻塞"><a href="#理解同步、异步、阻塞和非阻塞" class="headerlink" title="理解同步、异步、阻塞和非阻塞"></a>理解同步、异步、阻塞和非阻塞</h1><p>关于同步、异步、阻塞和非阻塞这个概念性问题，这可能是非常容易混淆的概念之一，特别是那些刚开始解除网络编程的人来说。本篇文章争取来说清楚这个问题，如果有错误之处，恳请批评指正。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>首先大家心中需要有以下的清晰认知：</p><ul><li><strong>阻塞操作不等于同步</strong>（blocking operation does NOT equal to synchronous）</li><li><strong>非阻塞操作不等于异步</strong>（non-blocking operation does NOT equal to asynchronous）</li></ul><p>事实上，同步异步于阻塞和非阻塞没有什么直接的关联关系。</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步和异步关注的是 <strong>通信机制</strong> (communication mechanism)</p><ul><li><strong>同步</strong>是指在发出一个<em>function调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到调用结果了。这个结果可能是一个正确的期望结果，也可能是因为异常原因（比如超时）导致的失败结果。换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</li></ul><blockquote><p>Synchronous is, when we started a function call, the call will not return anything until it gets the result, the function needs to finish everything before it can give anything to us.</p></blockquote><ul><li><strong>异步</strong>是调用在发出之后，本次调用过程就直接返回了，并没有同时没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态变化、事件通知等机制来通知调用者，或通过回调函数处理这个调用。</li></ul><blockquote><p>Asynchronous does not need to wait for the function completes its operation, once we call it, it returns immediately without any result, the function uses callback function (or other notification method) to “notify” us to get the value after it completes execution.</p></blockquote><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞和非阻塞关注的是 <strong>程序在等待调用结果（消息、返回值）时的状态.</strong></p><blockquote><p>Unlike synchronous/asynchronous, blocking/non-blocking focuses on the status of the program while waiting for the result from the function call.</p></blockquote><ul><li><strong>阻塞</strong>调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回</li></ul><blockquote><p>A blocking operation <strong>hangs up</strong> current thread before it gets the result, in other words, a blocking operation will let the current thread wait for the result returns, even if the target function will use a callback function to notify client side to fetch the result, the thread on the client side will still be blocked until it gets the returned result.</p></blockquote><ul><li><strong>非阻塞</strong>是指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li></ul><blockquote><p>the non-blocking operation will <strong>not hang up</strong> the current thread if no result returned immediately.</p></blockquote><p>对unix操作系统来讲：</p><ul><li>阻塞式I/O(默认)，非阻塞式I/O(nonblock)，I/O复用(select/poll/epoll)都属于同步I/O，因为它们在操作系统将数据由内核缓冲区复制到用户空间缓冲区时都是阻塞的(不能干别的事)。</li><li>只有异步I/O模型(AIO)是符合异步I/O操作的含义的，即在数据准备完成以后，由内核空间拷贝回用户缓冲区后再通知通知用户进程，而用户进程在等待通知的这段时间里可以干别的事。</li></ul><ul><li>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li><li>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</li><li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的浅拷贝与深拷贝</title>
      <link href="/2020/05/21/Java/Java%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2020/05/21/Java/Java%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java 中的数据类型分为基本数据类型和引用数据类型。对于这两种数据类型，在进行赋值操作、用作方法参数或返回值时，会有值传递和引用（地址）传递的差别。</p></blockquote><h2 id="一、拷贝分类"><a href="#一、拷贝分类" class="headerlink" title="一、拷贝分类"></a>一、拷贝分类</h2><ul><li>引用拷贝 （==）</li><li>对象拷贝 （.clone()）</li><li>浅拷贝（.clone()）</li><li>深拷贝（.clone().clone()）</li></ul><p><strong>注意：浅拷贝与深拷贝都属于对象拷贝</strong></p><p>浅拷贝：基本数据类型拷贝值，引用类型拷贝内存地址，修改基本数据类型不会对原对象产生影响，修改引用类型会对原对象产生影响。被拷贝对象通过实现 <code>Cloneable</code> 并重写 <code>clone()</code> 方法来实现浅拷贝。</p><p>深拷贝：基本数据类型拷贝值，引用类型拷贝会新建一个对象空间（新地址）拷贝里面的内容，修改基本数据类型和修改引用类型都不会对原对象产生影响。有多层对象的，每个对象都需要实现 <code>Cloneable</code> 并重写 <code>clone()</code> 方法，进而实现了对象的串行层层拷贝。</p><h2 id="二、引用拷贝"><a href="#二、引用拷贝" class="headerlink" title="二、引用拷贝"></a>二、引用拷贝</h2><p>拷贝的是内存地址，所以更改拷贝值也会更改原值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">"Taylor"</span>,<span class="number">26</span>);</span><br><span class="line">Teacher otherteacher = teacher;</span><br><span class="line">System.out.println(teacher);</span><br><span class="line">System.out.println(otherteacher);</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">blog.Teacher@<span class="number">355</span>da254</span><br><span class="line">blog.Teacher@<span class="number">355</span>da254</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521114815.png"  alt=""></p><h2 id="三、对象拷贝"><a href="#三、对象拷贝" class="headerlink" title="三、对象拷贝"></a>三、对象拷贝</h2><p>地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个新的引用变量,这就叫做对象拷贝（浅拷贝的默认实现）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">"Swift"</span>,<span class="number">26</span>);</span><br><span class="line">Teacher otherteacher = (Teacher)teacher.clone();</span><br><span class="line">System.out.println(teacher);</span><br><span class="line">System.out.println(otherteacher);</span><br><span class="line"></span><br><span class="line">blog.Teacher@<span class="number">355</span>da254</span><br><span class="line">blog.Teacher@<span class="number">4</span>dc63996</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521115052.png"  alt=""></p><h3 id="3-1-浅拷贝"><a href="#3-1-浅拷贝" class="headerlink" title="3.1 浅拷贝"></a>3.1 浅拷贝</h3><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是<strong>基本类型，拷贝的就是基本类型的值</strong>；如果属性是内存地址（<strong>引用类型</strong>），拷贝的就是内存地址 ，因此如果其中一个对象<strong>改变了这个地址，就会影响到另一个对象</strong>。即<strong>默认拷贝构造函数只是对对象进行浅拷贝</strong>复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</p><h3 id="3-2-深拷贝"><a href="#3-2-深拷贝" class="headerlink" title="3.2 深拷贝"></a>3.2 深拷贝</h3><p>深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。<strong>基础数据类型或者引用类型，对其中一个对象修改该值，不会影响另外一个</strong>。每个对象都需要实现 <code>Cloneable</code> 并重写 <code>clone()</code> 方法，进而实现了对象的串行层层拷贝。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深浅拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解synchronized</title>
      <link href="/2020/05/21/Java/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3Synchronized/"/>
      <url>/2020/05/21/Java/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3Synchronized/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Synchronized锁简介"><a href="#一、Synchronized锁简介" class="headerlink" title="一、Synchronized锁简介"></a>一、Synchronized锁简介</h2><p>Java的关键字，jvm层面上，可重入，不可中断，非公平的锁。</p><p>JDK1.6之前加重量级锁，每次加锁都通过监视器(monitor)来实现，但监视器本质又依赖于操作系统Mutex Lock实现，涉及到用户态和内核态的切换，消耗较高；</p><p>JDK1.6之后加锁分为加偏向锁和加轻量级锁，当没有线程竞争的时候加偏向锁，在只有两个线程交替执行同步块的时候加轻量级锁，多个线程竞争升级到重量级锁。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200610174532"  alt=""></p><p><strong>实现原理</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200524185543.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200524185642.png"  alt=""></p><p>monitorenter 和 monitorexit 是上层指令，底层实现可能是偏向锁、轻量级锁、重量级锁 等</p><h3 id="1-1-锁升级的过程"><a href="#1-1-锁升级的过程" class="headerlink" title="1.1 锁升级的过程"></a>1.1 锁升级的过程</h3><p><strong>加偏向锁的过程</strong></p><p>一个线程访问同步块并获取锁时，会在<strong>对象头里存储锁偏向的线程ID</strong>，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程</p><p>偏向锁使用了一种<strong>等到竞争出现才释放锁</strong>的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><p>关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。</p><p><strong>加轻量级锁的过程</strong></p><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中<strong>创建用于存储锁记录的空间</strong>，并将对象头中的Mark Word复制到锁记录中。然后线程尝试使用CAS<strong>将对象头中的Mark Word替换为指向锁记录的指针</strong>，<strong>并将 Lock Record 里的 owner 指针指向对象的 Mark Word</strong>。如果成功，当前线程获得锁，对象 Mark Word 的锁标志位设置为“00”；如果失败，表示其他线程竞争锁，当前线程则自旋重试。重试一定次数后则膨胀为重量级锁（修改Mark Word，改为指向重量级锁的指针）</p><p><strong>膨胀到重量级锁的过程</strong></p><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</p><p><strong>重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。</strong></p><p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p><h2 id="二、三种作用范围"><a href="#二、三种作用范围" class="headerlink" title="二、三种作用范围"></a>二、三种作用范围</h2><ol><li>在静态方法上加锁；</li><li>在非静态方法上加锁；</li><li>在代码块上加锁；</li></ol><p>下面是这三种情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    privatestaticint money = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">noStaticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        money++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        money++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codeBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            money++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么经常会有面试题问这三种作用范围是加在哪</p><p>我在网上看到比较普遍的一种答案是</p><ol><li>在静态方法上加锁；——–锁类</li><li>在非静态方法上加锁；—–锁对象</li><li>在代码块上加锁；———–锁对象</li></ol><p>这种说法不能说错的，但是不准确的！首先明确一点：<strong>锁是加在对象上面的</strong>，我们是在<strong>对象</strong>上加锁</p><table><thead><tr><th align="left">作用范围</th><th align="left">锁对象</th></tr></thead><tbody><tr><td align="left">非静态方法</td><td align="left">当前对象 =&gt; this</td></tr><tr><td align="left">静态方法</td><td align="left">类对象  =&gt; SynchronizedSample.class （一切皆对象，这个是类对象）</td></tr><tr><td align="left">代码块</td><td align="left">指定对象 =&gt; obj（以上面的代码为例）</td></tr></tbody></table><h3 id="2-1-底层实现"><a href="#2-1-底层实现" class="headerlink" title="2.1 底层实现"></a>2.1 底层实现</h3><p>synchronized 在代码块上是通过 monitorenter 和 monitorexit指令实现。在方法内部遇到monitorenter指令开始加锁。在静态方法和 方法上加锁是在方法的flags 中加入 ACC_SYNCHRONIZED 。JVM 运行方法时检查方法的flags，遇到同步标识开始启动加锁流程，当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象</p><p><img src="/" class="lazyload" data-src="https://mmbiz.qpic.cn/mmbiz_png/SoGf97KLurAicd1Y2Vmx8AMVibe6YvE8giaLGTQYb7aPBeEJRgicQ70zKWqQnnXhOIicicCShRLWMb8ANic8OxALQDozg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"  alt="img"></p><p>monitorenter/monitorexit</p><p>monitorenter指令时，首先要去尝试获取对象的锁。如果 这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，而在执行 monitorexit指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象 锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止</p><p>monitorenter 和 monitorexit 是上层指令，底层实现可能是偏向锁、轻量级锁、重量级锁 等。 </p><p><strong>那以代码块加重量级锁解释下为什么其它线程就不能访问了：</strong></p><p>当前对象A，声明了个用来给自己作为锁的<strong>obj对象</strong>，当A有一段代码需要同步时，就对obj加锁。这段代码前后也就标识了monitorenter 和 monitorexit指令，触发了争夺锁的机制，如果成功则让与obj关联的monitor监视器对象的owner指针指向A，同时将A对象头的markword中重量级锁需要的<strong>监视器地址</strong>设置为obj关联的monitor对象地址，这样monitor知道谁拥有对象锁，线程A也知道自己有monitor也就有锁了。其它线程在进入这个方法前，争夺obj的monitor，失败就被阻塞，直到下一次参与竞争。</p><h2 id="三、synchronized-实现原理"><a href="#三、synchronized-实现原理" class="headerlink" title="三、synchronized 实现原理"></a>三、synchronized 实现原理</h2><p>上面说了，遇到monitorenter指令或者ACC_synchronized时会加锁，首先要去尝试获取对象的锁，这个锁就是我们现在要讲的对象监视器。</p><h3 id="3-1-先了解下Mark-Word和Monitor对象"><a href="#3-1-先了解下Mark-Word和Monitor对象" class="headerlink" title="3.1 先了解下Mark Word和Monitor对象"></a>3.1 先了解下Mark Word和Monitor对象</h3><h4 id="3-1-1-Mark-Word"><a href="#3-1-1-Mark-Word" class="headerlink" title="3.1.1 Mark Word"></a>3.1.1 Mark Word</h4><p>首先synchronized 锁 和 对象头息息相关。Java 对象头，锁的类型和状态和对象头的Mark Word息息相关；</p><p>synchronized 锁  – 对象头 – Mark Word</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521094822.png"  alt="img"></p><p>Mard Word存储对象的hashCode、锁信息或分代年龄或GC标志等信息</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521095829.png"  alt=""></p><p><strong>这里大家注意重量级锁需要有个指向互斥量的指针，这里的互斥量指的就是下面要说的ObjectMonitor</strong>，我更喜欢把它叫做<strong>内置锁</strong>，更能表达含义。轻量级有个<strong>指向栈中锁记录的指针</strong>，偏向锁有个<strong>线程ID、Epoch</strong>以及用来区别无锁的字段（因为锁标志位都是00）。那是不是意味着满足对应条件就能实现加对应锁？</p><h4 id="3-1-2-Monitor"><a href="#3-1-2-Monitor" class="headerlink" title="3.1.2 Monitor"></a>3.1.2 Monitor</h4><p>每个对象都有一个与之关联的Monitor 对象，即内置锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>;   <span class="comment">// 重入次数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,   <span class="comment">// 等待线程数</span></span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;  <span class="comment">// 当前持有锁的线程</span></span><br><span class="line">    _WaitSet      = NULL;  <span class="comment">// 调用了 wait 方法的线程被阻塞 放置在这里</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">// 等待锁 处于block的线程 有资格成为候选资源的线程</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看这个代码以及注释，先不看下面的解析，思考下这些变量的含义。以下这段是我的猜想（<strong>是有误的</strong>）</p><p>_count：重入次数代表是可重入的，且重入一次，_count++，退出的时候也要退出到count==0；</p><p>_owner：拥有当前锁的线程，说明获取锁了，这个需要指向线程吧；</p><p>_WaitSet：阻塞队列？不懂，但从名字可以想到和wait有关，应该是调用wait方法被阻塞的线程存放的队列；</p><p>_EntryList：和_WaitSet一样，是阻塞队列还是等待队列？这里看不出来</p><p>根据这些注释，我们大概有了点思路，多线程竞争锁，竞争不到，则会被放入队列中，竞争到了则会被指向，并且还是可重入的。至于上面的猜想是否正确，可以继续往下看。</p><p><strong>对象关联的 ObjectMonitor 对象监视器有一个线程内部竞争锁的机制</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521095507.png"  alt=""></p><h3 id="3-2-JDK-6-以前-synchronized实现原理"><a href="#3-2-JDK-6-以前-synchronized实现原理" class="headerlink" title="3.2 JDK 6 以前 synchronized实现原理"></a>3.2 JDK 6 以前 synchronized实现原理</h3><p> JDK 6 以前 synchronized即通过<strong>重量级锁</strong>实现，而这些操作的实现又依赖于操作系统底层的Mutex Lock。</p><h4 id="3-2-1-重量级锁实现原理"><a href="#3-2-1-重量级锁实现原理" class="headerlink" title="3.2.1 重量级锁实现原理"></a>3.2.1 重量级锁实现原理</h4><p>过程：</p><ol><li>JVM每次会从队列尾部取出数据作为OnDeck竞争者，但在并发情况下Contention List会被大量进程CAS访问</li><li>为了降低尾部竞争，Owner线程在unlock时，Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中;</li><li><strong>从EntryList取出一个线程放到OnDeck作为候选者</strong>；</li><li>任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck;</li><li>当前已经获取到所资源的线程被称为 Owner;</li><li>Owner调用wait被阻塞，则进入WaitSet队列，等待被notify唤醒进入EntryList</li><li><strong>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态</strong>，该阻塞是由操作系统来完成的(Linux 内核下采用 <code>pthread_mutex_lock</code> 内核函数实现的);</li></ol><p>举例：</p><p>A线程抢先拿到了锁。拿到锁的步骤为：</p><ol><li>将 <code>MonitorObject</code> 中的 _owner设置成 A线程；</li><li><strong>将 mark word 设置为 Monitor 对象地址，锁标志位改为10(重量级锁)</strong>；</li><li>将B线程阻塞放到 ContentionList 队列；</li><li>作为Owner 的A 线程执行过程中，可能调用wait 释放锁，这个时候A线程进入 Wait Set , 等待被唤醒</li></ol><p>其实讲了这么多，最主要的一点是还记得刚讲过的MarkWord中重量级锁需要的字段嘛？<strong>指向互斥量（monitor、对象监视器）的指针</strong>，所以当线程中某个对象获取到锁了，就把该对象的MarkWord重量级锁字段指向monitor对象</p><h3 id="3-3-JDK-6-之后-synchronized实现原理"><a href="#3-3-JDK-6-之后-synchronized实现原理" class="headerlink" title="3.3 JDK 6 之后 synchronized实现原理"></a>3.3 JDK 6 之后 synchronized实现原理</h3><p>由于 synchronized 重量级锁有以下二个问题, 因此JDK 6 之后做了改进，引入了偏向锁和轻量级锁：</p><ol><li>JDK6 以前，synchronized 那时还属于重量级锁，<strong>每次加锁都依赖操作系统Mutex Lock实现</strong>，涉及到操作系统让线程从用户态切换到内核态，切换成本很高；</li><li>到了JDK6，研究人员引入了偏向锁和轻量级锁，因为Sun 程序员发现大部分程序大多数时间都不会发生多个线程同时访问竞态资源的情况，每次线程都加锁解锁，每次这么搞都要操作系统在用户态和内核态之前来回切，太耗性能了。偏向锁通过…进行加锁，轻量级锁通过…加锁</li></ol><h4 id="3-3-1-偏向锁实现原理"><a href="#3-3-1-偏向锁实现原理" class="headerlink" title="3.3.1 偏向锁实现原理"></a>3.3.1 偏向锁实现原理</h4><p>偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起 来让这个线程得到了偏护。这个<strong>线程在之后获取该锁就不再需要进行同步操作</strong>，甚至连 CAS 操作也不再需要。</p><p>当一个线程访问同步代码块并获取锁时，会在 <strong>Mark Word 里存储锁偏向的线程 ID</strong>。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</p><p>关于偏向锁的撤销，需要<strong>等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程</strong>，然后判断锁对象是否处于被锁定状态。如果线<strong>程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁</strong>，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。</p><h4 id="3-3-2-轻量级锁实现原理"><a href="#3-3-2-轻量级锁实现原理" class="headerlink" title="3.3.2 轻量级锁实现原理"></a>3.3.2 轻量级锁实现原理</h4><p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，它使用 CAS 操作来避免重量级锁使用互斥量的开销。但是，首先需要强调一点的是， 轻量级锁并不是用来代替重量级锁的，它的本意是在<strong>没有多线程竞争的前提下，减少传统的重量 级锁使用产生的性能消耗</strong>。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所<strong>适应的场 景是线程交替执行同步块</strong>的情况（整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步），<strong>如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀 为重量级锁</strong>（ CAS 失败了再改用互斥量进行同步）。</p><p>JVM会现在当前线程的栈桢中创建用于存储锁记录的空间 LockRecord，将对象头中的 Mark Word 复制到 LockRecord 中并将 LockRecord 中的 Owner 指针指向锁对象。然后线程会尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，成功则当前线程获取到锁，失败则表示其他线程竞争锁当前线程则尝试使用自旋的方式获取锁。</p><h4 id="四、锁升级过程"><a href="#四、锁升级过程" class="headerlink" title="四、锁升级过程"></a>四、锁升级过程</h4><p><strong>当没有线程竞争的时候加偏向锁</strong></p><p>在没有锁竞争的时候，也就是只有一个线程在获取锁，这时候加偏向锁，偏向锁使得线程在第一次CAS替换MarkWord中的是否标志锁、锁标志位和线程id后，它就获取了锁，之后再次获取不用再进行同步操作。</p><p><strong>当有线程与之竞争的时候，它就撤销偏向锁，转为轻量级锁</strong></p><p>锁撤销之后（偏向锁状态为0），现在无论是A线程还是B线程执行到同步代码块进行加锁，流程如下：</p><ol><li><p>线程在自己的栈桢中创建锁记录 LockRecord（锁记录）。</p></li><li><p>线程A 将 <code>Mark Word</code> 拷贝到线程栈的 Lock Record中，这个位置叫 displayced hdr，如下图所示：</p></li></ol><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521102815.png"  alt=""></p><ol start="3"><li><p>将锁记录中的<strong>Owner指针指向加锁的对象</strong>（存放对象地址）。</p></li><li><p>将<strong>锁对象的对象头的MarkWord替换为指向锁记录的指针</strong>。这二步如下图所示：</p></li></ol><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200521103005.png"  alt=""></p><ol start="5"><li>这时锁标志位变成 00 ，表示轻量级锁</li></ol><p><strong>轻量级锁什么时候会升级为重量级锁</strong></p><p>当锁升级为轻量级锁之后，如果依然有新线程过来竞争锁，首先新线程会自旋尝试获取锁，尝试到一定次数（默认10次）依然没有拿到，锁就会升级成重量级锁</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200524213425.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200524213504.png"  alt=""></p><h2 id="五、非公平"><a href="#五、非公平" class="headerlink" title="五、非公平"></a>五、非公平</h2><ul><li>Synchronized 在线程竞争锁时，首先做的不是直接进ContentionList 队列排队，而是尝试自旋获取锁（可能ContentionList 有别的线程在等锁），如果获取不到才进入 ContentionList，这明显对于已经进入队列的线程是不公平的；</li><li>另一个不公平的是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳台阶问题</title>
      <link href="/2020/05/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2020/05/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 跳台阶作为面试的热门题目，虽然不难，但还是有必要好好研究下；网上有很多的解题方案，迭代、递归、动态规划都可以</p></blockquote><h2 id="1-简单跳台阶"><a href="#1-简单跳台阶" class="headerlink" title="1.简单跳台阶"></a>1.<a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">简单跳台阶</a></h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><h3 id="1-1-最简单写法"><a href="#1-1-最简单写法" class="headerlink" title="1.1 最简单写法"></a>1.1 最简单写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个数组又好理解又简单是吧，我也这样想的。但在面试的时候被面试官提醒了，假设一种情况，如果不是跳一阶、两阶，而是允许跳1-n阶咋办？总不能<code>dp[i] = dp[i-1] + dp[i-2]+...dp[i-n]</code>这样吧。</p><h3 id="1-2-第二种写法"><a href="#1-2-第二种写法" class="headerlink" title="1.2 第二种写法"></a>1.2 第二种写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>||target==<span class="number">1</span>||target==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> f3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            f3 = f1+f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-递归方法"><a href="#1-3-递归方法" class="headerlink" title="1.3 递归方法"></a>1.3 递归方法</h3><p>应该很容易看出来了，有点斐波那契的味道了。那么用递归来解决趴</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>||target==<span class="number">1</span>||target==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JumpFloor(target - <span class="number">1</span>) + JumpFloor(target - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-变态跳台阶"><a href="#2-变态跳台阶" class="headerlink" title="2.变态跳台阶"></a>2.<a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">变态跳台阶</a></h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>f(1) = 1 </p><p>f(2) = f(2-1) + f(2-2)     //f(2-2) 表示2阶一次跳2阶的次数。 </p><p>f(3) = f(3-1) + f(3-2) + f(3-3) </p><p>有n阶台阶，就得有  f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n)  种</p><h3 id="2-1-递归写法"><a href="#2-1-递归写法" class="headerlink" title="2.1 递归写法"></a>2.1 递归写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>||target==<span class="number">1</span>||target==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            sum += JumpFloorII(target-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-归纳法"><a href="#2-2-归纳法" class="headerlink" title="2.2 归纳法"></a>2.2 归纳法</h3><p>f(n-1) = f(0) + f(1)+f(2)+f(3) + … + f((n-1)-1) =  f(0) + f(1) + f(2) + f(3) + … + f(n-2) </p><p>f(n) = f(0) + f(1) + f(2) + f(3) + … + f(n-2) +  f(n-1) = f(n-1) + f(n-1) </p><p>可以得出： </p><p>​    f(n) = 2*f(n-1)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387?f=discussion</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * JumpFloorII(target - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 迭代 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解快速排序</title>
      <link href="/2020/05/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/05/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面试的时候遇上了，但是很可惜忘记了。快排不难，但是如果没做个详细的记录的话，恐怕下次又要忘了，那真的就是让机会从手上溜走了。</p></blockquote><h2 id="一、快排"><a href="#一、快排" class="headerlink" title="一、快排"></a>一、快排</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>平均时间复杂度O(nlogn)，最好时间复杂度O(nlogn)，最差时间复杂度O(n^2)；空间复杂度O(nlogn)，不稳定。</p><p>给一串数组，第一遍选取一个参考点，可以随便选择，比如a[0]，接下来遍历数组，要做到左边的都比a[0]小，右边的都比a[0]大。</p><p>从a[0]开始向右遍历，a[length-1]开始向左遍历，遇到违反上述规则的就交换两个位置的数，以满足规则。直到两个指针相遇。还要记得将相遇的点与参考点a[0]交换数。</p><p>之后重复上述过程，相遇点-1作为左边部分的数组尾，相遇点+1作为右边部分的数组头，参考点就还是每部分数组的第一个元素。</p><h3 id="详细过程（参考）"><a href="#详细过程（参考）" class="headerlink" title="详细过程（参考）"></a>详细过程（<a href="https://www.jianshu.com/p/55ab254586bf" target="_blank" rel="noopener">参考</a>）</h3><p>下面通过一个例子介绍快速排序算法的思想，假设要对数组a[10]={6，1，2，7，9，3，4，5，10，8}进行排序，首先要在数组中选择一个数作为基准值，这个数可以随意选择，在这里，我们选择数组的第一个元素a[0]=6作为基准值，接下来，我们需要把数组中小于6的数放在左边，大于6的数放在右边，怎么实现呢？</p><p>我们设置两个“哨兵”，记为“哨兵i”和“哨兵j”，他们分别指向数组的第一个元素和最后一个元素，即i=0，j=8。首先哨兵j开始出动，哨兵j一步一步地向左挪动（即j–-），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。</p><p><img src="/" class="lazyload" data-src="https:////upload-images.jianshu.io/upload_images/9137038-970adbc928132b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/764/format/webp"  alt="img"></p><p>即将开始查询</p><p> 最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。此时就需要交换i和j指向的元素的值。</p><p><img src="/" class="lazyload" data-src="https:////upload-images.jianshu.io/upload_images/9137038-45f851f3ce4e1a61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/578/format/webp"  alt="img"></p><p>哨兵分别停在5和7上面，并且进行交换</p><p> 交换之后的数组变为a[10]={6，1，2，5，9，3，4，7，10，8}：</p><p><img src="/" class="lazyload" data-src="https:////upload-images.jianshu.io/upload_images/9137038-655ddca94bae92a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/546/format/webp"  alt="img"></p><p>交换完成</p><p> 第一次交换至此结束。接下来，由于哨兵i和哨兵j还没有相遇，于是哨兵j继续向前，发现比6小的4之后停下；哨兵i继续向前，发现比6大的9之后停下，两者再进行交换。交换之后的数组变为a[10]={6，1，2，5，4，3，9，7，10，8}。</p><p><img src="/" class="lazyload" data-src="https:////upload-images.jianshu.io/upload_images/9137038-e7b6f35cb82e7bbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/546/format/webp"  alt="img"></p><p>第二次的查询交换</p><p> 第二次交换至此结束。接下来，哨兵j继续向前，发小比6小的3停下来；哨兵i继续向前，发现i==j了！！！于是，这一轮的探测就要结束了，此时交换a[i]与基准的值，数组a就以6为分界线，分成了小于6和大于6的左右两部分：a[10]={3，1，2，5，4，6，9，7，10，8}。</p><p><img src="/" class="lazyload" data-src="https:////upload-images.jianshu.io/upload_images/9137038-9e4e52d1c781a312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/527/format/webp"  alt="img"></p><p>第一轮查询交换结束</p><p>此后分为{3,1,2,5,4} 6 {9,7,10,8}，递归的左边继续上述步骤、右边继续上述步骤</p><p>以上查询交换过程摘抄自<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fsinat_20177327%2Farticle%2Fdetails%2F76560079" target="_blank" rel="noopener">https://blog.csdn.net/sinat_20177327/article/details/76560079</a></p><h2 id="二、快排实现"><a href="#二、快排实现" class="headerlink" title="二、快排实现"></a>二、快排实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123; <span class="comment">// !!!不是while而是if</span></span><br><span class="line">        <span class="keyword">int</span> point = partition(list, left, right);</span><br><span class="line">        quickSort(list, left, point - <span class="number">1</span>);</span><br><span class="line">        quickSort(list, point + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用数组的第一个元素作为基准数</span></span><br><span class="line">    <span class="keyword">int</span> first = list[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; list[right] &gt;= first) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        list[left] = list[right]; <span class="comment">// swap(list, left, right);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; list[left] &lt;= first) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        list[right] = list[left];</span><br><span class="line">    &#125;</span><br><span class="line">    list[left] = first;<span class="comment">// 如果采用swap，则不需要这句</span></span><br><span class="line">    <span class="comment">// 返回分割点所在的位置</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组中两个位置的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        temp = list[left];</span><br><span class="line">        list[left] = list[right];</span><br><span class="line">        list[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解排序算法</title>
      <link href="/2020/05/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485814&amp;idx=2&amp;sn=704cee4eaaec8fc98765899bdeec988e&amp;chksm=cea246bdf9d5cfab168380240e9a20927930a905665b0d89e15207122f29ccc5afba0df37615&amp;token=292197051&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485814&amp;idx=2&amp;sn=704cee4eaaec8fc98765899bdeec988e&amp;chksm=cea246bdf9d5cfab168380240e9a20927930a905665b0d89e15207122f29ccc5afba0df37615&amp;token=292197051&amp;lang=zh_CN&amp;scene=21#wechat_redirect</a></p></blockquote><h3 id="一、动态规划的三大步骤"><a href="#一、动态规划的三大步骤" class="headerlink" title="一、动态规划的三大步骤"></a>一、动态规划的三大步骤</h3><p>动态规划，无非就是利用<strong>历史记录</strong>，来避免我们的重复计算。而这些<strong>历史记录</strong>，我们得需要一些<strong>变量</strong>来保存，一般是用<strong>一维数组</strong>或者<strong>二维数组</strong>来保存。下面我们先来讲下做动态规划题很重要的三个步骤，</p><p><strong>第一步骤</strong>：定义<strong>数组元素的含义</strong>，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？</p><p><strong>第二步骤</strong>：找出<strong>数组元素之间的关系式</strong>，我觉得动态规划，还是有一点类似于我们高中学习时的<strong>归纳法</strong>的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用<strong>历史数据</strong>来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说。</p><blockquote><p>学过动态规划的可能都经常听到<strong>最优子结构</strong>，把大的问题拆分成小的问题，说时候，最开始的时候，我是对<strong>最优子结构</strong>一梦懵逼的。估计你们也听多了，所以这一次，我将<strong>换一种形式来讲，不再是各种子问题，各种最优子结构</strong>。所以大佬可别喷我再乱讲，因为我说了，这是我自己平时做题的套路。</p></blockquote><p><strong>第三步骤</strong>：找出<strong>初始值</strong>。学过<strong>数学归纳法</strong>的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是<strong>所谓的初始值</strong>。</p><p>由了<strong>初始值</strong>，并且有了<strong>数组元素之间的关系式</strong>，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想<strong>求什么，就定义它是什么</strong>，这样，这道题也就解出来了。</p><h3 id="二、案例详解"><a href="#二、案例详解" class="headerlink" title="二、案例详解"></a>二、案例详解</h3><h4 id="案例一、简单的一维-DP"><a href="#案例一、简单的一维-DP" class="headerlink" title="案例一、简单的一维 DP"></a>案例一、简单的一维 DP</h4><blockquote><p>问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><h5 id="1-、定义数组元素的含义"><a href="#1-、定义数组元素的含义" class="headerlink" title="(1)、定义数组元素的含义"></a>(1)、定义数组元素的含义</h5><p>按我上面的步骤说的，首先我们来定义 dp[i] 的含义，我们的问题是要求青蛙跳上 n 级的台阶总共由多少种跳法，那我们就定义 dp[i] 的含义为：<strong>跳上一个 i 级的台阶总共有 dp[i] 种跳法</strong>。这样，如果我们能够算出 dp[n]，不就是我们要求的答案吗？所以第一步定义完成。</p><h5 id="（2）、找出数组元素间的关系式"><a href="#（2）、找出数组元素间的关系式" class="headerlink" title="（2）、找出数组元素间的关系式"></a>（2）、找出数组元素间的关系式</h5><p>我们的目的是要求 dp[n]，动态规划的题，如你们经常听说的那样，就是把一个<strong>规模</strong>比较大的问题分成几个<strong>规模</strong>比较小的问题，然后由小的问题推导出大的问题。也就是说，dp[n] 的规模为 n，比它规模小的是 n-1, n-2, n-3…. 也就是说，dp[n] 一定会和 dp[n-1], dp[n-2]….存在某种关系的。我们要找出他们的关系。</p><p><strong>那么问题来了，怎么找？</strong></p><p>这个怎么找，<strong>是最核心最难的一个</strong>，我们必须回到问题本身来了，来寻找他们的关系式，dp[n] 究竟会等于什么呢？</p><p>对于这道题，由于情况可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式</p><p>一种是从第 n-1 级跳上来</p><p>一种是从第 n-2 级跳上来</p><p>由于我们是要算<strong>所有可能的跳法的</strong>，所以有 dp[n] = dp[n-1] + dp[n-2]。</p><h5 id="（3）、找出初始条件"><a href="#（3）、找出初始条件" class="headerlink" title="（3）、找出初始条件"></a>（3）、找出初始条件</h5><p>当 n = 1 时，dp[1] = dp[0] + dp[-1]，而我们是数组是不允许下标为负数的，所以对于 dp[1]，我们必须要<strong>直接给出它的数值</strong>，相当于初始值，显然，dp[1] = 1。一样，dp[0] = 0.（因为 0 个台阶，那肯定是 0 种跳法了）。于是得出初始值：</p><p>dp[0] = 0.<br>dp[1] = 1.<br>即 n &lt;= 1 时，dp[n] = n.</p><p>三个步骤都做出来了，那么我们就来写代码吧，代码会详细注释滴。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 先创建一个数组来保存历史数据</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 给出初始值</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 通过关系式来计算出 dp[n]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把最终结果返回</span></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）、再说初始化"><a href="#（4）、再说初始化" class="headerlink" title="（4）、再说初始化"></a>（4）、再说初始化</h5><p>大家先想以下，你觉得，上面的代码有没有问题？</p><p>答是有问题的，还是错的，错在<strong>对初始值的寻找不够严谨</strong>，这也是我故意这样弄的，意在告诉你们，关于<strong>初始值的严谨性</strong>。例如对于上面的题，当 n = 2 时，dp[2] = dp[1] + dp[0] = 1。这显然是错误的，你可以模拟一下，应该是 dp[2] = 2。</p><p>也就是说，在寻找初始值的时候，一定要注意不要找漏了，dp[2] 也算是一个初始值，不能通过公式计算得出。有人可能会说，我想不到怎么办？这个很好办，多做几道题就可以了。</p><blockquote><p>下面我再列举三道不同的例题，并且，再在未来的文章中，我也会持续按照这个步骤，给大家找几道有难度且类型不同的题。下面这几道例题，不会讲的特性详细哈。实际上 ，上面的一维数组是可以把空间优化成更小的，不过我们现在先不讲优化的事，下面的题也是，不讲优化版本。</p></blockquote><h4 id="案例二：二维数组的-DP"><a href="#案例二：二维数组的-DP" class="headerlink" title="案例二：二维数组的 DP"></a>案例二：二维数组的 DP</h4><p>我做了几十道 DP 的算法题，可以说，80% 的题，都是要用二维数组的，所以下面的题主要以二维数组为主，当然有人可能会说，要用一维还是二维，我怎么知道？这个问题不大，接着往下看。</p><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200518115622.png"  alt=""></p><blockquote><p>这是 leetcode 的 62 号题：<a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths/</a></p></blockquote><p>还是老样子，三个步骤来解决。</p><h5 id="步骤一、定义数组元素的含义"><a href="#步骤一、定义数组元素的含义" class="headerlink" title="步骤一、定义数组元素的含义"></a>步骤一、定义数组元素的含义</h5><p>由于我们的目的是从左上角到右下角一共有多少种路径，那我们就定义 dp[i] [j]的含义为：<strong>当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i] [j] 种路径</strong>。那么，dp[m-1] [n-1] 就是我们要的答案了。</p><blockquote><p>注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 右下角的位置是 (m-1, n - 1)，所以 dp[m-1] [n-1] 就是我们要找的答案。</p></blockquote><h5 id="步骤二：找出关系数组元素间的关系式"><a href="#步骤二：找出关系数组元素间的关系式" class="headerlink" title="步骤二：找出关系数组元素间的关系式"></a>步骤二：找出关系数组元素间的关系式</h5><p>想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达</p><p>一种是从 (i-1, j) 这个位置走一步到达</p><p>一种是从(i, j - 1) 这个位置走一步到达</p><p>因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]。</p><h5 id="步骤三、找出初始值"><a href="#步骤三、找出初始值" class="headerlink" title="步骤三、找出初始值"></a>步骤三、找出初始值</h5><p>显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：</p><p>dp[0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往左走</p><p>dp[0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往下走</p><h5 id="撸代码"><a href="#撸代码" class="headerlink" title="撸代码"></a>撸代码</h5><p>三个步骤都写出来了，直接看代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n]; <span class="comment">// </span></span><br><span class="line">      <span class="comment">// 初始化</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 推导出 dp[m-1][n-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>O(n*m) 的空间复杂度可以优化成 O(min(n, m)) 的空间复杂度的，不过这里先不讲。</p></blockquote><h4 id="案例三、二维数组-DP"><a href="#案例三、二维数组-DP" class="headerlink" title="案例三、二维数组 DP"></a>案例三、二维数组 DP</h4><p>写到这里，有点累了，，但还是得写下去，所以看的小伙伴，你们可得继续看呀。下面这道题也不难，比上面的难一丢丢，不过也是非常类似</p><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line">输入:</span><br><span class="line">arr = [</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure><p>和上面的差不多，不过是算最优路径和，这是 leetcode 的第64题：<a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum/</a></p><blockquote><p>还是老样子，可能有些人都看烦了，哈哈，但我还是要按照步骤来写，让那些不大懂的加深理解。有人可能觉得，这些题太简单了吧，别慌，小白先入门，这些属于 medium 级别的，后面在给几道 hard 级别的。</p></blockquote><h5 id="步骤一、定义数组元素的含义-1"><a href="#步骤一、定义数组元素的含义-1" class="headerlink" title="步骤一、定义数组元素的含义"></a>步骤一、定义数组元素的含义</h5><p>由于我们的目的是从左上角到右下角，最小路径和是多少，那我们就定义 dp[i] [j]的含义为：<strong>当机器人从左上角走到(i, j) 这个位置时，最下的路径和是 dp[i] [j]</strong>。那么，dp[m-1] [n-1] 就是我们要的答案了。</p><blockquote><p>注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 由下角的位置是 (m-1, n - 1)，所以 dp[m-1] [n-1] 就是我们要走的答案。</p></blockquote><h5 id="步骤二：找出关系数组元素间的关系式-1"><a href="#步骤二：找出关系数组元素间的关系式-1" class="headerlink" title="步骤二：找出关系数组元素间的关系式"></a>步骤二：找出关系数组元素间的关系式</h5><p>想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达</p><p>一种是从 (i-1, j) 这个位置走一步到达</p><p>一种是从(i, j - 1) 这个位置走一步到达</p><p>不过这次不是计算所有可能路径，而是<strong>计算哪一个路径和是最小的</strong>，那么我们要从这两种方式中，选择一种，使得dp[i] [j] 的值是最小的，显然有</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i] [j] = min(dp[i-<span class="number">1</span>][j]，dp[i][j-<span class="number">1</span>]) + arr[i][j];<span class="comment">// arr[i][j] 表示网格种的值</span></span><br></pre></td></tr></table></figure><h5 id="步骤三、找出初始值-1"><a href="#步骤三、找出初始值-1" class="headerlink" title="步骤三、找出初始值"></a>步骤三、找出初始值</h5><p>显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：</p><p>dp[0] [j] = arr[0] [j] + dp[0] [j-1]; // 相当于最上面一行，机器人只能一直往左走</p><p>dp[i] [0] = arr[i] [0] + dp[i] [0];  // 相当于最左面一列，机器人只能一直往下走</p><h5 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> m = arr.length;</span><br><span class="line">      <span class="keyword">int</span> n = arr[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n]; <span class="comment">// </span></span><br><span class="line">      <span class="comment">// 初始化</span></span><br><span class="line">      dp[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 初始化最左边的列</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + arr[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 初始化最上边的行</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] + arr[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 推导出 dp[m-1][n-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>O(n*m) 的空间复杂度可以优化成 O(min(n, m)) 的空间复杂度的</p></blockquote><h4 id="案例-4：编辑距离"><a href="#案例-4：编辑距离" class="headerlink" title="案例 4：编辑距离"></a>案例 4：编辑距离</h4><p>这次给的这道题比上面的难一些，在 leetcdoe 的定位是 hard 级别。好像是 leetcode 的第 72 号题。</p><p><strong>问题描述</strong></p><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: word1 = <span class="string">"horse"</span>, word2 = <span class="string">"ros"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 <span class="string">'h'</span> 替换为 <span class="string">'r'</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">'r'</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">'e'</span>)</span><br></pre></td></tr></table></figure><p><strong>解答</strong></p><p>还是老样子，按照上面三个步骤来，并且我这里可以告诉你，90% 的字符串问题都可以用动态规划解决，并且90%是采用二维数组。</p><h5 id="步骤一、定义数组元素的含义-2"><a href="#步骤一、定义数组元素的含义-2" class="headerlink" title="步骤一、定义数组元素的含义"></a>步骤一、定义数组元素的含义</h5><p>由于我们的目的求将 word1 转换成 word2 所使用的最少操作数 。那我们就定义 dp[i] [j]的含义为：<strong>当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i] [j]</strong>。</p><blockquote><p>有时候，数组的含义并不容易找，所以还是那句话，我给你们一个套路，剩下的还得看你们去领悟。</p></blockquote><h5 id="步骤二：找出关系数组元素间的关系式-2"><a href="#步骤二：找出关系数组元素间的关系式-2" class="headerlink" title="步骤二：找出关系数组元素间的关系式"></a>步骤二：找出关系数组元素间的关系式</h5><p>接下来我们就要找 dp[i] [j] 元素之间的关系了，比起其他题，这道题相对比较难找一点，但是，不管多难找，大部分情况下，dp[i] [j] 和 dp[i-1] [j]、dp[i] [j-1]、dp[i-1] [j-1] 肯定存在某种关系。因为我们的目标就是，<strong>从规模小的，通过一些操作，推导出规模大的</strong>。对于这道题，我们可以对 word1 进行三种操作</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><p>由于我们是要让操作的次数最小，所以我们要寻找最佳操作。那么有如下关系式：</p><p>一、如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作，显然有 dp[i] [j] = dp[i-1] [j-1]。（别忘了 dp[i] [j] 的含义哈）。</p><p>二、如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下（注意字符串与字符的区别）：</p><p>（1）、如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i] [j] = dp[i-1] [j-1] + 1;</p><p>（2）、如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i] [j] = dp[i] [j-1] + 1;</p><p>（3）、如果把字符 word1[i] 删除，则有 dp[i] [j] = dp[i-1] [j] + 1;</p><p>那么我们应该选择一种操作，使得 dp[i] [j] 的值最小，显然有</p><p><strong>dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;</strong></p><p>于是，我们的关系式就推出来了，</p><h5 id="步骤三、找出初始值-2"><a href="#步骤三、找出初始值-2" class="headerlink" title="步骤三、找出初始值"></a>步骤三、找出初始值</h5><p>显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n] 和所有的 dp[0….m] [0]。这个还是非常容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。</p><h5 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> n2 = word2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[0][0...n2]的初始值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) </span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// dp[0...n1][0] 的初始值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 通过公式推出 dp[n1][n2]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">              <span class="comment">// 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1</span></span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后说下，如果你要练习，可以去 leetcode，选择动态规划专题，然后连续刷几十道，保证你以后再也不怕动态规划了。当然，遇到很难的，咱还是得挂。</p><p>Leetcode 动态规划直达：<a href="https://leetcode-cn.com/tag/dynamic-programming/" target="_blank" rel="noopener">https://leetcode-cn.com/tag/dynamic-programming/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署多个git账户且实现ssh代理</title>
      <link href="/2020/05/17/%E5%B7%A5%E5%85%B7/%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AAgit%E8%B4%A6%E6%88%B7%E4%B8%94%E5%AE%9E%E7%8E%B0ssh%E4%BB%A3%E7%90%86/"/>
      <url>/2020/05/17/%E5%B7%A5%E5%85%B7/%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AAgit%E8%B4%A6%E6%88%B7%E4%B8%94%E5%AE%9E%E7%8E%B0ssh%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前注册了github没弄ssh，每次需要push代码或者部署hexo博客都需要输入用户名密码，很麻烦。在体会一次ssh之后，简直太香了。最近又注册了个github账号，发现ssh key会相互覆盖，在网上找了一些资料后在这里做个总结，防止下次有相同需求又得百度了。</p></blockquote><h2 id="一、生成sshKey"><a href="#一、生成sshKey" class="headerlink" title="一、生成sshKey"></a>一、生成sshKey</h2><p>如果有多个账户的，建议就别设置全局的用户名和邮箱了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name <span class="string">"yourgithubname"</span></span><br><span class="line">git config user.email <span class="string">"yourgithubemail"</span></span><br><span class="line"></span><br><span class="line">git config --global user.name <span class="string">"yourgithubname"</span><span class="comment"># 不要全局</span></span><br><span class="line">git config --global user.email <span class="string">"yourgithubemail"</span><span class="comment"># 不要全局</span></span><br></pre></td></tr></table></figure><p>如果设置了全局的话，可以删除<code>~/.gitconfig</code>文件；局部的不设置好像也行。</p><p><strong>生成公钥和私钥</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>注意这里需要重写默认生成的sshKey名称</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200517190834.png"  alt=""></p><p>同理你可以按照命令生成其它sshKey</p><h2 id="二、配置ssh代理"><a href="#二、配置ssh代理" class="headerlink" title="二、配置ssh代理"></a>二、配置ssh代理</h2><p>在生成ssh的同目录下也存在一个config文件，如果没有就新建。</p><p><strong>配置config文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里用的user1、user2都是举例，可以自定义，和上面图片我命令的没啥关系</span></span><br><span class="line">Host github_user1<span class="comment"># ssh -T git@github_user1  !!待会测试的时候记住是这个</span></span><br><span class="line">HostName github.com<span class="comment"># 就是github.com或者你使用的其他git工具的网站</span></span><br><span class="line">User git<span class="comment"># 这个同一git就行</span></span><br><span class="line">IdentityFile C:\Users\h\.ssh\id_rsa_1<span class="comment"># 你刚重命名的sshKey的私钥！(不是以.pub结尾的那个)</span></span><br><span class="line"></span><br><span class="line">Host github_user2<span class="comment"># 反正主机名不重复就行</span></span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">IdentityFile C:\Users\h\.ssh\id_rsa_2</span><br></pre></td></tr></table></figure><p>代理配置完成之后，就可以进行测试了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成后填到github或其他git上</span></span><br><span class="line"><span class="comment">#验证是否成功</span></span><br><span class="line">ssh -T git@github_user1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果是下面这样就行了</span></span><br><span class="line">Hi user1! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>所以<code>ssh -T git</code>就是会从代理文件中通过你给的主机名找到私钥，通过这个私钥再和你给的ssh地址通信验证。</p><h2 id="三、ssh地址"><a href="#三、ssh地址" class="headerlink" title="三、ssh地址"></a>三、ssh地址</h2><p><strong>这里就是主要注意的一点了</strong></p><p>我们通常在git上获取的地址都是这样的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@github.com:用户名/仓库名.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错</span></span><br><span class="line">git@github.com: Permission denied (publickey).</span><br></pre></td></tr></table></figure><p>所以你可能一没注意就把ssh地址填这个了，这在默认情况下是可以的，但现在执行<code>ssh git@github.com</code>就会出错了。换言之，仓库给的默认地址不能用的。所以需要进行更改。</p><p>比如，现在要往用户为user1的仓库中push了，仓库给的地址还是<code>git@github.com:user1/demo1.git</code>，你需要将域名也就是<code>github.com</code>修改成<code>github_user1</code>，也就是地址为<code>git@github_user1:user1/demo1.git</code>。这样就行啦。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle数据库项目实战</title>
      <link href="/2020/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
      <url>/2020/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>个人网站：点击<a href="https://hhofe.github.io" target="_blank" rel="noopener">Hofe’s blog</a>可查看更多内容</p></blockquote><h2 id="Oracle数据库项目实战"><a href="#Oracle数据库项目实战" class="headerlink" title="Oracle数据库项目实战"></a>Oracle数据库项目实战</h2><h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><p>系统总共分为3个模块，分别是用户模块、商品模块、订单模块。</p><p>由于每次秒杀活动都会操作数据库，修改秒杀商品的字段，因为每次秒杀时候。对应的秒杀时间段，秒杀实现，秒杀功能，价格等都不同，商品表不易于维护。而且，秒杀商品的个数和普通商品的个数是独立计算的，不同于普通商品的库存字段。因此秒杀系统需要有商品表，秒杀商品表，订单表，秒杀订单，秒杀用户表。 </p><p><strong>用户模块</strong>：需要用到用户表。前端获取用户的id以及登录密码传递给后端进行验证，后端从秒杀用户表中查找是否存在该用户，以及验证账号密码是否正确。验证通过则登录系统。</p><p><strong>商品模块</strong>：需要用到秒杀商品表、商品表。后端从秒杀商品表中查找参与秒杀活动的商品，并将其返回给前端显示在页面上；用户在点击秒杀商品后，前端会发起请求携带商品id给后端，后端从商品表中检索该条数据，若存在数据则会跳转至商品详情页面。</p><p><strong>订单模块</strong>：需要用到秒杀订单表、订单表。用户在抢到秒杀商品后，首先会在订单表中生成一条只含有订单id号的记录，该订单id会与商品id、用户id一起存入秒杀订单表，成功存入后，再将详细记录存入订单表，该过程需要开启事务，如中间有步骤失败将回退。</p><h3 id="二、系统E-R图"><a href="#二、系统E-R图" class="headerlink" title="二、系统E-R图"></a>二、系统E-R图</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516222659.jpg"  alt="img"></p><h3 id="三、关系模型"><a href="#三、关系模型" class="headerlink" title="三、关系模型"></a>三、关系模型</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516222859.jpg"  alt="img"></p><h4 id="3-1-goods表"><a href="#3-1-goods表" class="headerlink" title="3.1 goods表"></a>3.1 goods表</h4><p>该表存放商品数据，含商品名、价格等，用于页面显示商品详情</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223634.jpg"  alt="img"></p><h4 id="3-2-miaosha-users表"><a href="#3-2-miaosha-users表" class="headerlink" title="3.2 miaosha_users表"></a>3.2 miaosha_users表</h4><p>该表存放用户信息，含用户名、密码等，用于登陆</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223631.jpg"  alt="img"></p><h4 id="3-3-miaosha-goods表"><a href="#3-3-miaosha-goods表" class="headerlink" title="3.3 miaosha_goods表"></a>3.3 miaosha_goods表</h4><p>该表存放参与秒杀的商品信息，含秒杀价格、库存等信息</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223629.jpg"  alt="img"></p><h4 id="3-4-miaosha-order表"><a href="#3-4-miaosha-order表" class="headerlink" title="3.4 miaosha_order表"></a>3.4 miaosha_order表</h4><p>该表存放秒杀订单的信息，含下单用户ID、商品ID等信息</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223626.jpg"  alt="img"></p><h4 id="3-5-order-info表"><a href="#3-5-order-info表" class="headerlink" title="3.5 order_info表"></a>3.5 order_info表</h4><p>该表存放订单的详细信息。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223622.jpg"  alt="img"></p><h3 id="四、创建表并添加数据"><a href="#四、创建表并添加数据" class="headerlink" title="四、创建表并添加数据"></a>四、创建表并添加数据</h3><p>先使用命令行创建一个用户并授权</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223619.jpg"  alt="img"></p><p>在Navicat工具中创建表并填入数据</p><p>插入的数据为了方便理解，统一规定为userId从15960000001开始递增，goodId从11开始递增，orderId从101开始递增。</p><h4 id="4-1-goods表"><a href="#4-1-goods表" class="headerlink" title="4.1 goods表"></a>4.1 goods表</h4><p><strong>执行创建表语句，并添加注释</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223615.jpg"  alt="img"></p><p><strong>插入数据</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223612.jpg"  alt="img"></p><p><strong>查看插入结果</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223607.jpg"  alt="img"></p><p><strong>添加主键约束和check约束</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223604.jpg"  alt="img"></p><h4 id="4-2-miaosha-users表"><a href="#4-2-miaosha-users表" class="headerlink" title="4.2 miaosha_users表"></a>4.2 miaosha_users表</h4><p><strong>创建表</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223601.jpg"  alt="img"></p><p><strong>添加数据</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223558.jpg"  alt="img"></p><p><strong>查看数据</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223556.jpg"  alt="img"></p><p><strong>添加主键约束和check约束</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223552.jpg"  alt="img"></p><h4 id="4-3-miaosha-goods表"><a href="#4-3-miaosha-goods表" class="headerlink" title="4.3 miaosha_goods表"></a>4.3 miaosha_goods表</h4><p><strong>创建表</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223549.jpg"  alt="img"></p><p><strong>添加数据</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223545.jpg"  alt="img"></p><p><strong>查看数据</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223541.jpg"  alt="img"></p><p><strong>添加主键约束、唯一约束、check约束、外键约束</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223539.jpg"  alt="img"></p><p><strong>注：添加外键约束时，外键只能参考主键或者唯一键，故如果参考的不是主键，需要先在参考列上加上唯一约束。由于goods_id不是该表主键，但是它需要作为order_info表的外键参考，故需要加上唯一约束。</strong></p><h4 id="4-4-order-info表"><a href="#4-4-order-info表" class="headerlink" title="4.4 order_info表"></a>4.4 order_info表</h4><p><strong>创建表</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223534.jpg"  alt="img"></p><p><strong>添加数据</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223530.jpg"  alt="img"></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223527.jpg"  alt="img"></p><p><strong>添加主键和check约束</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223525.jpg"  alt="img"></p><p><strong>注：这里的user_id和goods_id并没有依赖外键，但是当用户下单时会先在该表生成只含id的记录，id将作为miaosha_order的order_id的参考外键。</strong></p><h4 id="4-5-miaosha-order表"><a href="#4-5-miaosha-order表" class="headerlink" title="4.5 miaosha_order表"></a>4.5 miaosha_order表</h4><p><strong>创建表</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223521.jpg"  alt="img"></p><p><strong>添加数据</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223516.jpg"  alt="img"></p><p><strong>查看数据</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223513.jpg"  alt="img"></p><p><strong>添加主键、check和外键约束</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223510.jpg"  alt="img"></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223507.jpg"  alt="img"></p><h3 id="五、索引-视图的创建与应用"><a href="#五、索引-视图的创建与应用" class="headerlink" title="五、索引/视图的创建与应用"></a>五、索引/视图的创建与应用</h3><h4 id="5-1-添加索引"><a href="#5-1-添加索引" class="headerlink" title="5.1 添加索引"></a>5.1 添加索引</h4><p>在order_info.goods_id添加索引，可以在数据量大的情况下加快连接查询的速度</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223505.jpg"  alt="img"></p><h4 id="5-2-添加视图"><a href="#5-2-添加视图" class="headerlink" title="5.2 添加视图"></a>5.2 添加视图</h4><p>考虑到当查看秒杀商品的时候，会点击进去查看商品的详情，故添加goods和miaosha_goods的查询视图。</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223502.jpg"  alt="img"></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223459.jpg"  alt="img"></p><h3 id="六、游标的创建与应用"><a href="#六、游标的创建与应用" class="headerlink" title="六、游标的创建与应用"></a>六、游标的创建与应用</h3><h4 id="6-1-使用游标检索miaosha-user表中所有数据"><a href="#6-1-使用游标检索miaosha-user表中所有数据" class="headerlink" title="6.1 使用游标检索miaosha_user表中所有数据"></a>6.1 使用游标检索miaosha_user表中所有数据</h4><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223457.jpg"  alt="img"></p><h3 id="七、存储过程的创建与应用"><a href="#七、存储过程的创建与应用" class="headerlink" title="七、存储过程的创建与应用"></a>七、存储过程的创建与应用</h3><h4 id="7-1-使用存储过程将指定用户登录次数-1"><a href="#7-1-使用存储过程将指定用户登录次数-1" class="headerlink" title="7.1 使用存储过程将指定用户登录次数+1"></a>7.1 使用存储过程将指定用户登录次数+1</h4><p>这里执行完存储过程后，生成函数P1</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223453.jpg"  alt="img"></p><p>测试：原login_count=2</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223451.jpg"  alt="img"></p><p>执行完存储过程p1后，login_count=3</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223448.jpg"  alt="img"></p><h3 id="八、触发器的创建与应用"><a href="#八、触发器的创建与应用" class="headerlink" title="八、触发器的创建与应用"></a>八、触发器的创建与应用</h3><h4 id="8-1-使用触发器实现下订单后库存减1"><a href="#8-1-使用触发器实现下订单后库存减1" class="headerlink" title="8.1 使用触发器实现下订单后库存减1"></a>8.1 使用触发器实现下订单后库存减1</h4><p>执行触发器之前，gooid_id为16的stock_count为5</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223445.jpg"  alt="img"></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223441.jpg"  alt="img"></p><p>触发器成功执行</p><p><img src="/" class="lazyload" data-src="/C:/Users/h/AppData/Local/Temp/msohtmlclip1/01/clip_image078.jpg"  alt="img"></p><p>再次查询，gooid_id为16的stock_count为4</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223435.jpg"  alt="img"></p><h3 id="九、函数的创建与应用"><a href="#九、函数的创建与应用" class="headerlink" title="九、函数的创建与应用"></a>九、函数的创建与应用</h3><h4 id="9-1-计算iPhoneX全部销售完的总金额"><a href="#9-1-计算iPhoneX全部销售完的总金额" class="headerlink" title="9.1 计算iPhoneX全部销售完的总金额"></a>9.1 计算iPhoneX全部销售完的总金额</h4><p>iPhoneX总库存100台，每台售价5000</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223430.jpg"  alt="img"></p><p>函数执行完后会将值返回给s，最后输出s</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223426.jpg"  alt="img"></p><h3 id="十、软件各模块功能实现"><a href="#十、软件各模块功能实现" class="headerlink" title="十、软件各模块功能实现"></a>十、软件各模块功能实现</h3><h4 id="10-1-用户模块"><a href="#10-1-用户模块" class="headerlink" title="10.1 用户模块"></a>10.1 用户模块</h4><p><strong>用户登录功能</strong></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223422.jpg"  alt="img"></p><p>输错密码或者数据库中不存在该用户，都会提示</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223419.jpg"  alt="img"></p><p>数据库中存在该数据则跳转至商品列表页</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223416.jpg"  alt="img"></p><h4 id="10-2-商品模块"><a href="#10-2-商品模块" class="headerlink" title="10.2 商品模块"></a>10.2 商品模块</h4><p><strong>秒杀商品展示功能</strong></p><p>用户成功登录后即跳转至该页面</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223413.jpg"  alt="img"></p><p><strong>商品详情页</strong></p><p>为了方便计算秒杀倒计时，这里直接换算了时间单位，所以开始时间显示数字，表示1970 年 1 月 1 日开始计算到 Date 对象中的时间之间的毫秒数</p><p>未到达秒杀时间不可抢购</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223327.jpg"  alt="img"></p><p>达到秒杀时间，秒杀后加入秒杀订单</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223324.jpg"  alt="img"></p><h4 id="10-3-订单模块"><a href="#10-3-订单模块" class="headerlink" title="10.3 订单模块"></a>10.3 订单模块</h4><p>在秒杀进行的时候对商品进行下单</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223321.jpg"  alt="img"></p><p>确定秒杀成功后，将记录加入订单详情表</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223319.jpg"  alt="img"></p><p>同时列表页显示库存减1</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200516223312.jpg"  alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python分类预测泰坦尼克号生存率</title>
      <link href="/2020/05/15/Python/Python%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E7%94%9F%E5%AD%98%E7%8E%87/"/>
      <url>/2020/05/15/Python/Python%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E7%94%9F%E5%AD%98%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>可访问<a href="https://hhf443.github.io/" target="_blank" rel="noopener">个人网站</a>进行阅读最新版本</p></blockquote><h3 id="二、泰坦尼克号乘客生存预测（分类分析）"><a href="#二、泰坦尼克号乘客生存预测（分类分析）" class="headerlink" title="二、泰坦尼克号乘客生存预测（分类分析）"></a>二、泰坦尼克号乘客生存预测（分类分析）</h3><h4 id="1-1-环境"><a href="#1-1-环境" class="headerlink" title="1.1 环境"></a>1.1 环境</h4><ol><li><p>python(3.6)</p></li><li><p>matplotlib (3.1.3)</p></li><li><p>numpy (1.18.1)</p></li><li><p>pandas (1.0.0)</p></li><li><p>scikit-learn (0.22.2.post1)</p></li></ol><p><strong>数据集</strong><a href="https://github.com/hhf443/data-analysis.git" target="_blank" rel="noopener">点击下载</a></p><h4 id="1-2-功能"><a href="#1-2-功能" class="headerlink" title="1.2 功能"></a>1.2 功能</h4><ol><li>进行必要数据预处理和特征工程</li><li>使用两种以上分类算法建立分类模型（不限编程语言）</li><li>随机将数据划分为训练集和测试集，进行模型训练和测试</li><li>应用交叉验证法训练和测试分类模型</li><li>分别对第(3)和(4)小题，用F1-Measure评价分类模型的性能</li></ol><h3 id="二、结果"><a href="#二、结果" class="headerlink" title="二、结果"></a>二、结果</h3><p>（1）使用ID3决策树进行分类</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200515235008.png"  alt=""></p><p>（2）使用K近邻进行分类</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200515235049.jpg"  alt="img"></p><h3 id="三、源码"><a href="#三、源码" class="headerlink" title="三、源码"></a>三、源码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split, cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KNebClf</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="comment"># 使用ID3决策树进行分类</span></span><br><span class="line">    clf = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">    clf.fit(x, y)</span><br><span class="line">    pred = clf.predict(x)</span><br><span class="line">    <span class="keyword">return</span> clf, pred</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DTreeClf</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="comment"># 使用K近邻进行分类</span></span><br><span class="line">    clf = DecisionTreeClassifier(criterion=<span class="string">"entropy"</span>)</span><br><span class="line">    clf.fit(x, y)</span><br><span class="line">    pred = clf.predict(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clf, pred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = pd.read_csv(<span class="string">"C:\\Users\\h\\Grade3\\Grade3-2\\dataset\\Titanic_train.csv"</span>)</span><br><span class="line">    size = data.shape</span><br><span class="line"></span><br><span class="line">    index = data[<span class="string">"PassengerId"</span>]</span><br><span class="line">    <span class="comment"># PassengerID、Name、Ticket、Cabin 对预测结果影响不大，可以删除</span></span><br><span class="line">    data.drop([<span class="string">"PassengerId"</span>, <span class="string">"Cabin"</span>,<span class="string">"Name"</span>,<span class="string">"Ticket"</span>],inplace=<span class="literal">True</span>,axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(data.isnull().sum())</span></span><br><span class="line">    <span class="comment"># 处理空值</span></span><br><span class="line">    data[<span class="string">'Age'</span>].fillna(data[<span class="string">'Age'</span>].mean(), inplace=<span class="literal">True</span>)    <span class="comment"># 年龄 均值填充</span></span><br><span class="line">    data[<span class="string">'Embarked'</span>].fillna(data[<span class="string">'Embarked'</span>].mode()[<span class="number">0</span>], inplace=<span class="literal">True</span>)    <span class="comment"># 登船港口 众数填充</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理非数值型数据，可以采用onehot也可以替换，这里采用替换的方式</span></span><br><span class="line">    data[<span class="string">'Sex'</span>] = data[<span class="string">'Sex'</span>].map(&#123;<span class="string">'male'</span>: <span class="number">0</span>, <span class="string">'female'</span>: <span class="number">1</span>&#125;).astype(int)</span><br><span class="line">    data[<span class="string">'Embarked'</span>] = data[<span class="string">'Embarked'</span>].map(&#123;<span class="string">'S'</span>: <span class="number">0</span>, <span class="string">'C'</span>: <span class="number">1</span>, <span class="string">'Q'</span>: <span class="number">2</span>&#125;).astype(int)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># index = data[:, 0]  # 第一列是PassengerId，不应加入预测</span></span><br><span class="line">    y = data[<span class="string">"Survived"</span>]      <span class="comment"># Survived待预测</span></span><br><span class="line">    x = data.drop([<span class="string">'Survived'</span>], axis=<span class="number">1</span>)    <span class="comment"># 第8列为Survived， 即需要预测的列，故不加入到模型中</span></span><br><span class="line"></span><br><span class="line">    X_train, X_test, Y_train, Y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    clf, y_pred = DTreeClf(x, y)  <span class="comment">#使用ID3决策树进行分类</span></span><br><span class="line">    <span class="comment"># clf, y_pred = KNebClf(x, y)     # 使用K近邻进行分类</span></span><br><span class="line">    scores = cross_val_score(clf, x, y, cv=<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"交叉验证准确率： "</span>, np.mean(scores), scores)</span><br><span class="line"></span><br><span class="line">    clf, y_pred_train = DTreeClf(X_train, Y_train)</span><br><span class="line">    <span class="comment"># clf, y_pred_train = KNebClf(X_train, Y_train)</span></span><br><span class="line">    print(<span class="string">"训练集的F1-Measure： "</span>, f1_score(Y_train, y_pred_train, average=<span class="string">'weighted'</span>))</span><br><span class="line">    <span class="comment"># print("训练集上的准确率： ", np.mean(Y_train == y_pred_train))</span></span><br><span class="line"></span><br><span class="line">    clf, y_pred_test = DTreeClf(X_test, Y_test)</span><br><span class="line">    <span class="comment"># clf, y_pred_test = KNebClf(X_test, Y_test)</span></span><br><span class="line">    print(<span class="string">"测试集的F1-Measure： "</span>, f1_score(Y_test, y_pred_test, average=<span class="string">'weighted'</span>))</span><br><span class="line">    <span class="comment"># print("测试集上的准确率： ", np.mean(Y_test == y_pred_test))</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DTree </tag>
            
            <tag> KNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python回归分析预测房屋价格</title>
      <link href="/2020/05/14/Python/Python%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E9%A2%84%E6%B5%8B%E6%88%BF%E5%B1%8B%E4%BB%B7%E6%A0%BC/"/>
      <url>/2020/05/14/Python/Python%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E9%A2%84%E6%B5%8B%E6%88%BF%E5%B1%8B%E4%BB%B7%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>可访问<a href="http://hhf443.github.io/" target="_blank" rel="noopener">个人网站</a>进行阅读最新版本</p></blockquote><h3 id="一、房价预测（回归分析）"><a href="#一、房价预测（回归分析）" class="headerlink" title="一、房价预测（回归分析）"></a>一、房价预测（回归分析）</h3><h4 id="1-1-环境"><a href="#1-1-环境" class="headerlink" title="1.1 环境"></a>1.1 环境</h4><ol><li><p>python(3.6)</p></li><li><p>matplotlib (3.1.3)</p></li><li><p>numpy (1.18.1)</p></li><li><p>pandas (1.0.0)</p></li><li><p>scikit-learn (0.22.2.post1)</p></li></ol><p><strong>数据集</strong><a href="https://github.com/hhf443/data-analysis.git" target="_blank" rel="noopener">点击下载</a></p><h4 id="1-2-功能"><a href="#1-2-功能" class="headerlink" title="1.2 功能"></a>1.2 功能</h4><ol><li><p>进行必要的数据预处理和特征工程</p></li><li><p>应用两种以上回归分析算法建立预测模型（不限编程语言）</p></li><li><p>随机将数据划分为训练集和测试集，进行模型训练和测试</p></li><li><p>应用交叉验证法训练和测试预测模型</p></li><li><p>评价第(3)和(4)所建立预测模型的性能（用MSE（均方误差）和R2 Score（R2决定系数）等指标评价）</p></li></ol><h3 id="二、结果"><a href="#二、结果" class="headerlink" title="二、结果"></a>二、结果</h3><p>逻辑回归的准确率一直不高；多项式回归准确率还可以，这里用的只是1阶，2阶就开始过拟合了，可以用交叉验证看误差在多少。数据集共有2000条，图片只显示前100条。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200514191016.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200514191047.png"  alt=""></p><h3 id="三、源码"><a href="#三、源码" class="headerlink" title="三、源码"></a>三、源码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression, LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split, cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder, PolynomialFeatures</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">days</span><span class="params">(str2)</span>:</span></span><br><span class="line">    <span class="comment"># 考虑到时间列变成onehot编码不太合理，故将其转为房屋建造时间距离现在的时间，即房屋建了多少天</span></span><br><span class="line">    date1 = datetime.datetime.strptime(<span class="string">"2020/5/15"</span>, <span class="string">"%Y/%m/%d"</span>)</span><br><span class="line">    date2 = datetime.datetime.strptime(str2[<span class="number">0</span>:<span class="number">10</span>], <span class="string">"%Y/%m/%d"</span>)</span><br><span class="line">    num = (date1 - date2).days</span><br><span class="line">    <span class="keyword">return</span> int(num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crossValid</span><span class="params">(lr, x, y)</span>:</span></span><br><span class="line">    X_train, X_test, Y_train, Y_test = train_test_split(x, y)</span><br><span class="line">    scores = cross_val_score(lr, X_train, Y_train, cv=<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"交叉验证准确率： "</span>, np.mean(scores), scores)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PredByLogisticRegression</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="comment"># 逻辑回归预测</span></span><br><span class="line">    lr = LogisticRegression(solver=<span class="string">'liblinear'</span>)</span><br><span class="line">    lr.fit(x,y)</span><br><span class="line">    print(<span class="string">"模型的平均准确度为： %s "</span> % lr.score(x,y))</span><br><span class="line">    y_pred = lr.predict(x)</span><br><span class="line">    crossValid(lr, x, y)</span><br><span class="line">    <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PredByPolynomialRegression</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="comment"># 多项式回归预测</span></span><br><span class="line">    poly = PolynomialFeatures(degree=<span class="number">1</span>)</span><br><span class="line">    X_poly = poly.fit_transform(x)</span><br><span class="line">    poly.fit(X_poly, y)</span><br><span class="line"></span><br><span class="line">    lin = LinearRegression()</span><br><span class="line">    lin.fit(X_poly, y)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"R2 Score： %s "</span> % lin.score(X_poly, y))</span><br><span class="line">    y_pred = lin.predict(poly.fit_transform(x))</span><br><span class="line"></span><br><span class="line">    crossValid(lin, X_poly, y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = pd.read_csv(<span class="string">"C:\\Users\\h\\Grade3\\Grade3-2\\dataset\\house_train.csv"</span>)</span><br><span class="line">    size = data.shape</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 时间列无法做onehot编码，会有很多个值，故转换成与某个时间之间的差值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size[<span class="number">0</span>]):</span><br><span class="line">        data[<span class="string">"built_date"</span>][i] = days(data[<span class="string">"built_date"</span>][i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将id列抽取出来，价格与id没关系</span></span><br><span class="line">    X_id = pd.DataFrame(data[<span class="string">'id'</span>])</span><br><span class="line">    data = data.drop([<span class="string">'id'</span>], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取非数值型数据</span></span><br><span class="line">    X_sym = pd.DataFrame(data[<span class="string">'floor'</span>])</span><br><span class="line">    imp_mean = SimpleImputer(missing_values=NA, strategy=<span class="string">'most_frequent'</span>, copy=<span class="literal">True</span>)  <span class="comment"># 对非数值型数据用众数填充</span></span><br><span class="line">    X_symfilled = imp_mean.fit_transform(X_sym)</span><br><span class="line">    <span class="comment"># 对非数值型数据进行one-hot编码,X_onehot是ndarray对象</span></span><br><span class="line">    X_onehot = OneHotEncoder(sparse=<span class="literal">False</span>).fit_transform(X_symfilled)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取数值型数据</span></span><br><span class="line">    X_num = data.drop([<span class="string">'floor'</span>], axis=<span class="number">1</span>)</span><br><span class="line">    imp_mean = SimpleImputer(missing_values=NA, strategy=<span class="string">'mean'</span>)  <span class="comment"># 对数值型数据用均值填充</span></span><br><span class="line">    X_numfilled = imp_mean.fit_transform(X_num)  <span class="comment"># 缺失处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 组合成新的数据</span></span><br><span class="line">    data2 = np.hstack((X_id, X_onehot, X_numfilled))</span><br><span class="line">    index = data2[:, <span class="number">0</span>].astype(int)  <span class="comment"># 第一列是id，不应加入预测</span></span><br><span class="line">    x = data2[:, <span class="number">1</span>:<span class="number">14</span>]</span><br><span class="line">    y = data2[:, <span class="number">14</span>].astype(int)</span><br><span class="line"></span><br><span class="line">    y_pred = PredByLogisticRegression(x, y) <span class="comment"># 调用逻辑回归</span></span><br><span class="line">    <span class="comment"># y_pred = PredByPolynomialRegression(x, y) # 调用多项式线性回归</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"MSE均方误差： %.2f"</span> % mean_squared_error(y, y_pred))  <span class="comment"># 均方差</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2000行数据太多，只显示前100个数据的拟合情况</span></span><br><span class="line">    plt.scatter(index[<span class="number">0</span>:<span class="number">100</span>], y[<span class="number">0</span>:<span class="number">100</span>], color=<span class="string">'blue'</span>)</span><br><span class="line">    plt.plot(index[<span class="number">0</span>:<span class="number">100</span>], y_pred[<span class="number">0</span>:<span class="number">100</span>], color=<span class="string">'red'</span>)</span><br><span class="line">    plt.title(<span class="string">'Logistic Regression'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀架构的设计</title>
      <link href="/2020/05/12/%E9%A1%B9%E7%9B%AE/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/05/12/%E9%A1%B9%E7%9B%AE/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>项目描述</strong>：本系统是使用SpringBoot开发的高并发限时抢购秒杀系统，除了实现基本的登录、查看商品列表、秒杀、下单等功能，项目中还针对高并发情况实现了系统缓存和限流。</p><p><strong>项目架构</strong>：SpringBoot+Mybatis+Redis+RabbitMQ</p><p><strong>技术要点</strong>：</p><ol><li><p>基于Cookie实现Session共享，实现单点登录及双重md5密码校验</p></li><li><p>使用Redis做缓存提高访问速度和并发量，库存预减防止超卖，利用内存标记减少对Redis的访问</p></li><li><p>使用页面静态化，加快用户访问速度，缓存页面至浏览器降低服务器压力</p></li><li><p>使用消息队列完成异步下单，提升用户体验，实现高并发场景下的削峰和降流</p></li><li><p>安全性优化：秒杀接口地址的隐藏，接口限流防刷，数学公式验证码</p></li></ol><h3 id="1-基于Cookie实现Session共享，实现单点登录及双重md5密码校验"><a href="#1-基于Cookie实现Session共享，实现单点登录及双重md5密码校验" class="headerlink" title="1.基于Cookie实现Session共享，实现单点登录及双重md5密码校验"></a>1.基于Cookie实现Session共享，实现单点登录及双重md5密码校验</h3><h4 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h4><p>将登陆功能单独抽取出来，每个子系统登陆都把请求发送到该登陆系统。登陆系统在用户第一次登陆之后，随机生成uuid作为key，user信息作为value存入redis，设置过期时间，这样就保留了这次的登陆信息，同时把这个uuid写入客户端的Cookie。之后其它子系统在发起请求时携带着cookie，会先向登陆系统发起请求，如果登陆系统中的redis存在这条uuid对应的用户信息，说明目前已经登录了，则放行直接登陆，否则重定向到登陆页面。</p><h4 id="双重md5密码校验"><a href="#双重md5密码校验" class="headerlink" title="双重md5密码校验"></a>双重md5密码校验</h4><p>前端输入用户名密码之后进行MD5加密（明文密码+固定盐值），再将请求发送给后端，为了防止数据库被入侵，被人通过彩虹表反查出密码，后端再使用随机salt与加过一次密后的密码再做一次加密，最终把加密后的值与随机salt存在数据库里。</p><h3 id="2-使用Redis做缓存提高访问速度和并发量，库存预减防止超卖，利用内存标记减少对Redis的访问"><a href="#2-使用Redis做缓存提高访问速度和并发量，库存预减防止超卖，利用内存标记减少对Redis的访问" class="headerlink" title="2.使用Redis做缓存提高访问速度和并发量，库存预减防止超卖，利用内存标记减少对Redis的访问"></a>2.使用Redis做缓存提高访问速度和并发量，库存预减防止超卖，利用内存标记减少对Redis的访问</h3><h4 id="库存预减"><a href="#库存预减" class="headerlink" title="库存预减"></a>库存预减</h4><p>Controller实现InitializingBean接口，重写afterPropertiesSet方法。容器启动的时候，检测到了实现了接口InitializingBean之后，就会去回调afterPropertiesSet方法,将每种商品的库存数量加载到redis里面去。后端收到请求之后，就先在redis中减库存，当redis中库存为0的时候，就直接返回失败。成功之后，判断秒杀订单是否形成了，如果已经形成了，说明之前已经秒杀过了，返回失败，同时库存也要更新回去，这样就可以防止重复秒杀。之后就可以将请求封装入队列。</p><p>会有个问题，就是一个用户一直点击，redis库存就没了，所以可以把判断是否下单的逻辑放在预减库存之前（或者将已经秒杀的用户存在缓存中）</p><h4 id="内存标记"><a href="#内存标记" class="headerlink" title="内存标记"></a>内存标记</h4><p>设一个标志位，如果库存已经减为0了，就不再接受请求，减少不必要的redis访问</p><h3 id="3-使用消息队列完成异步下单，提升用户体验，实现高并发场景下的削峰和降流"><a href="#3-使用消息队列完成异步下单，提升用户体验，实现高并发场景下的削峰和降流" class="headerlink" title="3.使用消息队列完成异步下单，提升用户体验，实现高并发场景下的削峰和降流"></a>3.使用消息队列完成异步下单，提升用户体验，实现高并发场景下的削峰和降流</h3><p>RabbitMQ监听秒杀MIAOSHA_QUEUE的这名字的通道，如果有消息过来，获取到传入的信息，执行真正的秒杀之前，要判断数据库的库存，判断是否重复秒杀，然后执行秒杀事务（秒杀事务是一个原子操作：库存减1，下订单，写入秒杀订单）</p><ol><li>系统初始化，把商品库存数量stock加载到Redis上面来。</li><li>后端收到秒杀请求，Redis预减库存，如果库存已经到达临界值的时候，就不需要继续请求下去，直接返回失败，即后面的大量请求无需给系统带来压力。</li><li>判断这个秒杀订单形成没有，判断是否已经秒杀到了，避免一个账户秒杀多个商品，判断是否重复秒杀。（将秒杀过的用户缓存在redis中）</li><li>库存充足，且无重复秒杀，将秒杀请求封装后消息入队，同时给前端返回一个code (0)，即代表返回排队中。（返回的并不是失败或者成功，此时还不能判断）</li><li>前端接收到数据后，显示排队中，并根据商品id轮询请求服务器（考虑200ms轮询一次）。</li><li>后端RabbitMQ监听秒杀MIAOSHA_QUEUE的这名字的通道，如果有消息过来，获取到传入的信息，执行真正的秒杀之前，要判断数据库的库存，判断是否重复秒杀，然后执行秒杀事务（秒杀事务是一个原子操作：库存减1，下订单，写入秒杀订单）。</li><li>此时，前端根据商品id轮询请求接口MiaoshaResult,查看是否生成了商品订单，如果请求返回-1代表秒杀失败，返回0代表排队中，返回&gt;0代表商品id说明秒杀成功。<br><strong>返回结果说明</strong>：<br>前端会根据后端返回的值来判断是秒杀结果。<br>  -1 ：库存不足秒杀失败<br>   0 ：排队中，继续轮询</li></ol><h4 id="取消订单"><a href="#取消订单" class="headerlink" title="取消订单"></a>取消订单</h4><p>利用延迟消息。下单未付款设定一个过期时间如15分钟，超过这个时间未付款则自动取消。</p><h3 id="4-使用页面静态化，加快用户访问速度，缓存页面至浏览器降低服务器压力"><a href="#4-使用页面静态化，加快用户访问速度，缓存页面至浏览器降低服务器压力" class="headerlink" title="4.使用页面静态化，加快用户访问速度，缓存页面至浏览器降低服务器压力"></a>4.使用页面静态化，加快用户访问速度，缓存页面至浏览器降低服务器压力</h3><h4 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h4><p>商品列表页：访问页面的时候先从redis中查找是否已经缓存了，若缓存直接获取html页面，否则从数据库中取数据，并使用模板引擎手动渲染（<code>thymeleafViewResolver.getTemplateEngine().process()</code>）成html，将html存入redis。</p><h4 id="URL缓存"><a href="#URL缓存" class="headerlink" title="URL缓存"></a>URL缓存</h4><p>用在详情页，其实和页面缓存本质是一样的，只是url可以根据商品id更换页面，进而继续缓存。</p><h4 id="对象缓存"><a href="#对象缓存" class="headerlink" title="对象缓存"></a>对象缓存</h4><p>前端发来了获取某个用户信息的请求，从数据库获取后，就将这个对象缓存至redis</p><h4 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h4><p>做了页面缓存：第一次访问页面，生成缓存，之后再访问直接取redis中缓存的html，那么这种方式每次都还是需要请求服务器，所以还可以继续优化，就是用页面静态化的方式。</p><p>页面静态化之后，第一次是去请求后台要渲染好的html页面，之后的请求都是直接访问用户本地浏览器的缓存的html页面 ，静态资源，然后前端通过Ajax异步来访问后端，只去获取页面需要显示的数据返回即可。</p><h3 id="5-安全性优化：秒杀接口地址的隐藏，接口限流防刷，数学公式验证码"><a href="#5-安全性优化：秒杀接口地址的隐藏，接口限流防刷，数学公式验证码" class="headerlink" title="5.安全性优化：秒杀接口地址的隐藏，接口限流防刷，数学公式验证码"></a>5.安全性优化：秒杀接口地址的隐藏，接口限流防刷，数学公式验证码</h3><h4 id="接口地址的隐藏"><a href="#接口地址的隐藏" class="headerlink" title="接口地址的隐藏"></a>接口地址的隐藏</h4><p>只有用户在秒杀时间到了之后点击按钮发起请求才能获取到秒杀路径，后端随机生成路径path(url : “/miaosha/” + path + “/do_miaosha”)并设置过期时间写入redis后返回给前端，前端再向该路径发起请求，后端验证是否与redis中的路径一致，一致则可以进行抢购</p><h4 id="图形验证码"><a href="#图形验证码" class="headerlink" title="图形验证码"></a>图形验证码</h4><p>后端随机生成验证码，并计算结果以及用户id、商品id存入redis，前端在请求秒杀地址之前需要先写入验证码计算结果，与redis中记录的进行对比，通过才动态生成地址给前端</p><p>需要注意的是请求可能会去从缓存中拿，所以url加个timestamp参数</p><h4 id="接口限流防刷"><a href="#接口限流防刷" class="headerlink" title="接口限流防刷"></a>接口限流防刷</h4><p>利用缓存实现，用户每次点击之后访问接口的时候，在缓存中生成一个计数器（需要用户id以及url作为key），第一次将这个计数器置1后存入缓存，并给其设定有效期，比如一分钟，一分钟之内再访问，那么数值加一。一分钟之内访问次数超过限定数值，直接返回失败。下一个一分钟，数据重新从0开始计算。因为缓存具有一个有效期，一分钟之后自动失效。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归题目合集</title>
      <link href="/2020/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">矩形覆盖</a></h3><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p>比如n=3时，2*3的矩形块有3种覆盖方法：</p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200525222715"  alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2*n的矩阵，宽是固定的</span></span><br><span class="line">        <span class="comment">// 如果是竖着摆的，右边可以横着也可以竖着</span></span><br><span class="line">        <span class="comment">// 如果是横着摆的，下方那块也必须是横着摆的</span></span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">1</span>)&#123;    <span class="comment">// 递归会到RectCover(0)的情况，所以题目即使不会给0，也要考虑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span> || target == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RectCover(target - <span class="number">1</span>) + RectCover(target - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划题目合集</title>
      <link href="/2020/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/"/>
      <url>/2020/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>1、买卖股票最大收益</p><blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><p>示例：</p><blockquote><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>  注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; min)&#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max = Math.max(max, prices[i] - min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、买卖股票最大收益（可多次买卖）</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener">力扣</a></p><p>题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。</p><p>贪心：对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            profit += Math.max(prices[i] - prices[i-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划：第<code>i</code>天只有两种状态，不持有或持有股票，当天不持有股票的状态可能来自昨天卖出或者昨天也不持有，同理，当天持有股票的状态可能来自昨天买入或者昨天也持有中，取最后一天的不持有股票状态就是问题的解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、最大连续子数组求和</p><p><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">力扣</a></p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> presum[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        presum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = presum[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            presum[i] = presum[i-<span class="number">1</span>] &gt; <span class="number">0</span> ? presum[i-<span class="number">1</span>]+nums[i] : nums[i];</span><br><span class="line">            max = Math.max(presum[i], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以用presum代替presum进行优化，这样好理解写</span></span><br></pre></td></tr></table></figure><p>4、矩阵的最小路径和</p><p><a href="https://leetcode.com/problems/minimum-path-sum/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/minimum-path-sum/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[[1,3,1],</span><br><span class="line"> [1,5,1],</span><br><span class="line"> [4,2,1]]</span><br><span class="line">Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure><p>求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++)&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = dp[j];        <span class="comment">// 只能从上侧走到该位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>];    <span class="comment">// 只能从左侧走到该位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] += grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、数组中等差递增子区间的个数</p><p><a href="https://leetcode.com/problems/arithmetic-slices/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/arithmetic-slices/description/" target="_blank" rel="noopener">力扣</a></p><blockquote><p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><p>示例:</p><p>A = [1, 2, 3, 4]</p><p>返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</p></blockquote><p>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p><p>当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.length == <span class="number">0</span> || A == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] - A[i-<span class="number">1</span>] == A[i-<span class="number">1</span>] - A[i-<span class="number">2</span>])&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">            res += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、分割整数计算最大乘积</p><p><a href="https://leetcode.com/problems/integer-break/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/integer-break/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">4</span>)&#123;</span><br><span class="line">            n-=<span class="number">3</span>;</span><br><span class="line">            res*=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP与UDP详解</title>
      <link href="/2020/05/08/%E7%BD%91%E7%BB%9C/TCP%E4%B8%8EUDP/"/>
      <url>/2020/05/08/%E7%BD%91%E7%BB%9C/TCP%E4%B8%8EUDP/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="hofe.work">欢迎来我的个人网站</a>，里面有最新的版本</p><p>这篇介绍了下TCP与UDP面试题常考内容，并做了延伸，解释了原理。</p></blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>tcp和udp的区别</p><p>tcp如何实现可靠性</p><p>怎么实现拥塞控制</p><p>cookie、session</p><h2 id="一、TCP-IP协议"><a href="#一、TCP-IP协议" class="headerlink" title="一、TCP/IP协议"></a>一、TCP/IP协议</h2><blockquote><p>TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是<strong>指能够在多个不同网络间实现信息传输的协议簇</strong>。TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。<br><strong>我的理解：</strong> 互联网中的设备要相互通信，必须基于相同的方式，比如由哪一方发起通讯，使用什么语言进行通讯，怎么结束通讯这些都要事先确定，不同设备之间的通讯都需要一种规则，我们将这种规则成为协议。</p></blockquote><h3 id="1-1-TCP-IP-的分层管理图"><a href="#1-1-TCP-IP-的分层管理图" class="headerlink" title="1.1 TCP/IP 的分层管理图"></a>1.1 TCP/IP 的分层管理图</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200508144146.png"  alt="TCP/IP模型"></p><h4 id="1-1-1-应用层"><a href="#1-1-1-应用层" class="headerlink" title="1.1.1 应用层"></a>1.1.1 应用层</h4><p>TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现。这一层主要的代表有<strong>DNS域名解析/http</strong>协议</p><h4 id="1-1-2-传输层"><a href="#1-1-2-传输层" class="headerlink" title="1.1.2 传输层"></a>1.1.2 传输层</h4><p>在TCP/IP模型中，传输层的功能是使<strong>源端主机和目标端主机上的对等实体可以进行会话</strong>。在传输层定义了两种服务质量不同的协议。即：<strong>传输控制协议TCP和用户数据报协议UDP</strong>.</p><h4 id="1-1-3-网络层"><a href="#1-1-3-网络层" class="headerlink" title="1.1.3 网络层"></a>1.1.3 网络层</h4><p>网络层是整个TCP/IP协议栈的核心。它的功能是<strong>把分组发往目标网络或主机</strong>。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。网络层定义了分组格式和协议，即IP协议（Internet Protocol ）。</p><h4 id="1-1-4-数据链路层"><a href="#1-1-4-数据链路层" class="headerlink" title="1.1.4 数据链路层"></a>1.1.4 数据链路层</h4><p><strong>控制网络层与物理层之间的通信</strong>，主要功能是保证物理线路上进行可靠的数据传递。为了保证传输，<strong>从网络层接收到的数据被分割成特定的可被物理层传输的帧</strong>。帧是用来移动数据结构的结构包，他不仅包含原始数据，还包含发送方和接收方的物理地址以及纠错和控制信息。其中的地址确定了帧将发送到何处，而纠错和控制信息则确保帧无差错到达。如果在传达数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。</p><h4 id="1-1-5-物理层"><a href="#1-1-5-物理层" class="headerlink" title="1.1.5 物理层"></a>1.1.5 物理层</h4><p>该层负责 <strong>比特流在节点之间的传输，即负责物理传输</strong>，这一层的协议既与链路有关，也与传输的介质有关。通俗来说就是把计算机连接起来的物理手段。</p><h2 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a>二、UDP</h2><h4 id="2-1-首部"><a href="#2-1-首部" class="headerlink" title="2.1 首部"></a>2.1 首部</h4><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200508150841.png"  alt=""></p><p>UDP用户数据报有两个字段：<strong>首部</strong>字段和<strong>数据</strong>字段，数据字段很简单，只有8个字节；首部由四个字段组成，每个字段的长度都是两个字节。各字段意义如下：</p><ol><li><strong>源端口：</strong> 源端口号，在需要给对方回信时使用。不需要是可全用0.</li><li><strong>目的端口号：</strong> 这在终点交付报文时必须使用。</li><li><strong>长度：</strong> 用户数据报UDP的长度，最小为8（仅首部）。</li><li><strong>校验和：</strong> 用于<strong>校验用户数据报在传输过程是否出错</strong>，出错则丢弃该报文</li></ol><h2 id="三、TCP"><a href="#三、TCP" class="headerlink" title="三、TCP"></a>三、TCP</h2><h3 id="3-1-首部"><a href="#3-1-首部" class="headerlink" title="3.1 首部"></a>3.1 首部</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200508144900.png"  alt=""></p><p><strong>源端口和目的端口:</strong> 各占两个字节，分别写入源端口号和目的端口号。<br><strong>序号 ：</strong> 占4个字节；<strong>用于对字节流进行编号</strong>，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。<br><strong>确认号 ：</strong> 占4个字节；<strong>期望收到的下一个报文段的序号</strong>。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。<br><strong>数据偏移 ：</strong> 占4位；指的是<strong>数据部分距离报文段起始处的偏移量</strong>，<strong>实际上指的是首部的长度</strong>。<br><strong>确认 ACK ：</strong> 当 ACK=1 时<strong>确认号字段有效</strong>，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。<br>同步 SYN ：在<strong>连接建立时用来同步序号</strong>。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。<br><strong>终止 FIN ：</strong> 用来<strong>释放一个连接</strong>，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。<br><strong>窗口 ：</strong> 占2字节；窗口值作为<strong>接收方让发送方设置其发送窗口的依据</strong>。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。<br><strong>检验和：</strong> 占2个字节；检验和字段<strong>检验</strong>的范围包括<strong>首部和数据</strong>这两个部分。在计算检验和时，在TCP报文段的前面加上12字节的伪首部。</p><p><strong>紧急指针字段</strong>：占 16 位，指出在本报文段中紧急数据共有多少个字节(紧急数据放在本报文段数据的最前面)；</p><p><strong>套接字：</strong> TCP连接的端点叫做套接字或插口。端口号拼接到IP地址即构成了套接字。</p><h3 id="3-2-三次握手"><a href="#3-2-三次握手" class="headerlink" title="3.2 三次握手"></a>3.2 三次握手</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200508154922.png"  alt=""></p><ul><li>第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；</li><li>第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；</li><li>第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。</li></ul><h4 id="3-2-1-TCP建立连接可以两次握手吗？为什么"><a href="#3-2-1-TCP建立连接可以两次握手吗？为什么" class="headerlink" title="3.2.1 TCP建立连接可以两次握手吗？为什么?"></a>3.2.1 TCP建立连接可以两次握手吗？为什么?</h4><p>不可以。有两个原因：</p><ul><li><p>可能会出现<strong>已失效的连接请求报文段又传到了服务器端</strong>。</p><p>client 发出的第一个连接请求报文段并没有丢失，而是在某个<strong>网络结点长时间的滞留</strong>了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。<strong>假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了</strong>。由于现在 client 并没有发出建立连接的请求，因此<strong>不会理睬 server 的确认</strong>，也不会向 server 发送数据。但 <strong>server 却以为新的运输连接已经建立，并一直等待 client 发来数据</strong>。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</p></li><li><p>其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。</p></li></ul><h4 id="3-2-2-可以采用四次握手吗？为什么？"><a href="#3-2-2-可以采用四次握手吗？为什么？" class="headerlink" title="3.2.2 可以采用四次握手吗？为什么？"></a>3.2.2 可以采用四次握手吗？为什么？</h4><p>可以。但是会降低传输的效率。</p><p>四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。</p><h4 id="3-2-3-第三次握手中，如果客户端的ACK未送达服务器，会怎样？"><a href="#3-2-3-第三次握手中，如果客户端的ACK未送达服务器，会怎样？" class="headerlink" title="3.2.3 第三次握手中，如果客户端的ACK未送达服务器，会怎样？"></a>3.2.3 第三次握手中，如果客户端的ACK未送达服务器，会怎样？</h4><p>Server端：<br>由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。</p><h4 id="3-2-4-如果已经建立了连接，但客户端出现了故障怎么办？"><a href="#3-2-4-如果已经建立了连接，但客户端出现了故障怎么办？" class="headerlink" title="3.2.4 如果已经建立了连接，但客户端出现了故障怎么办？"></a>3.2.4 如果已经建立了连接，但客户端出现了故障怎么办？</h4><p><strong>服务器每收到一次客户端的请求后都会重新复位一个计时器</strong>，时间通常是设置为2小时，若<strong>两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段</strong>，以后<strong>每隔75秒钟发送一次</strong>。若一连发送<strong>10个探测报文</strong>仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h4 id="3-2-5-初始序列号是什么？"><a href="#3-2-5-初始序列号是什么？" class="headerlink" title="3.2.5 初始序列号是什么？"></a>3.2.5 初始序列号是什么？</h4><p>TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002…三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。</p><h3 id="3-3-四次挥手"><a href="#3-3-四次挥手" class="headerlink" title="3.3 四次挥手"></a>3.3 四次挥手</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200508160654.png"  alt=""></p><ul><li>第一次挥手：Client将<strong>FIN置为1，发送一个序列号seq给Server</strong>；进入<strong>FIN_WAIT_1</strong>状态；</li><li>第二次挥手：Server收到FIN之后，发送一个<strong>ACK=1，acknowledge number=收到的序列号+1</strong>；进入<strong>CLOSE_WAIT</strong>状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</li><li>第三次挥手：Server将<strong>FIN置1，发送一个序列号给Client</strong>；进入<strong>LAST_ACK</strong>状态；</li><li>第四次挥手：Client收到服务器的FIN后，进入<strong>TIME_WAIT</strong>状态；接着将<strong>ACK置1，发送一个acknowledge number=序列号+1</strong>给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</li></ul><h4 id="3-3-1-为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？"><a href="#3-3-1-为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？" class="headerlink" title="3.3.1 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？"></a>3.3.1 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？</h4><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时<strong>先回复ACK，表示接收到了断开连接的请求</strong>。等到<strong>数据发完之后再发FIN，断开服务器到客户端的数据传送</strong>。</p><h4 id="3-3-2-如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"><a href="#3-3-2-如果第二次挥手时服务器的ACK没有送达客户端，会怎样？" class="headerlink" title="3.3.2 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"></a>3.3.2 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？</h4><p>客户端没有收到ACK确认，会重新发送FIN请求。</p><h4 id="3-3-3-客户端TIME-WAIT状态的意义是什么？"><a href="#3-3-3-客户端TIME-WAIT状态的意义是什么？" class="headerlink" title="3.3.3 客户端TIME_WAIT状态的意义是什么？"></a>3.3.3 客户端TIME_WAIT状态的意义是什么？</h4><p>第四次挥手时，客户端发送给服务器的ACK有可能丢失，<strong>TIME_WAIT状态就是用来重发可能丢失的ACK报文</strong>。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会<strong>重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN</strong>。</p><p>MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h3 id="3-4-流量控制"><a href="#3-4-流量控制" class="headerlink" title="3.4 流量控制"></a>3.4 流量控制</h3><p><a href="https://github.com/wolverinn/Waking-Up/blob/master/_v_images/20191129145400104_2106.png" target="_blank" rel="noopener"><img src="/" class="lazyload" data-src="https://github.com/wolverinn/Waking-Up/raw/master/_v_images/20191129145400104_2106.png"  alt="滑动窗口"></a></p><p><strong>使用滑动窗口协议实现流量控制</strong>。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在<strong>返回ACK时将接受窗口大小放在TCP报文中的窗口字段</strong>告知发送方。发送窗口的大小不能超过接受窗口的大小，<strong>只有当发送方发送并收到确认之后，才能将发送窗口右移</strong>。</p><p>发送窗口的上限为<strong>接受窗口和拥塞窗口中的较小值</strong>。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。</p><h4 id="3-4-1-什么是零窗口（接收窗口为0时会怎样）？"><a href="#3-4-1-什么是零窗口（接收窗口为0时会怎样）？" class="headerlink" title="3.4.1 什么是零窗口（接收窗口为0时会怎样）？"></a>3.4.1 什么是零窗口（接收窗口为0时会怎样）？</h4><p>接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个<strong>持续计时器</strong>(persistence timer)，到期后发送一个大小为<strong>1字节的探测数据包</strong>，以查看接收窗口状态。如果接收方能够接收数据，就会在<strong>返回的报文中更新接收窗口大小</strong>，恢复数据传送。</p><h3 id="3-5-拥塞控制"><a href="#3-5-拥塞控制" class="headerlink" title="3.5 拥塞控制"></a>3.5 拥塞控制</h3><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200607151826.png"  alt=""></p><p>拥塞控制主要由四个算法组成：<strong>慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）</strong></p><ol><li>慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个<strong>最大报文段MSS的数值</strong>，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍</li></ol><p><a href="https://github.com/wolverinn/Waking-Up/blob/master/_v_images/20191129155345024_11142.png" target="_blank" rel="noopener"><img src="/" class="lazyload" data-src="https://github.com/wolverinn/Waking-Up/raw/master/_v_images/20191129155345024_11142.png"  alt="slow start"></a></p><ol start="2"><li>拥塞避免：当拥塞窗口的大小达到<strong>慢启动门限</strong>(slow start threshold)时，开始执行<strong>拥塞避免</strong>算法，拥塞窗口大小不再指数增加，而是<strong>线性增加</strong>，即每经过一个传输轮次只增加1MSS.</li></ol><blockquote><p>发生超时重传，判断网络出现拥塞</p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢启动算法。<strong>（这是不使用快重传的情况）</strong></p></blockquote><p>快重传：快重传要求接收方在<strong>收到一个失序的报文段</strong>后就立即发出<strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当<strong>立即重传对方尚未收到的报文段</strong>，而不必继续等待设置的重传计时器时间到期。</p><p><a href="https://github.com/wolverinn/Waking-Up/blob/master/_v_images/20191129161026032_32431.png" target="_blank" rel="noopener"><img src="/" class="lazyload" data-src="https://github.com/wolverinn/Waking-Up/raw/master/_v_images/20191129161026032_32431.png"  alt="快重传"></a></p><p>快恢复：当发送方连续收到三个重复确认时，就把<strong>慢启动门限和拥塞窗口的值减半，然后执行拥塞避免算法</strong>。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。<br>也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。</p><h2 id="四、面试题"><a href="#四、面试题" class="headerlink" title="四、面试题"></a>四、面试题</h2><h3 id="4-1-TCP与UDP的区别"><a href="#4-1-TCP与UDP的区别" class="headerlink" title="4.1 TCP与UDP的区别"></a>4.1 TCP与UDP的区别</h3><ol><li>TCP是面向连接的，UDP是无连接的；（UDP发送数据之前不需要建立连接）</li><li>TCP是可靠的，UDP不可靠；（UDP接收方收到报文后，不需要给出任何确认）</li><li>TCP<strong>只支持点对点通信</strong>，UDP支持一对一、一对多、多对一、多对多；</li><li>TCP是<strong>面向字节流</strong>的，UDP是面向报文的；（面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。）</li><li>TCP有<strong>拥塞控制机制</strong>，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；</li><li>TCP首部开销（20字节）比UDP首部开销（8字节）要大</li><li>UDP 的主机不需要维持复杂的连接状态表</li></ol><h4 id="什么时候选择TCP，什么时候选UDP？"><a href="#什么时候选择TCP，什么时候选UDP？" class="headerlink" title="什么时候选择TCP，什么时候选UDP？"></a>什么时候选择TCP，什么时候选UDP？</h4><p>对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失</p><h4 id="HTTP可以使用UDP吗？"><a href="#HTTP可以使用UDP吗？" class="headerlink" title="HTTP可以使用UDP吗？"></a>HTTP可以使用UDP吗？</h4><p>HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠</p><h4 id="面向连接和无连接的区别"><a href="#面向连接和无连接的区别" class="headerlink" title="面向连接和无连接的区别"></a>面向连接和无连接的区别</h4><p>无连接的网络服务（数据报服务）– 面向连接的网络服务（虚电路服务）</p><p>虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；</p><p>数据报服务：<strong>每个数据包含目的地址，数据路由相互独立</strong>（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；</p><h3 id="4-2-TCP如何保证传输的可靠性"><a href="#4-2-TCP如何保证传输的可靠性" class="headerlink" title="4.2 TCP如何保证传输的可靠性"></a>4.2 TCP如何保证传输的可靠性</h3><ol><li>数据包校验</li><li>对失序数据包重新排序（TCP报文具有序列号）</li><li>丢弃重复数据</li><li>应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；</li><li>超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；</li><li>流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出</li></ol><h3 id="4-3-UDP如何实现可靠传输"><a href="#4-3-UDP如何实现可靠传输" class="headerlink" title="4.3 UDP如何实现可靠传输"></a>4.3 UDP如何实现可靠传输</h3><p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。</p><p><strong>传输层无法保证数据的可靠传输，只能通过应用层来实现</strong>了。实现的方式可以<strong>参照tcp可靠性传输的方式</strong>，只是实现不在传输层，实现转移到了应用层。</p><p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p><ul><li>1、添加seq/ack机制，确保数据发送到对端</li><li>2、添加发送和接收缓冲区，主要是用户超时重传。</li><li>3、添加超时重传机制。</li></ul><p>详细说明：发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p><p>目前有如下开源程序利用udp实现了可靠的数据传输。分别为<strong>RUDP、RTP、UDT</strong>。</p><p><strong>总结</strong>：UDP要想可靠，就要接收方<strong>收到UDP之后回复个确认包</strong>，发送方有个机制，<strong>收不到确认包就要重新发送</strong>；每个包有<strong>递增的序号</strong>，<strong>接收方发现中间丢了包就要发重传请求</strong>；当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，所以要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> TCP/IP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Session与Cookie</title>
      <link href="/2020/05/08/%E7%BD%91%E7%BB%9C/Session%E4%B8%8ECookie/"/>
      <url>/2020/05/08/%E7%BD%91%E7%BB%9C/Session%E4%B8%8ECookie/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="hofe.work">欢迎来我的个人网站</a>，里面有最新的版本</p><p>这篇介绍了下Session 和 Cookie面试题常考内容，并做了延伸，解释了原理。没有太过详细，之后会补充。</p></blockquote><h2 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h2><h3 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h3><p>HTTP协议是无状态的协议。<strong>一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接，这就意味着服务器无法从连接上跟踪会话</strong>。</p><p>Cookie通过在<strong>客户端记录信息</strong>确定用户身份，在客户端发起请求的时候，携带上cookie，服务器通过该cookie辨认用户信息。以此来弥补HTTP协议无状态的不足。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>Cookie是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用<strong>response向客户端浏览器颁发一个Cookie</strong>。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，<strong>浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态</strong>。</p><h3 id="二、Session"><a href="#二、Session" class="headerlink" title="二、Session"></a>二、Session</h3><p>Session是<strong>服务器端使用的一种记录客户端状态的机制</strong>，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。</p><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端<strong>浏览器再次访问时只需要从该Session中查找该客户的状态</strong>就可以了。</p><p>保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。</p><h2 id="三、核心概念"><a href="#三、核心概念" class="headerlink" title="三、核心概念"></a>三、核心概念</h2><h3 id="Session和Cookie的区别？"><a href="#Session和Cookie的区别？" class="headerlink" title="Session和Cookie的区别？"></a>Session和Cookie的区别？</h3><ol><li><p>数据存储位置：cookie数据存放在客户的浏览器上，客户端请求服务器时会将Cookie一起提交；session数据放在服务器上，通过检索Sessionid查看状态。</p></li><li><p>安全性：cookie不是很安全，别人可以<strong>分析存放在本地的cookie并进行cookie欺骗</strong>，考虑到安全应当使用session。</p></li><li><p>服务器性能：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。</p></li><li><p>数据大小：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p></li><li><p>信息重要程度：可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。</p></li></ol><h3 id="Cookie、session和token的区别"><a href="#Cookie、session和token的区别" class="headerlink" title="Cookie、session和token的区别"></a>Cookie、session和token的区别</h3><p><strong>Cookie的原理</strong></p><p>（1）客户端第一次请求时，发送数据到服务器。</p><p>（2）服务器返回响应信息的同时，还会传回一个cookie（cookie S-001）</p><p>（3）客户端接收服务器的响应之后，浏览器会将cookie存放在一个统一的位置。</p><p>（4）客户端再次向服务器发送请求的时候，会把Cookie S-001再次发挥服务器。</p><p><strong>Token的原理</strong></p><p>（1）客户端第一次请求时，发送用户信息到服务器。服务器对用户信息使用HSA256算法及密钥进行签名，再将这个签名和数据一起作为token返回给客户户端。</p><p>（2）服务端不再保存token，客户端保存token。</p><p>（3）当客户端再次发送请求时，在请求信息中将token一起发送给服务器。</p><p>（4）服务器用同样的HSA256算法和密钥，对数据再计算一次签名，和token的签名做比较</p><p>（5）如果相同，服务器就知道客户端登录过，则反之。</p><p><strong>session的原理</strong></p><p>（1）服务器在处理客户端请求过程中会创建session，并且为该session生存唯一的session ID。（这个session ID在随后的请求中会被用来重新获得已经创建的session。在session被创建后，就可以调用session相关的方法向session中新增内容，这些内容只会保存在服务器中） </p><p>（2）服务器将session ID发送到客户端</p><p>（3）当客户端再次请求时，就会带上这个session ID</p><p>（4）服务器接收到请求之后就会一句Session ID 找到相应的Session ，完成请求</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Session </tag>
            
            <tag> Cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/05/07/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/07/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>只完成了单例、代理、装饰三种，其余待完善</p></blockquote><h2 id="一、设计模式划分"><a href="#一、设计模式划分" class="headerlink" title="一、设计模式划分"></a>一、设计模式划分</h2><p><img src="/" class="lazyload" data-src="https://images2017.cnblogs.com/blog/401339/201709/401339-20170928225241215-295252070.png"  alt=""></p><p>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</p><p>结构型模式：把类或对象结合在一起形成一个更大的结构。</p><p>行为型模式：类和对象如何交互，及划分责任和算法。</p><h2 id="二、创建型模式"><a href="#二、创建型模式" class="headerlink" title="二、创建型模式"></a>二、创建型模式</h2><h3 id="2-1-单例模式"><a href="#2-1-单例模式" class="headerlink" title="2.1 单例模式"></a>2.1 单例模式</h3><blockquote><p>某个类只能有一个实例，提供一个全局的访问点。</p></blockquote><h4 id="2-1-1-实现原理"><a href="#2-1-1-实现原理" class="headerlink" title="2.1.1 实现原理"></a>2.1.1 实现原理</h4><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p><p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p><p><strong>使用场景</strong></p><p>● 要求生成唯一序列号的环境；</p><p>● 在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；</p><p>● 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；</p><p>● 需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当然，也可以直接声明为static的方式）。</p><h4 id="2-1-2-懒汉式-线程不安全"><a href="#2-1-2-懒汉式-线程不安全" class="headerlink" title="2.1.2 懒汉式-线程不安全"></a>2.1.2 懒汉式-线程不安全</h4><p>只要实例还未被初始化，则new Singleton()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;<span class="comment">// 私有静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;<span class="comment">// 私有构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;<span class="comment">// 公有静态函数</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方式在多线程下是不安全的，多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p><h4 id="2-1-3-懒汉式-线程安全"><a href="#2-1-3-懒汉式-线程安全" class="headerlink" title="2.1.3 懒汉式-线程安全"></a>2.1.3 懒汉式-线程安全</h4><p>只需要对 getUniqueInstance() 方法<strong>加锁</strong>，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。</p><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="comment">// 私有静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有静态函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-4-饿汉式-线程安全"><a href="#2-1-4-饿汉式-线程安全" class="headerlink" title="2.1.4 饿汉式-线程安全"></a>2.1.4 饿汉式-线程安全</h4><p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。这样多线程也就创建多个实例了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();<span class="comment">// 私有静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;<span class="comment">// 私有构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;<span class="comment">// 公有静态函数</span></span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p><h4 id="2-1-5-双重校验锁-线程安全"><a href="#2-1-5-双重校验锁-线程安全" class="headerlink" title="2.1.5 双重校验锁-线程安全"></a>2.1.5 双重校验锁-线程安全</h4><p>只有当 uniqueInstance 没有被实例化时，才需要进行加<code>synchronize</code>锁，不对整个方法加锁。但这时候多个线程都可以进入该方法了，就可能获取到还没初始化的实例，所以同加<code>volatile</code>，防止指令重排序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 多个进程可进入，依次加锁new 对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 第二重校验，防止第二个线程再new 一次</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-6-静态内部类-安全-延迟加载"><a href="#2-1-6-静态内部类-安全-延迟加载" class="headerlink" title="2.1.6 静态内部类-安全-延迟加载"></a>2.1.6 静态内部类-安全-延迟加载</h4><p>当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-简单工厂"><a href="#2-2-简单工厂" class="headerlink" title="2.2 简单工厂"></a>2.2 简单工厂</h3><p>一个工厂类根据传入的参量决定创建出那一种产品类的实例。</p><h3 id="2-3-工厂方法"><a href="#2-3-工厂方法" class="headerlink" title="2.3 工厂方法"></a>2.3 工厂方法</h3><p>定义一个创建对象的接口，让子类决定实例化那个类。</p><h3 id="2-4-抽象工厂"><a href="#2-4-抽象工厂" class="headerlink" title="2.4 抽象工厂"></a>2.4 抽象工厂</h3><p>创建相关或依赖对象的家族，而无需明确指定具体类。</p><h3 id="2-5-建造者模式"><a href="#2-5-建造者模式" class="headerlink" title="2.5 建造者模式"></a>2.5 建造者模式</h3><p>封装一个复杂对象的构建过程，并可以按步骤构造。</p><h3 id="2-6-原型模式"><a href="#2-6-原型模式" class="headerlink" title="2.6 原型模式"></a>2.6 原型模式</h3><p>通过复制现有的实例来创建新的实例。</p><h2 id="三、结构型模式"><a href="#三、结构型模式" class="headerlink" title="三、结构型模式"></a>三、结构型模式</h2><h3 id="3-1-适配器模式"><a href="#3-1-适配器模式" class="headerlink" title="3.1 适配器模式"></a>3.1 适配器模式</h3><p>将一个类的方法接口转换成客户希望的另外一个接口。</p><h3 id="3-2-组合模式"><a href="#3-2-组合模式" class="headerlink" title="3.2 组合模式"></a>3.2 组合模式</h3><p>将对象组合成树形结构以表示“”部分-整体“”的层次结构。</p><h3 id="3-3-装饰模式"><a href="#3-3-装饰模式" class="headerlink" title="3.3 装饰模式"></a>3.3 装饰模式</h3><blockquote><p>动态的给对象添加新的功能。</p></blockquote><h4 id="3-3-1-实现原理"><a href="#3-3-1-实现原理" class="headerlink" title="3.3.1 实现原理"></a>3.3.1 实现原理</h4><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200507161016.png"  alt=""></p><ul><li><p>Component<code>抽象构件</code>：Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象</p><p>注意：在装饰模式中，必然有一个最基本、最核心、最原始的接口或抽象类充当Component抽象构件。</p></li><li><p>ConcreteComponent <code>具体构件</code></p><p>ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它。</p></li><li><p>Decorator<code>装饰角色</code></p><p>一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，在它的属性里必然有一个private变量指向Component抽象构件。</p></li><li><p>具体装饰角色</p><p>ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的、最原始的、最基本的东西装饰成其他东西。</p></li></ul><p><strong>使用场景</strong></p><ul><li><p>需要扩展一个类的功能，或给一个类增加附加功能。</p></li><li><p>需要动态地给一个对象增加功能，这些功能可以再动态地撤销。</p></li><li><p>需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式。</p></li><li><p>当不能通过生成子类的方法进行扩充时 </p></li></ul><p><strong>优点</strong></p><ul><li><p>无需通过继承增加子类就能扩展新功能。</p></li><li><p>使用关联关系比继承更加灵活，可以用添加和分离的方式，用装饰在运行时 增加和删除职责</p></li><li><p>避免在层次结构高的类有太多特征，用装饰器为其逐渐地添加功能 </p></li></ul><h3 id="3-4-代理模式"><a href="#3-4-代理模式" class="headerlink" title="3.4 代理模式"></a>3.4 代理模式</h3><blockquote><p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</p></blockquote><p>代理有以下三类：</p><ul><li>静态代理：被代理对象与代理对象需要一起实现相同的接口或者是继承相同父类，因此要定义一个接口或抽象类。可以做到在<strong>不修改目标对象的功能前提下，对目标功能扩展</strong>；但因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，类太多，同时，<strong>一旦接口增加方法，目标对象与代理对象都要维护</strong>。</li><li>动态代理：解决静态代理需要维护对象的问题。<strong>在程序运行时JVM才为被代理对象生成代理对象</strong>。常说的动态代理也叫做JDK代理也是一种接口代理，JDK中生成代理对象的代理类就是Proxy，所在包是java.lang.reflect。<strong>代理对象不需要实现接口，但是目标对象一定要实现接口，否则不能使用动态代理</strong>，因此这也算是这种方式的缺陷。</li><li>cglib代理：弥补静态代理和动态代理的目标对象都要实现接口的不足。<strong>并不是任何对象都会实现一个接口</strong>，也存在没有实现任何的接口的对象，这时就可以使用<strong>继承目标类作为目标对象子类的方式实现代理</strong>,这种方法就叫做:Cglib代理，也叫作子类代理，它是在<strong>内存中构建一个子类对象从而实现对目标对象功能的扩展</strong>。</li></ul><p>总结：</p><p><strong>静态代理，代理对象与目标对象都需要实现相同接口，一旦接口增加方法，代理对象和目标对象都要维护。</strong></p><p><strong>动态代理，只需要目标对象实现接口，程序运行时JVM才生成代理对象。</strong></p><p><strong>cglib代理，目标对象和代理对象都可以不实现接口，从内存中构建出一个子类来扩展目标对象的功能。</strong></p><h4 id="3-4-1-实现原理"><a href="#3-4-1-实现原理" class="headerlink" title="3.4.1 实现原理"></a>3.4.1 实现原理</h4><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200507191737.jpg"  alt=""></p><p>记住以下关键点，简单易实现：</p><ul><li><p>代理类与委托类实现同一接口</p></li><li><p>在委托类中实现功能，在代理类的方法中中引用委托类的同名方法</p></li><li><p>外部类调用委托类某个方法时，直接以接口指向代理类的实例，这正是代理的意义所在：屏蔽。</p></li></ul><p><strong>使用场景</strong></p><ul><li><p>当我们想要隐藏某个类时，可以为其提供代理类</p></li><li><p>当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现（代理类不一定只有一个，我们可以建立多个代理类来实现，也可以在一个代理类中金进行权限判断来进行不同权限的功能调用）</p></li></ul><ul><li>当我们要扩展某个类的某个功能时，可以使用代理模式，在代理类中进行简单扩展（只针对简单扩展，可在引用委托类的语句之前与之后进行）</li></ul><h4 id="3-4-2-静态代理"><a href="#3-4-2-静态代理" class="headerlink" title="3.4.2 静态代理"></a>3.4.2 静态代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IStar</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真实对象</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LDHStar</span> <span class="keyword">implements</span> <span class="title">IStar</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"刘德华唱歌"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类需要有真实对象的控制权 (引用)</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ProxyManger</span> <span class="keyword">implements</span> <span class="title">IStar</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 真实对象的引用</span></span><br><span class="line">        <span class="keyword">private</span> IStar star;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProxyManger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProxyManger</span><span class="params">(IStar star)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.star = star;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　　　System.out.println(<span class="string">"唱歌前准备"</span>);</span><br><span class="line">    　　　 star.sing();</span><br><span class="line">   　　　　System.out.println(<span class="string">"善后工作"</span>);        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 创建明星对象</span></span><br><span class="line">            IStar ldh = <span class="keyword">new</span> LDHStar();</span><br><span class="line">            ProxyManger proxy = <span class="keyword">new</span> ProxyManger(ldh);</span><br><span class="line">            proxy.sing();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-动态代理"><a href="#3-4-2-动态代理" class="headerlink" title="3.4.2 动态代理"></a>3.4.2 动态代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目标类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IDog</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GunDog</span> <span class="keyword">implements</span> <span class="title">IDog</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猎狗在跑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogUtils</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"增强方式一"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"增强方式二"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandle</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            DogUtils.method1();</span><br><span class="line">            method.invoke(target, args);</span><br><span class="line">            DogUtils.method2();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//生产代理对象的工厂</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        MyInvocationHandle handle = <span class="keyword">new</span> MyInvocationHandle();</span><br><span class="line">        handle.setTarget(target);</span><br><span class="line">        Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handle);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      IDog dog = <span class="keyword">new</span> GunDog();</span><br><span class="line">      IDog proxy =(IDog) MyProxyFactory.getProxy(dog);</span><br><span class="line">      proxy.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-3-Cglib代理"><a href="#3-4-3-Cglib代理" class="headerlink" title="3.4.3 Cglib代理"></a>3.4.3 Cglib代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实例化一个增强器，也就是cglib中的一个class generator</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置目标类</span></span><br><span class="line">        enhancer.setSuperclass(ArraySort2<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//设置拦截对象，这里直接使用匿名内部类写法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object , Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                String sortName = method.getName();</span><br><span class="line">                <span class="keyword">switch</span> (sortName) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"bubbleSort"</span>:</span><br><span class="line">                    sortName = <span class="string">"冒泡排序"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"selectSort"</span>:</span><br><span class="line">                    sortName = <span class="string">"选择排序"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"quickSort"</span>:</span><br><span class="line">                    sortName = <span class="string">"快速排序"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//此处一定要使用proxy的invokeSuper方法来调用目标类的方法</span></span><br><span class="line">                proxy.invokeSuper(object, args);</span><br><span class="line">                <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"本次"</span> + sortName + <span class="string">"的执行时间为: "</span> + (end -start) + <span class="string">"ms"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//生成代理类并返回一个实例</span></span><br><span class="line">        ArraySort2 arraySort = (ArraySort2) enhancer.create();</span><br><span class="line">        arraySort.bubbleSort(arr);</span><br><span class="line">        arraySort.selectSort(arr);</span><br><span class="line">        arraySort.quickSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArraySort2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-亨元模式"><a href="#3-5-亨元模式" class="headerlink" title="3.5 亨元模式"></a>3.5 亨元模式</h3><p>通过共享技术来有效的支持大量细粒度的对象。</p><h3 id="3-6-外观模式"><a href="#3-6-外观模式" class="headerlink" title="3.6 外观模式"></a>3.6 外观模式</h3><p>对外提供一个统一的方法，来访问子系统中的一群接口。</p><h3 id="3-7-桥接模式"><a href="#3-7-桥接模式" class="headerlink" title="3.7 桥接模式"></a>3.7 桥接模式</h3><p>将抽象部分和它的实现部分分离，使它们都可以独立的变化。</p><h2 id="四、行为型模式"><a href="#四、行为型模式" class="headerlink" title="四、行为型模式"></a>四、行为型模式</h2><h3 id="4-1-模板模式"><a href="#4-1-模板模式" class="headerlink" title="4.1 模板模式"></a>4.1 模板模式</h3><p>定义一个算法结构，而将一些步骤延迟到子类实现。</p><h3 id="4-2-解释器模式"><a href="#4-2-解释器模式" class="headerlink" title="4.2 解释器模式"></a>4.2 解释器模式</h3><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器。</p><h3 id="4-3-策略模式"><a href="#4-3-策略模式" class="headerlink" title="4.3 策略模式"></a>4.3 策略模式</h3><p>定义一系列算法，把他们封装起来，并且使它们可以相互替换。</p><h3 id="4-4-状态模式"><a href="#4-4-状态模式" class="headerlink" title="4.4 状态模式"></a>4.4 状态模式</h3><p>允许一个对象在其对象内部状态改变时改变它的行为。</p><h3 id="4-5-观察者模式"><a href="#4-5-观察者模式" class="headerlink" title="4.5 观察者模式"></a>4.5 观察者模式</h3><p>对象间的一对多的依赖关系。</p><h3 id="4-6-备忘录模式"><a href="#4-6-备忘录模式" class="headerlink" title="4.6 备忘录模式"></a>4.6 备忘录模式</h3><p>在不破坏封装的前提下，保持对象的内部状态。</p><h3 id="4-7-中介者模式"><a href="#4-7-中介者模式" class="headerlink" title="4.7 中介者模式"></a>4.7 中介者模式</h3><p>用一个中介对象来封装一系列的对象交互。</p><h3 id="4-8-命令模式"><a href="#4-8-命令模式" class="headerlink" title="4.8 命令模式"></a>4.8 命令模式</h3><p>将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</p><h3 id="4-9-访问者模式"><a href="#4-9-访问者模式" class="headerlink" title="4.9 访问者模式"></a>4.9 访问者模式</h3><p>在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</p><h3 id="4-10-责任链模式"><a href="#4-10-责任链模式" class="headerlink" title="4.10 责任链模式"></a>4.10 责任链模式</h3><blockquote><p>将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。，将 这些处理器对象连成一条链，并沿这条链传递请求，直到有一个处理器对象处理它为止</p></blockquote><h4 id="4-10-1-实现原理"><a href="#4-10-1-实现原理" class="headerlink" title="4.10.1 实现原理"></a>4.10.1 实现原理</h4><p><strong>适用场景</strong></p><p>1）有多个处理器对象可以处理一个请求，<strong>哪个处理器对象处理该请求在运行时动态确定</strong> </p><p>2）在不明确指定接收者的情况下，向多个处理器对象中的一个提交请求 </p><p>3）可以动态指定一组处理器对象处理请求</p><p><strong>优点</strong> </p><p>1）降低耦合，使得 请求发送者无需知道是哪个处理器对象处理请求 </p><p>2）简化对象的相互连接 </p><p>3）增强了给对象指派责任的灵活性 </p><p>4）方便添加新的请求处理类 </p><h3 id="4-11-迭代器模式"><a href="#4-11-迭代器模式" class="headerlink" title="4.11 迭代器模式"></a>4.11 迭代器模式</h3><p>一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀架构的设计</title>
      <link href="/2020/05/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/%E7%A7%92%E6%9D%80%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2020/05/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/%E7%A7%92%E6%9D%80%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>可访问<a href="hofe.work">个人网站</a>进行阅读最新版本</p><p>转载：<a href="https://mp.weixin.qq.com/s?__biz=MzA3ODQ0Mzg2OA==&amp;mid=2649051049&amp;idx=2&amp;sn=ac38a47f2e5f6f6700a82c4dfda5961b&amp;chksm=87534b9ab024c28c8cdaebdf4800ab741c8780d6a185850043b7ac573f58f0cf24c5e51ddea1&amp;mpshare=1&amp;scene=23&amp;srcid=0509QxlDOcqtDO61HcLNaKQm&amp;sharer_sharetime=1589020470217&amp;sharer_shareid=d476d18cbe4a83b141ea1ff413565f8c#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA3ODQ0Mzg2OA==&amp;mid=2649051049&amp;idx=2&amp;sn=ac38a47f2e5f6f6700a82c4dfda5961b&amp;chksm=87534b9ab024c28c8cdaebdf4800ab741c8780d6a185850043b7ac573f58f0cf24c5e51ddea1&amp;mpshare=1&amp;scene=23&amp;srcid=0509QxlDOcqtDO61HcLNaKQm&amp;sharer_sharetime=1589020470217&amp;sharer_shareid=d476d18cbe4a83b141ea1ff413565f8c#rd</a></p></blockquote><h2 id="一、秒杀应该考虑哪些问题"><a href="#一、秒杀应该考虑哪些问题" class="headerlink" title="一、秒杀应该考虑哪些问题"></a>一、秒杀应该考虑哪些问题</h2><h3 id="1-1-超卖问题"><a href="#1-1-超卖问题" class="headerlink" title="1.1 超卖问题"></a>1.1 超卖问题</h3><p>这就不用解释啥意思了趴</p><h3 id="1-2-高并发"><a href="#1-2-高并发" class="headerlink" title="1.2 高并发"></a>1.2 高并发</h3><p>秒杀具有<strong>时间短、并发量大的特点</strong>，秒杀持续时间只有几分钟，而一般公司都为了制造轰动效应，会以极低的价格来吸引用户，因此参与抢购的用户会非常的多。短时间内会有大量请求涌进来，后端如何<strong>防止并发过高造成缓存击穿或者失效</strong>，<strong>击垮数据库</strong>都是需要考虑的问题。</p><h3 id="1-3-接口防刷"><a href="#1-3-接口防刷" class="headerlink" title="1.3 接口防刷"></a>1.3 接口防刷</h3><p>现在的秒杀大多都会出来针对秒杀对应的软件，这类软件会模拟不断向后台服务器发起请求，一秒几百次都是很常见的，如何防止这类软件的重复无效请求，防止不断发起的请求也是需要我们针对性考虑的</p><h3 id="1-4-秒杀url"><a href="#1-4-秒杀url" class="headerlink" title="1.4 秒杀url"></a>1.4 秒杀url</h3><p>对于普通用户来讲，看到的只是一个比较简单的秒杀页面，在未达到规定时间，<strong>秒杀按钮是灰色</strong>的，一旦到达规定时间，灰色按钮变成可点击状态。这部分是针对小白用户的，如果是稍微有点电脑功底的用户，会通过<strong>F12看浏览器的network看到秒杀的url</strong>，通过特定软件去请求也可以实现秒杀。或者提前知道秒杀url的人，一请求就直接实现秒杀了。这个问题我们需要考虑解决</p><h3 id="1-5-数据库设计"><a href="#1-5-数据库设计" class="headerlink" title="1.5 数据库设计"></a>1.5 数据库设计</h3><p>秒杀有把我们<strong>服务器击垮的风险</strong>，如果让它<strong>与我们的其他业务使用在同一个数据库</strong>中，耦合在一起，就很有可能<strong>牵连和影响其他的业务</strong>。如何防止这类问题发生，就算秒杀发生了宕机、服务器卡死问题，也应该让他尽量不影响线上正常进行的业务</p><h3 id="1-6-大量请求问题"><a href="#1-6-大量请求问题" class="headerlink" title="1.6 大量请求问题"></a>1.6 大量请求问题</h3><p>按照1.2的考虑，就算<strong>使用缓存还是不足以应对短时间的高并发的流量的冲击</strong>。如何承载这样巨大的访问量，同时提供稳定低时延的服务保证，是需要面对的一大挑战。我们来算一笔账，假如使用的是redis缓存，单台redis服务器可承受的QPS大概是10W+左右，如果一个秒杀吸引的用户量足够多的话，单QPS可能达到几十万，单体redis还是不足以支撑如此巨大的请求量。缓存会被击穿，直接渗透到DB,从而击垮mysql.后台会将会大量报错</p><h2 id="二、秒杀系统的设计和技术方案"><a href="#二、秒杀系统的设计和技术方案" class="headerlink" title="二、秒杀系统的设计和技术方案"></a>二、秒杀系统的设计和技术方案</h2><p><img src="/" class="lazyload" data-src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMqbjM9RnB9VuA3mSvUJXBqBnqTvlpVgZj6TMhQqdHTSoNK5a2OWQbj4vQNW7hRwhxWh5of0GtLNA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"  alt=""></p><h3 id="2-1-秒杀页面静态化"><a href="#2-1-秒杀页面静态化" class="headerlink" title="2.1 秒杀页面静态化"></a>2.1 秒杀页面静态化</h3><p>将商品的描述、参数、成交记录、图像、评价等全部<strong>写入到一个静态页面</strong>，用户请求不需要通过访问后端服务器，不需要经过数据库，<strong>直接在前台客户端</strong>生成，这样可以最大可能的减少服务器的压力。</p><p>具体的方法可以使用freemarker模板技术，建立网页模板，填充数据，然后渲染网页</p><h3 id="2-2-接口限流"><a href="#2-2-接口限流" class="headerlink" title="2.2 接口限流"></a>2.2 接口限流</h3><p>秒杀最终的本质是数据库的更新，但是有很多<strong>大量无效的请求</strong>，我们最终要做的就是如何把这些无效的请求过滤掉，<strong>防止渗透到数据库</strong>。限流的话，需要入手的方面很多：</p><h4 id="2-2-1：前端限流"><a href="#2-2-1：前端限流" class="headerlink" title="2.2.1：前端限流"></a>2.2.1：前端限流</h4><p>首先第一步就是通过前端限流，用户在<strong>秒杀按钮点击以后发起请求</strong>，那么在<strong>接下来的5秒是无法点击</strong>(通过设置按钮为disable)。这一小举措开发起来成本很小，但是很有效。</p><h4 id="2-2-2：同一个用户xx秒内重复请求直接拒绝"><a href="#2-2-2：同一个用户xx秒内重复请求直接拒绝" class="headerlink" title="2.2.2：同一个用户xx秒内重复请求直接拒绝"></a>2.2.2：同一个用户xx秒内重复请求直接拒绝</h4><p>具体多少秒需要根据实际业务和秒杀的人数而定，一般限定为10秒。具体的做法就是通过<strong>redis的键过期策略</strong>，首先对每个请求都从<code>String value = redis.get(userId)</code>;如果获取到这个value为空或者为null，表示它是有效的请求，然后放行这个请求。如果<strong>不为空表示它是重复性请求</strong>，直接丢掉这个请求。如果有效,采用<code>redis.setexpire(userId,value,10).value</code>可以是任意值，一般放业务属性比较好,这个是设置以userId为key，10秒的过期时间(10秒后,key对应的值自动为null)</p><h3 id="2-3-令牌桶算法限流"><a href="#2-3-令牌桶算法限流" class="headerlink" title="2.3 令牌桶算法限流"></a>2.3 令牌桶算法限流</h3><p><strong>接口限流的策略</strong>有很多，我们这里采用令牌桶算法。令牌桶算法的基本思路是<strong>每个请求尝试获取一个令牌，后端只处理持有令牌的请求</strong>，生产令牌的速度和效率我们都可以自己限定，guava提供了RateLimter的api供我们使用。</p><p>以下做一个简单的例子,注意需要引入guava</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRateLimiter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1秒产生1个令牌</span></span><br><span class="line">        <span class="keyword">final</span> RateLimiter rateLimiter = RateLimiter.create(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//该方法会阻塞线程，直到令牌桶中能取到令牌为止才继续向下执行。</span></span><br><span class="line">            <span class="keyword">double</span> waitTime= rateLimiter.acquire();</span><br><span class="line">            System.out.println(<span class="string">"任务执行"</span> + i + <span class="string">"等待时间"</span> + waitTime);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"执行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的思路就是通过RateLimiter来限定我们的令牌桶每秒产生1个令牌(生产的效率比较低)，循环10次去执行任务。</p><p><strong>acquire会阻塞当前线程直到获取到令牌</strong>，也就是<strong>如果任务没有获取到令牌，会一直等待</strong>。那么请求就会卡在我们限定的时间内才可以继续往下走，这个方法返回的是线程具体等待的时间。执行如下;</p><p><img src="/" class="lazyload" data-src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMqbjM9RnB9VuA3mSvUJXBqiaFvpv6liaiaiaZm6ALsoQkZ2Ax2Cfp0FPzb7N2nnWAYQiaRg3k1V2FxIqw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"  alt="img"></p><p>可以看到任务执行的过程中，第1个是无需等待的，因为已经在开始的第1秒生产出了令牌。接下来的任务请求就必须等到令牌桶产生了令牌才可以继续往下执行。</p><p><strong>如果没有获取到就会阻塞(有一个停顿的过程)。不过这个方式不太好</strong>，因为用户如果在客户端请求，如果较多的话,直接后台在生产token就会卡顿(用户体验较差)，它是不会抛弃任务的，我们需要一个<strong>更优秀的策略:如果超过某个时间没有获取到，直接拒绝该任务</strong>。接下来再来个案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRateLimiter2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> RateLimiter rateLimiter = RateLimiter.create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeOut = (<span class="keyword">long</span>) <span class="number">0.5</span>;</span><br><span class="line">            <span class="keyword">boolean</span> isValid = rateLimiter.tryAcquire(timeOut, TimeUnit.SECONDS);</span><br><span class="line">            System.out.println(<span class="string">"任务"</span> + i + <span class="string">"执行是否有效:"</span> + isValid);</span><br><span class="line">            <span class="keyword">if</span> (!isValid) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"任务"</span> + i + <span class="string">"在执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中用到了<strong>tryAcquire方法</strong>，这个方法的<strong>主要作用是设定一个超时的时间</strong>，如果在指定的时间内预估(注意是预估并不会真实的等待)，如果能拿到令牌就返回true，如果拿不到就返回false.</p><p>然后我们让无效的直接跳过，这里设定每秒生产1个令牌，让每个任务尝试在0.5秒获取令牌，如果获取不到,就直接跳过这个任务(放在秒杀环境里就是直接抛弃这个请求)；程序实际运行如下：</p><p><img src="/" class="lazyload" data-src="https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaIMqbjM9RnB9VuA3mSvUJXBqtiaicFyvVMKbHodrUdQibjH8V2IRAznV41DokzAibR6EqZC43QrrY7pxVQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"  alt="img"></p><p>只有第1个获取到了令牌，顺利执行了，下面的基本都直接抛弃了，因为0.5秒内，令牌桶(1秒1个)来不及生产就肯定获取不到返回false了。</p><p><strong>这个限流策略的效率有多高呢？</strong>假如我们的并发请求是400万瞬间的请求,将令牌<strong>产生的效率</strong>设为每秒20个，每次尝试<strong>获取令牌的时间</strong>是0.05秒，那么最终测试下来的结果是，每次只会放行4个左右的请求,大量的请求会被拒绝,这就是令牌桶算法的优秀之处。</p><h3 id="2-4-秒杀url的设计"><a href="#2-4-秒杀url的设计" class="headerlink" title="2.4 秒杀url的设计"></a>2.4 秒杀url的设计</h3><p>为了<strong>避免</strong>有程序访问经验的人<strong>通过下单页面url直接访问后台接口</strong>来秒杀货品，我们需要将秒杀的<strong>url实现动态化</strong>，即使是开发整个系统的人都无法在秒杀开始前知道秒杀的url。</p><p>具体的做法就是通过<strong>md5加密一串随机字符作为秒杀的url</strong>，然后<strong>前端访问后台获取具体的url，后台校验</strong>通过之后才可以继续秒杀。</p><hr><h3 id="2-5-单体redis升级为集群redis"><a href="#2-5-单体redis升级为集群redis" class="headerlink" title="2.5 单体redis升级为集群redis"></a>2.5 单体redis升级为集群redis</h3><p>秒杀是一个读多写少的场景，使用redis做缓存再合适不过。不过考虑到缓存击穿问题，我们应该<strong>构建redis集群，采用哨兵模式</strong>，可以提升redis的性能和可用性。</p><h3 id="2-6-redis预减库存"><a href="#2-6-redis预减库存" class="headerlink" title="2.6 redis预减库存"></a>2.6 redis预减库存</h3><p>很多请求进来，都需要后台查询库存,这是一个频繁读的场景。可以使用redis来预减库存，在秒杀开始前可以在redis设值，比如<code>redis.set(goodsId,100)</code>,这里预放的库存为100可以设值为常量),每次下单成功之后,<code>Integer stock = (Integer)redis.get(goosId);</code> 然后判断sock的值，如果小于常量值就减去1;</p><p>不过注意当<strong>取消的时候,需要增加库存</strong>，增加库存的时候也得注意不能大于之间设定的总库存数(<strong>查询库存和扣减库存需要原子操作</strong>，此时可以借助lua脚本)下次下单再获取库存的时候,直接从redis里面查就可以了。</p><h3 id="2-7-异步下单"><a href="#2-7-异步下单" class="headerlink" title="2.7 异步下单"></a>2.7 异步下单</h3><p>为了提升下单的效率，并且防止下单服务的失败。需要将下单这一操作进行异步处理。最常采用的办法是使用队列，<strong>队列</strong>最显著的三个优点：<strong>异步、削峰、解耦</strong>。这里可以采用rabbitmq，<strong>在后台经过了限流、库存校验之后，流入到这一步骤的就是有效请求</strong>。然后发送到队列里，队列接受消息，异步下单。下完单，<strong>入库没有问题可以用短信通知用户秒杀成功。假如失败的话,可以采用补偿机制，重试</strong>。</p><hr><h3 id="2-8-秒杀系统数据库设计"><a href="#2-8-秒杀系统数据库设计" class="headerlink" title="2.8 秒杀系统数据库设计"></a>2.8 秒杀系统数据库设计</h3><p>针对1.5提出的秒杀数据库的问题，因此应该<strong>单独设计一个秒杀数据库</strong>，防止因为秒杀活动的高并发访问拖垮整个网站。</p><h3 id="2-9-精简sql"><a href="#2-9-精简sql" class="headerlink" title="2.9 精简sql"></a>2.9 精简sql</h3><p>典型的一个场景是在进行扣减库存的时候，传统的做法是先查询库存，再去update。这样的话<strong>需要两个sql，而实际上一个sql我们就可以完成的</strong>。本质是利用数据库锁</p><p>可以用这样的做法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> miaosha_goods </span><br><span class="line"><span class="keyword">set</span> stock = stock<span class="number">-1</span> </span><br><span class="line"><span class="keyword">where</span> goos_id =&#123;<span class="comment">#goods_id&#125; and version = #&#123;version&#125; and stock&gt;0;</span></span><br></pre></td></tr></table></figure><p>这样的话，就可以保证<strong>库存不会超卖并且一次更新库存</strong>,还有注意一点这里使用了<strong>版本号的乐观锁</strong>，相比较悲观锁，它的性能较好。</p><hr><h3 id="2-10-使用nginx"><a href="#2-10-使用nginx" class="headerlink" title="2.10 使用nginx"></a>2.10 使用nginx</h3><p>nginx是一个高性能<strong>web服务器</strong>，它的并发能力可以达到几万，而tomcat只有几百。通过<strong>nginx映射客户端请求，再分发到后台tomcat服务器集群</strong>中可以大大提升并发能力。</p><h3 id="2-11-服务降级"><a href="#2-11-服务降级" class="headerlink" title="2.11 服务降级"></a>2.11 服务降级</h3><p>假如在秒杀过程中出现了某个服务器宕机，或者服务不可用，应该做好后备工作。之前的博客里有介绍通过<strong>Hystrix进行服务熔断和降级</strong>，可以开发一个备用服务，假如服务器真的宕机了，<strong>直接给用户一个友好的提示返回，而不是直接卡死，服务器错误等生硬的反馈</strong>。</p><h2 id="三、面试题"><a href="#三、面试题" class="headerlink" title="三、面试题"></a>三、面试题</h2><h3 id="3-1-为什么会超卖"><a href="#3-1-为什么会超卖" class="headerlink" title="3.1 为什么会超卖"></a>3.1 为什么会超卖</h3><p>超卖的原因在于减库存操作是一个事务操作，需要先select，然后insert，最后update -1。最后这个-1操作是不能出现负数的，但是当多用户在有库存的情况下并发操作，出现负数这是无法避免的。</p><h3 id="3-2-怎么解决超卖少卖的问题"><a href="#3-2-怎么解决超卖少卖的问题" class="headerlink" title="3.2 怎么解决超卖少卖的问题"></a>3.2 怎么解决超卖少卖的问题</h3><p>超卖问题是用redis+mq解决的，先将mysql中商品库存信息写入redis；然后每次下单都从redis中做库存预减1，如果库存值减1后大于0，则判断该用户秒杀成功，进入消息队列，做异步减库存，下订单操作。因为redis是单线程的，所以不会存在超卖并发问题。</p><h3 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h3><h3 id="Redis预减库存就不会超卖吗"><a href="#Redis预减库存就不会超卖吗" class="headerlink" title="Redis预减库存就不会超卖吗"></a>Redis预减库存就不会超卖吗</h3><h3 id="了解分布式事务吗"><a href="#了解分布式事务吗" class="headerlink" title="了解分布式事务吗"></a>了解分布式事务吗</h3><h3 id="说一下分布式唯一ID生成"><a href="#说一下分布式唯一ID生成" class="headerlink" title="说一下分布式唯一ID生成"></a>说一下分布式唯一ID生成</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 秒杀 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记进阶篇</title>
      <link href="/2020/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
      <url>/2020/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="hofe.work">欢迎来我的个人网站</a>，里面有最新的版本</p><p>这篇介绍了下MySQL的主从同步及分库分表</p></blockquote><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><p>数据库如何实现并发（主从、分库）</p><p>mysql 主从同步怎么搞的？分哪几个过程？如果有一台新机器要加到从机里，怎么个过程。</p><p>binlog 日志是 master 推的还是 salve 来拉的？</p><h2 id="一、主从复制（同步-分离）"><a href="#一、主从复制（同步-分离）" class="headerlink" title="一、主从复制（同步/分离）"></a>一、主从复制（同步/分离）</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200509155433.png"  alt=""></p><h3 id="1-1-主从复制原理"><a href="#1-1-主从复制原理" class="headerlink" title="1.1 主从复制原理"></a>1.1 主从复制原理</h3><p>复制功能并不是copy文件来实现的，而是借助binlog日志文件里面的SQL命令实现的主从复制，可以理解为我再Master端执行了一条SQL命令，那么在Salve端同样会执行一遍，从而达到主从复制的效果；</p><p><strong>主库会做哪些事？</strong></p><p>1)、在master机器上的操作：<br>当master上的数据发生变化时，该事件变化会按照顺序写入bin-log中；</p><p>当slave链接到master的时候，master机器会为slave开启binlog dump线程；</p><p>当master的binlog发生变化的时候，bin-log dump线程会通知slave，并将相应的binlog内容发送给slave。</p><p><strong>主库会做哪些事？</strong></p><p>2)、在slave机器上操作：</p><p>当主从同步开启的时候，slave上会创建两个线程：I/O线程和SQL线程。</p><p>I/O线程。该线程连接到master机器，master机器上的binlog dump 线程会将binlog的内容发送给该I\O线程，该I/O线程接收到binlog内容后，再将内容写入到本地的relay log；</p><p>Sql线程。该线程读取到I/O线程写入的ralay log。并且根据relay log 的内容对slave数据库做相应的操作。</p><h3 id="1-2-主从复制流程"><a href="#1-2-主从复制流程" class="headerlink" title="1.2 主从复制流程"></a>1.2 主从复制流程</h3><p>分为同步复制和异步复制，实际复制架构中大部分为异步复制。 复制的基本过程如下：</p><p><strong>在Master机器</strong>上，<strong>主从同步事件会被写到特殊的log文件</strong>中(binary-log);</p><p>主从同步事件有3种形式:statement、row、mixed。</p><ol><li>statement：会将对数据库操作的<strong>sql语句</strong>写入到binlog中。</li><li>row：会将每一条<strong>数据的变化</strong>写入到binlog中。</li><li>mixed：<strong>statement与row的混合</strong>。Mysql决定什么时候写statement格式的，什么时候写row格式的binlog。</li></ol><p>1）当master上的数据发生改变的时候，该事件(insert、update、delete)变化会按照顺序写入到binlog中。</p><p>2）当slave连接到master的时候，master机器会为slave开启binlog dump线程。当<strong>master 的 binlog发生变化的时候，binlog dump线程会通知slave</strong>。</p><p><strong>在Slave机器</strong>上</p><p>1) Slave上面的<strong>IO进程</strong>连接上Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</p><p>2) Master接收到来自Slave的IO进程的请求后，通过负责复制的IO进程根据请求信息<strong>读取制定日志指定位置之后的日志信息，返回给Slave 的IO进程</strong>。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的<strong>bin-log文件的名称以及bin-log的位置</strong>；  </p><p>3) Slave的IO进程接收到信息后，将接收到的<strong>日志内容依次添加</strong>到Slave端的<strong>relay-log文件的最末端</strong>，并将读取到的Master端的 <strong>bin-log的文件名和位置记录到master-info</strong>文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”；  </p><p>4) Slave的<strong>Sql进程检测到relay-log中新增加了内容后</strong>，会马上<strong>解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容</strong>，并在自身执行。</p><h3 id="1-3-主从复制优点"><a href="#1-3-主从复制优点" class="headerlink" title="1.3 主从复制优点"></a>1.3 主从复制优点</h3><p>主从复制可以实现<strong>数据备份</strong>、<strong>故障转移</strong>、MySQL<strong>集群</strong>、<strong>高可用</strong>、<strong>读写分离</strong></p><ol><li><p>实现服务器负载均衡(读写分离)</p></li><li><p>通过复制实现数据的异地备份(数据备份)</p></li><li><p>提高数据库系统的可用性(故障转移)</p></li></ol><h3 id="1-4-数据不一致问题"><a href="#1-4-数据不一致问题" class="headerlink" title="1.4 数据不一致问题"></a>1.4 数据不一致问题</h3><p>主从同步延迟 导致主库从库数据不一致问题的及解决方案</p><p>具体请参考 <a href="https://www.dgstack.cn/archives/887.html" target="_blank" rel="noopener">https://www.dgstack.cn/archives/887.html</a></p><p>1.忽略错误后，继续同步<br>该方法适用于主从库数据相差不大，或者要求<strong>数据可以不完全统一</strong>的情况，数据要求不严格的情况</p><p>2.强制读主</p><p>使用一个高可用主库提供数据库服务，读和写都落在主库上；采用缓存来提升系统性能</p><p>3.选择性读主</p><p>在缓存中记录哪些数据发生过写请求，来路由读主还是读从</p><h2 id="二、分库分表"><a href="#二、分库分表" class="headerlink" title="二、分库分表"></a>二、分库分表</h2><p>当DB的数据量级到达一个阶段，写入和读取的速度会出现瓶颈，即使是有索引，索引也会变得很大，而且数据库的物理文件会使备份和恢复等操作变的很困难。这个时候由于DB的瓶颈已经严重危害到了业务，最有效的解决方案莫过于DB的分库分表了。</p><p>数据库分布式核心内容无非就是数据切分（Sharding），以及切分后对<strong>数据的定位</strong>、<strong>整合</strong>。数据切分就是将数据分散存储到多个数据库中，使得单一数据库中的数据量变小，通过扩充主机的数量缓解单一数据库的性能问题，从而达到提升数据库操作性能的目的。</p><p>数据切分根据其切分类型，可以分为两种方式：垂直（纵向）切分和水平（横向）切分</p><h3 id="垂直（纵向）切分"><a href="#垂直（纵向）切分" class="headerlink" title="垂直（纵向）切分"></a>垂直（纵向）切分</h3><p>垂直切分常见有<strong>垂直分库和垂直分表</strong>两种。</p><p><strong>垂直分库</strong>就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。与”微服务治理”的做法相似，每个微服务使用单独的一个数据库。</p><ol><li>概念：以 <strong>表</strong>为依据，按照业务归属不同，将不同的 <strong>表</strong>拆分到不同的 <strong>库</strong>中 。</li><li>结果：<ul><li>每个 <strong>库</strong>的 <strong>结构</strong>都不一样；</li><li>每个 <strong>库</strong>的 <strong>数据</strong>也不一样，没有交集；</li><li>所有 <strong>库</strong>的 <strong>并集</strong>是全量数据；</li></ul></li><li>场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。</li><li>分析：到这一步，基本上就可以服务化了。例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。</li></ol><p><strong>垂直分表</strong>是基于数据库中的”列”进行，将不经常用或字段长度较大的字段拆分出去到扩展表中。</p><blockquote><p>在字段很多的情况下（例 如一个大表有100多个字段），通过”大表拆小表”，更便于开发与维护，也能避免跨页问题，MySQL底层是通过数据页存储的，一条记录占用空间过大会导 致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了 磁盘IO，从而提升了数据库性能。</p></blockquote><ol><li>概念：以 <strong>字段</strong>为依据，按照字段的活跃性，将 <strong>表</strong>中字段拆到不同的 <strong>表</strong>（主表和扩展表）中。</li><li>结果：<ul><li>每个 <strong>表</strong>的 <strong>结构</strong>都不一样；</li><li>每个 <strong>表</strong>的 <strong>数据</strong>也不一样，一般来说，每个表的 <strong>字段</strong>至少有一列交集，一般是主键，用于关联数据；</li><li>所有 <strong>表</strong>的 <strong>并集</strong>是全量数据；</li></ul></li><li>场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。</li><li>分析：可以用列表页和详情页来帮助理解。垂直分表的拆分原则是将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表。这样更多的热点数据就能被缓存下来，进而减少了随机读IO。拆了之后，要想获得全部数据就需要关联两个表来取数据。但记住，千万别用join，因为join不仅会增加CPU负担并且会讲两个表耦合在一起（必须在一个数据库实例上）。关联数据，应该在业务Service层做文章，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。</li></ol><h3 id="水平（横向）切分"><a href="#水平（横向）切分" class="headerlink" title="水平（横向）切分"></a>水平（横向）切分</h3><p>当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了。</p><p>水平切分分为<strong>库内分表和分库分表</strong>，是根据表内<strong>数据内在的逻辑关系</strong>，将同一个表按<strong>不同的条件</strong>分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。</p><p><strong>水平分库</strong></p><ol><li>概念：以 <strong>字段</strong>为依据 ，按照一定策略（hash、range等），将一个 <strong>库</strong>中的数据拆分到多个 <strong>库</strong>中。</li><li>结果：<ul><li>每个 <strong>库</strong>的 <strong>结构</strong>都一样；</li><li>每个 <strong>库</strong>的 <strong>数据</strong>都不一样，没有交集；</li><li>所有 <strong>库</strong>的 <strong>并集</strong>是全量数据；</li></ul></li><li>场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。</li><li>分析：库多了，io和cpu的压力自然可以成倍缓解。</li></ol><p><strong>水平分表</strong></p><ol><li>概念：以 <strong>字段</strong>为依据 ，按照一定策略（hash、range等），将一个 <strong>表</strong>中的数据拆分到多个 <strong>表</strong>中。</li><li>结果：<ul><li>每个 <strong>表</strong>的 <strong>结构</strong>都一样；</li><li>每个 <strong>表</strong>的 <strong>数据</strong>都不一样，没有交集；</li><li>所有 <strong>表</strong>的 <strong>并集</strong>是全量数据；</li></ul></li><li>场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。</li><li>分析：表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记进阶篇</title>
      <link href="/2020/05/05/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6Redis%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
      <url>/2020/05/05/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6Redis%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="hofe.work">欢迎来我的个人网站</a>，里面有最新的版本</p><p>上篇篇介绍了下单体Redis的知识，这篇介绍分布式集群下的Redis。</p><p>还未全部完成，遗留集群和异步更新策略还未解决</p></blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><strong>上篇博客解决了以下问题：</strong></p><p>Redis是什么，用在哪？Redis 的缺点？</p><p><strong>Redis常见数据类型</strong></p><ul><li>用在什么场景</li><li>底层数据结构是啥</li><li>Zset底层为什么要用两个数据结构</li></ul><p><strong>Redis的持久化</strong></p><p>说一下 <strong>Redis 的数据淘汰策略</strong></p><p><strong>Redis和MySql的区别？</strong></p><ul><li>redis为什么不能代替mysql?</li><li>redis能存大量的数据呢为什么不能？说到了事务</li></ul><p>Redis和memcached有什么区别？</p><hr><p><strong>这篇博客主要解决以下问题</strong></p><p>Redis的并发竞争问题如何解决？<br>Redis的缓存穿透，缓存雪崩，缓存击穿？怎么解决？<br>怎么保证缓存和数据库数据的一致性？<br>Redis集群！集群是如何判断是否有某个节点挂掉？集群进入fail状态的必要条件？<br>Redis哨兵<br>Redis主从复制和一致性保证！<br>Redis热key问题</p><h2 id="一、redis缓存与数据库一致性"><a href="#一、redis缓存与数据库一致性" class="headerlink" title="一、redis缓存与数据库一致性"></a>一、redis缓存与数据库一致性</h2><p>在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。</p><h3 id="1-1-关于缓存"><a href="#1-1-关于缓存" class="headerlink" title="1.1 关于缓存"></a>1.1 关于缓存</h3><p>加入缓存后，客户端发来的请求一般经过以下步骤</p><p><img src="/" class="lazyload" data-src="https://oscimg.oschina.net/oscnet/fa60658310f220abb9042070915d186b883.jpg"  alt=""></p><p><strong>从缓存中读数据会出现以下情况</strong>：</p><p>读数据的时候首先去缓存里读</p><p>没有读到再去MySQL里读</p><p>读回来之后更新到缓存</p><p>下一次从缓存中获取数据</p><h3 id="1-2-更新操作带来的一致性问题"><a href="#1-2-更新操作带来的一致性问题" class="headerlink" title="1.2 更新操作带来的一致性问题"></a>1.2 更新操作带来的一致性问题</h3><p>写数据的时候会产生数据不一致的问题，无论是先写到Redis里再写MySQL还是先写MySQL再写Redis，这两步写操作不能保证原子性，所以会出现Redis和MySQL里的数据不一致。</p><p>数据库中数据更新了，显然缓存也是要更新的，那么并发场景下该先写数据库还是先更新缓存？</p><h4 id="1-2-1-先更新数据库，然后再删除缓存"><a href="#1-2-1-先更新数据库，然后再删除缓存" class="headerlink" title="1.2.1 先更新数据库，然后再删除缓存"></a>1.2.1 先更新数据库，然后再删除缓存</h4><p>到我们最常用的方案了，但是也会导致一致性问题，不过产生脏数据比较少。</p><p>我们假设有两个请求，请求<strong>A是读</strong>请求，请求<strong>B是写</strong>请求，那么可能会出现下述情形：</p><ul><li><p>请求B更新数据库</p></li><li><p>请求A从缓存中读出旧数据</p></li><li><p>请求B删除缓存</p></li></ul><p>期间只有请求B更新数据库，还没来得及删除缓存这段时间内会有脏数据，导致数据不一致。但是后面更新操作完成后，立马将缓存删除了，在后面的读请求获取到的就是新的数据了。</p><h4 id="1-2-2-先删除缓存，然后再更新数据库"><a href="#1-2-2-先删除缓存，然后再更新数据库" class="headerlink" title="1.2.2 先删除缓存，然后再更新数据库"></a>1.2.2 先删除缓存，然后再更新数据库</h4><p>这个方案的问题很明显，假设现在并发两个请求，一个是写请求A，一个是读请求B，那么可能出现如下的执行序列：</p><ul><li><p>请求A删除缓存</p></li><li><p>请求B读取缓存，发现不存在，从数据库中读取到旧值</p></li><li><p>请求A将新值写入数据库</p></li><li><p>请求B将旧值写入缓存</p></li></ul><p>这样就会导致缓存中存的还是旧值，在<strong>缓存过期之前都无法读到新值</strong>。这个问题在数据库读写分离的情况下会更明显，因为主从同步需要时间，请求B获取到的数据很可能还是旧值，那么写入缓存中的也会是旧值。这样会产生大量<strong>脏数据</strong>。</p><h3 id="1-3-解决方案"><a href="#1-3-解决方案" class="headerlink" title="1.3 解决方案"></a>1.3 解决方案</h3><h4 id="1-3-1-采用延时双删策略"><a href="#1-3-1-采用延时双删策略" class="headerlink" title="1.3.1 采用延时双删策略"></a>1.3.1 采用延时双删策略</h4><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。</p><p>伪代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line"> redis.delKey(key);<span class="comment">// 请求A删除缓存</span></span><br><span class="line">    <span class="comment">// 请求B读取缓存，发现不存在，从数据库中读取到旧值</span></span><br><span class="line"> db.updateData(data);<span class="comment">// 请求A将新值写入数据库</span></span><br><span class="line"> Thread.sleep(<span class="number">500</span>);<span class="comment">// 请求B将旧值写入缓存</span></span><br><span class="line"> redis.delKey(key);<span class="comment">// 删除B写入的旧值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="1-具体步骤"><a href="#1-具体步骤" class="headerlink" title="1.具体步骤"></a>1.具体步骤</h5><ol><li>先删除缓存</li><li>再写数据库</li><li>休眠500毫秒</li><li>再次删除缓存</li></ol><h5 id="2-确定休眠时间"><a href="#2-确定休眠时间" class="headerlink" title="2.确定休眠时间"></a>2.确定休眠时间</h5><p>需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保<strong>读请求结束，写请求可以删除读请求造成的缓存脏数据</strong>。</p><p>当然这种策略还要考虑redis和数据库主从同步的耗时。最后的写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。</p><h5 id="3-设置缓存过期时间"><a href="#3-设置缓存过期时间" class="headerlink" title="3.设置缓存过期时间"></a>3.设置缓存过期时间</h5><p>从理论上来说，给<strong>缓存设置过期时间，是保证最终一致性的解决方案</strong>。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p><h5 id="4-该方案的弊端"><a href="#4-该方案的弊端" class="headerlink" title="4.该方案的弊端"></a>4.该方案的弊端</h5><p>结合<strong>双删策略+缓存超时</strong>设置，这样最差的情况就是在<strong>超时时间内数据存在不一致，而且又增加了写请求的耗时</strong>。</p><h4 id="1-3-2-异步更新缓存-基于订阅binlog的同步机制"><a href="#1-3-2-异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="1.3.2 异步更新缓存(基于订阅binlog的同步机制)"></a>1.3.2 异步更新缓存(基于订阅binlog的同步机制)</h4><h5 id="1-技术整体思路："><a href="#1-技术整体思路：" class="headerlink" title="1.技术整体思路："></a>1.技术整体思路：</h5><p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p><p><strong>1）读Redis</strong>：热数据基本都在Redis</p><p><strong>2）写MySQL</strong>:增删改都是操作MySQL</p><p><strong>3）更新Redis数据</strong>：MySQ的数据操作binlog，来更新到Redis</p><h5 id="2-Redis更新"><a href="#2-Redis更新" class="headerlink" title="2.Redis更新"></a>2.Redis更新</h5><p><strong>1）数据操作主要分为两大块：</strong></p><ul><li>一个是全量(将全部数据一次写入到redis)</li><li>一个是增量（实时更新）</li></ul><p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p><p><strong>2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</strong></p><p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把<strong>binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新</strong>。</p><p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p><p>这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p><p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p><p>看到这里我想大家还有点疑惑，感觉上比延时双删更浪费时间，以及需要等待的更久，并发场景下可行嘛？我的理解是多个线程的读或写操作都放进了队列，这样可以保证写库并且删了缓存之后再执行下一个线程的读操作，通过这种方式保证了操作的原子性，另外只要异步消息处理的足够快，那么是不会有问题的</p><h2 id="二、缓存穿透、击穿与雪崩"><a href="#二、缓存穿透、击穿与雪崩" class="headerlink" title="二、缓存穿透、击穿与雪崩"></a>二、缓存穿透、击穿与雪崩</h2><p>使用缓存的主要目是提升查询速度和减轻数据库压力。而缓存最常见的问题是缓存穿透、击穿和雪崩，在高并发下这三种情况都会有大量请求落到数据库，导致数据库资源占满，引起数据库故障。</p><h3 id="2-1-缓存穿透"><a href="#2-1-缓存穿透" class="headerlink" title="2.1 缓存穿透"></a>2.1 缓存穿透</h3><p>在高并发下，<strong>查询一个缓存和数据库中都不存在的值时</strong>，缓存不会被命中，导致大量请求直接落到数据库上，这会给持久层数据库造成很大的压力。</p><h4 id="2-1-1-解决方案"><a href="#2-1-1-解决方案" class="headerlink" title="2.1.1 解决方案"></a>2.1.1 解决方案</h4><ol><li><p>布隆过滤器</p><p><strong>布隆过滤器是一种数据结构</strong>，用于数据量大的情况下代替hashmap判断某个元素是否存在，<strong>拦截对不存在数据的请求</strong>。</p><p>它是一个bit 向量或者说 bit 数组</p><p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/2785001-07e149c32a2608fa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp"  alt=""></p><p>对于要查找的值，将其用多个不同的hash函数映射到这个bit数组中。如hash1(baidu)=1，hash2(baidu)=4，hash3(baidu)=8，将这些位置的元素置为1</p><p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/2785001-12449becdb038afd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp"  alt=""></p><p>这时，如果查询“ten”是否存在，哈希函数返回了 1、5、8三个值，发现5这个位置没有被置为1，那么这个元素肯定不存在。</p><p>将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p></li><li><p>缓存空对象</p><p>当<strong>存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间</strong>，之后再访问这个数据将会从缓存中获取，保护了后端数据源</p><p>但是这种方法会存在两个问题：</p><ul><li><p>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</p></li><li><p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p></li></ul></li><li><p>在接口层增加校验，比如用户鉴权，参数做校验，不合法的校验直接 return，比如 id 做基础校验，id&lt;=0 直接拦截</p></li></ol><h3 id="2-2-缓存击穿（热点key）"><a href="#2-2-缓存击穿（热点key）" class="headerlink" title="2.2 缓存击穿（热点key）"></a>2.2 缓存击穿（热点key）</h3><p>一个 Key 非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个 Key 在失效的瞬间，持续的大并发直接落到了数据库上，就在这个 Key 的点上击穿了缓存。</p><h4 id="2-2-1-解决方案"><a href="#2-2-1-解决方案" class="headerlink" title="2.2.1 解决方案"></a>2.2.1 解决方案</h4><ul><li>使用锁，单机用synchronized,lock等，分布式用分布式锁。</li><li>缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。</li><li>在value设置一个比过期时间t0小的过期时间值t1，当t1过期的时候，延长t1并做更新缓存操作。</li><li>设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需异步地更新实际缓存</li></ul><h3 id="2-3-缓存雪崩"><a href="#2-3-缓存雪崩" class="headerlink" title="2.3 缓存雪崩"></a>2.3 缓存雪崩</h3><p>在高并发下，大量的缓存key在同一时间失效，导致大量的请求落到数据库上。</p><h4 id="2-2-1-解决方案-1"><a href="#2-2-1-解决方案-1" class="headerlink" title="2.2.1 解决方案"></a>2.2.1 解决方案</h4><ol><li><p>redis高可用</p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是<strong>搭建的集群</strong>。</p></li><li><p>限流降级</p><p>这个解决方案的思想是，在缓存失效后，通过<strong>加锁或者队列来控制读数据库写缓存的线程数量</strong>。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p></li><li><p>数据预热</p><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前<strong>手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</strong>。(批量往 Redis 存数据的时候，把每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。)</p></li></ol><h2 id="三、复制"><a href="#三、复制" class="headerlink" title="三、复制"></a>三、复制</h2><h3 id="3-1-主从复制"><a href="#3-1-主从复制" class="headerlink" title="3.1 主从复制"></a>3.1 主从复制</h3><p> 一个Redis服务可以有多个该服务的复制品，这个Redis服务称为Master，其它复制称为Slaves</p><p>主库只负责写数据，每次有数据更新都将更新的数据同步到它所有的从库，而从库只负责读数据。这样一来，就有了两个好处：</p><ol><li><p>读写分离，不仅可以<strong>提高</strong>服务器的<strong>负载能力</strong>，并且可以根据读请求的<strong>规模</strong>自由增加或者减少从库的数量。</p></li><li><p>容灾恢复，数据被复制成了了好几份，就算有一台机器出现<strong>故障</strong>，也可以使用其他机器的数据<strong>快速恢复</strong>。</p></li></ol><p>Redis的主从结构可以采用一主多从或者级联结构，Redis主从复制可以根据是否是全量分为全量同步和增量同步。下图为级联结构。 </p><p><img src="/" class="lazyload" data-src="https://images2018.cnblogs.com/blog/907596/201807/907596-20180710175627988-299575978.png"  alt=""></p><h4 id="3-1-1-全量复制"><a href="#3-1-1-全量复制" class="headerlink" title="3.1.1 全量复制"></a>3.1.1 全量复制</h4><p>Redis全量复制一般发生在<strong>Slave初始化</strong>阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： </p><ol><li><p>从服务器连接主服务器，<strong>发送SYNC命令</strong>； </p></li><li><p>主服务器接收到SYNC命名后，开始<strong>执行BGSAVE命令生成RDB</strong>文件并使用<strong>缓冲区记录</strong>此后执行的所有<strong>写命令</strong>； </p></li><li><p>主服务器BGSAVE执行完后，<strong>向所有从服务器发送快照文件</strong>，并在发送期间<strong>继续记录</strong>被执行的写命令； </p></li><li><p>从服务器收到<strong>快照文件后丢弃所有旧数据，载入收到的快照</strong>； </p></li><li><p>主服务器快照发送完毕后开始<strong>向从服务器发送缓冲区中的写命令</strong>；  </p></li><li><p>从服务器<strong>完成对快照的载入</strong>，开始接收命令请求，并<strong>执行来自主服务器缓冲区的写命令</strong>；</p></li></ol><p><img src="/" class="lazyload" data-src="https://images2018.cnblogs.com/blog/907596/201807/907596-20180710175736785-1172070242.png"  alt=""></p><p>完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。</p><h4 id="3-1-2-增量复制"><a href="#3-1-2-增量复制" class="headerlink" title="3.1.2 增量复制"></a>3.1.2 增量复制</h4><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。<br>增量复制的过程主要是<strong>主服务器每执行一个写命令就会向从服务器发送相同的写命令</strong>，从服务器接收并执行收到的写命令。</p><h3 id="3-2-Redis主从同步策略"><a href="#3-2-Redis主从同步策略" class="headerlink" title="3.2 Redis主从同步策略"></a>3.2 Redis主从同步策略</h3><p>主从刚<strong>刚连接</strong>的时候，进行<strong>全量</strong>同步；<strong>全量同步结束后，进行增量同步</strong>。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p><p><strong>注意</strong></p><p>从Redis 2.8开始，如果遭遇连接断开，重新连接之后可以从中断处继续进行复制，而不必重新同步。</p><p>部分同步的实现依赖于在master服务器内存中给每个slave服务器维护了一份<strong>同步日志offest和同步标识</strong>，每个slave服务器在跟master服务器进行同步时都会<strong>携带自己的同步标识和上次同步的最后位置offest</strong>。当主从连接断掉之后，slave服务器隔断时间内（默认1s）主动尝试和master服务器进行连接，如果从服务器携带的偏移量标识还在master服务器上的同步备份日志中，那么就从slave发送的偏移量开始继续上次的同步操作，如果slave发送的偏移量已经不再master的同步备份日志中（可能由于主从之间断掉的时间比较长或者在断掉的短暂时间内master服务器接收到大量的写操作），则必须进行一次全量更新。在部分同步过程中，master会将本地记录的同步备份日志中记录的指令依次发送给slave服务器从而达到数据一致。</p><h3 id="3-3-Redis主从复制特点"><a href="#3-3-Redis主从复制特点" class="headerlink" title="3.3 Redis主从复制特点"></a>3.3 Redis主从复制特点</h3><ol><li>采用异步复制；</li><li>一个主redis可以含有多个从redis；每个从redis可以接收来自其他从redis服务器的连接；</li><li>主从复制对于主redis服务器来说是非阻塞的，这意味着当从服务器在进行主从复制同步过程中，主redis仍然可以处理外界的访问请求；</li><li>主从复制对于从redis服务器来说也是非阻塞的，这意味着，即使从redis在进行主从复制过程中也可以接受外界的查询请求，只不过这时候从redis返回的是以前老的数据，如果你不想这样，那么在启动redis时，可以在配置文件中进行设置，那么从redis在复制同步过程中来自外界的查询请求都会返回错误给客户端；</li><li>主从复制提高了redis服务的扩展性，避免单个redis服务器的读写访问压力过大的问题，同时也可以给为数据备份及冗余提供一种解决方案；</li></ol><h2 id="四、Sentinel"><a href="#四、Sentinel" class="headerlink" title="四、Sentinel"></a>四、Sentinel</h2><h4 id="4-1-哨兵模式–Redis提供的高可用方案"><a href="#4-1-哨兵模式–Redis提供的高可用方案" class="headerlink" title="4.1 哨兵模式–Redis提供的高可用方案"></a>4.1 哨兵模式–Redis提供的高可用方案</h4><p>主从模式的弊端就是不具备高可用性，当master挂掉以后，Redis将不能再对外提供写入操作，因此sentinel应运而生。sentinel中文含义为哨兵，它的作用就是监控redis集群的运行状况。有多个sentinel实例组成的sentinel系统可以监视多个主服务器以及下属的从服务器，并在主服务器挂掉之后，升级从服务器为主服务器，由新的主服务器代替已下线的主服务器继续处理命令请求。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200505161654.png"  alt=""></p><p><strong>工作机制</strong>：</p><ul><li>每个sentinel以<strong>每秒钟一次</strong>的频率向它所知的master，slave以及其他sentinel实例发送一个 <strong>PING 命令</strong> </li><li>如果一个<strong>实例</strong>距离最后一次有效回复 PING 命令的时间<strong>超过 down-after-milliseconds</strong> 选项所指定的值， 则这个实例会被sentinel标记为<strong>主观下线</strong>。 </li><li>如果一个master被标记为主观下线，则正在监<strong>视这个master的所有sentinel</strong>要以每秒一次的频率确认master的确进入了主观下线状态</li><li>当有<strong>足够</strong>数量的<strong>sentinel</strong>（大于等于配置文件指定的值）在指定的时间范围内<strong>确认master的确进入了主观下线</strong>状态， 则master会被标记为<strong>客观下线</strong> </li><li>在一般情况下， 每个sentinel会以每 <strong>10 秒一次</strong>的频率向它已知的所有master，slave发送 <strong>INFO 命令</strong> </li><li>当master被sentinel标记为<strong>客观下线</strong>时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 <strong>10 秒一次改为 1 秒一次</strong> </li><li>若<strong>没有足够</strong>数量的sentinel同意master已经下线，master的<strong>客观下线状态就会被移除</strong>；</li><li>若master重新向sentinel的 PING 命令返回有效回复，master的主观下线状态就会被移除</li></ul><p>当使用sentinel模式的时候，客户端就不要直接连接Redis，而是连接sentinel的ip和port，由sentinel来提供具体的可提供服务的Redis实现，这样当master节点挂掉以后，sentinel就会感知并将新的master节点提供给使用者。</p><p><strong>特点</strong>：</p><ul><li>sentinel模式是<strong>建立在主从模式的基础上</strong>，如果只有一个Redis节点，sentinel就没有任何意义</li><li>当<strong>master挂了以后，sentinel会在slave中选择一个做为master</strong>，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master</li><li>当<strong>master重新启动后，它将不再是master而是做为slave</strong>接收新的master的同步数据</li><li>sentinel因为也是一个进程有挂掉的可能，所以<strong>sentinel也会启动多个形成一个sentinel集群</strong></li><li><strong>多sentinel配置的时候，sentinel之间也会自动监控</strong></li><li>当主从模式配置密码时，sentinel也会同步将配置信息修改到配置文件中，不需要担心</li><li>一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis</li><li>sentinel最好不要和Redis部署在同一台机器，不然Redis的服务器挂了以后，sentinel也挂了</li></ul><p><strong>缺点</strong>：</p><p>sentinel模式基本可以满足一般生产的需求，具备高可用性。但无法满足数据量大的场景。</p><h2 id="五、集群"><a href="#五、集群" class="headerlink" title="五、集群"></a>五、集群</h2><h3 id="5-1-分布式数据库方案"><a href="#5-1-分布式数据库方案" class="headerlink" title="5.1 分布式数据库方案"></a>5.1 分布式数据库方案</h3><p>所谓的集群，就是通过添加服务器的数量，提供相同的服务，从而让服务器达到一个稳定、高效的状态。集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。</p><blockquote><p>可参考：<a href="https://www.jianshu.com/p/161e66611fe9" target="_blank" rel="noopener">https://www.jianshu.com/p/161e66611fe9</a></p></blockquote><h3 id="5-3-集群模式"><a href="#5-3-集群模式" class="headerlink" title="5.3 集群模式"></a>5.3 集群模式</h3><h4 id="5-3-1-主从模式"><a href="#5-3-1-主从模式" class="headerlink" title="5.3.1 主从模式"></a>5.3.1 主从模式</h4><p>在主从复制中，数据库分为两类：主数据库(master)和从数据库(slave)</p><p><strong>工作机制</strong>：</p><p>当slave启动后，主动向master发送SYNC命令。</p><p>master接收到SYNC命令后在后台保存快照（RDB持久化）和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。</p><p>slave接收到快照文件和命令后加载快照文件和缓存的执行命令。</p><p>复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性</p><p><strong>主从复制特点</strong>：</p><ul><li><p>主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库</p></li><li><p>从数据库一般都是只读的，并且接收主数据库同步过来的数据</p></li><li><p>一个master可以拥有多个slave，但是一个slave只能对应一个master</p></li><li><p>slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来</p></li><li><p>master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务</p></li><li><p>master挂了以后，不会在slave节点中重新选一个master</p></li></ul><p><strong>缺点</strong>：</p><p>从上面可以看出，master节点在主从模式中唯一，<strong>若master挂掉，则redis无法对外提供写服务</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法题目总结</title>
      <link href="/2020/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>1、买卖股票最大收益</p><blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><p>示例：</p><blockquote><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; min)&#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max = Math.max(max, prices[i] - min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、买卖股票最大收益（可多次买卖）</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener">力扣</a></p><p>题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。</p><p>贪心：对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            profit += Math.max(prices[i] - prices[i-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划：第<code>i</code>天只有两种状态，不持有或持有股票，当天不持有股票的状态可能来自昨天卖出或者昨天也不持有，同理，当天持有股票的状态可能来自昨天买入或者昨天也持有中，取最后一天的不持有股票状态就是问题的解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、最大连续子数组求和</p><p><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">力扣</a></p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> presum[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        presum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = presum[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            presum[i] = presum[i-<span class="number">1</span>] &gt; <span class="number">0</span> ? presum[i-<span class="number">1</span>]+nums[i] : nums[i];</span><br><span class="line">            max = Math.max(presum[i], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以用presum代替presum进行优化，这样好理解写</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈、队列题目总结</title>
      <link href="/2020/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=4&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">包含min函数的栈</a></h3><blockquote><p>用辅助栈保存栈中每个值对应状态下的最小值。</p></blockquote><p>需要注意的是Java的Stack类</p><ul><li>push( num) //入栈</li><li>pop() //栈顶元素出栈</li><li>empty() //判定栈是否为空</li><li>peek() //获取栈顶元素</li><li>search(num) //判端元素num是否在栈中，如果在返回1，不在返回-1</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; minstack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">if</span>(minstack.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            m = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m = minstack.peek();    <span class="comment">// java的stack原来没有top方法而是peek？？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; node)&#123;</span><br><span class="line">            minstack.push(m);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minstack.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minstack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">栈的压入、弹出序列</a></h3><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p></blockquote><p>借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length;i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() == popA[j])&#123;</span><br><span class="line">                <span class="comment">// stack.isEmpty()判断语句需在前</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == popA.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&rp=1&ru=%2Factivity%2Foj&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tPage=1" target="_blank" rel="noopener">两个栈实现队列</a></h3><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p></blockquote><p>用一个辅助栈。当调用pop方法的时候也就是需要栈最底下的数，那就将其上的数都pop到辅助栈中直到空位置，这时候pop辅助栈的最顶上元素即可；push元素需要跟在栈最顶上元素之后，故把辅助栈的元素重新pop回到原栈中，这时候在push进栈中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记基础篇</title>
      <link href="/2020/05/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6Redis%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2020/05/04/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6Redis%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇介绍了下单体Redis的知识，还会再写一篇介绍分布式集群下的Redis。</p><p>参考：<a href="https://blog.nowcoder.net/n/f62aef5a98804489a7e7bd27cfd7b542" target="_blank" rel="noopener">https://blog.nowcoder.net/n/f62aef5a98804489a7e7bd27cfd7b542</a></p><p>​            <a href="https://www.cnblogs.com/ysocean/p/9080942.html" target="_blank" rel="noopener">https://www.cnblogs.com/ysocean/p/9080942.html</a></p></blockquote><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p><strong>这篇博客会解决以下问题：</strong></p><p>Redis是什么，用在哪？Redis 的缺点？</p><p><strong>Redis常见数据类型</strong></p><ul><li>用在什么场景</li><li>底层数据结构是啥</li><li>Zset底层为什么要用两个数据结构</li></ul><p><strong>Redis的持久化</strong></p><p>说一下 <strong>Redis 的数据淘汰策略</strong></p><p><strong>Redis和MySql的区别？</strong></p><ul><li>redis为什么不能代替mysql?</li><li>redis能存大量的数据呢为什么不能？说到了事务</li></ul><p>Redis和memcached有什么区别？</p><hr><p><strong>以下内容放在另外一篇博客</strong></p><p>Redis的并发竞争问题如何解决？<br>Redis的缓存穿透，缓存雪崩，缓存击穿？怎么解决？<br>怎么保证缓存和数据库数据的一致性？<br>Redis集群！集群是如何判断是否有某个节点挂掉？集群进入fail状态的必要条件？<br>Redis哨兵<br>Redis主从复制和一致性保证！<br>Redis热key问题</p><h2 id="一、Redis简介"><a href="#一、Redis简介" class="headerlink" title="一、Redis简介"></a>一、Redis简介</h2><h3 id="1-1-Redis是什么"><a href="#1-1-Redis是什么" class="headerlink" title="1.1 Redis是什么"></a>1.1 Redis是什么</h3><p>Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库，基于内存，可持久化。 它支持符串，哈希，列表，集合等多种数据结构，应用于缓存、消息队列等多种场景。</p><p><strong>Redis 与其他 key - value 缓存产品有以下三个特点</strong>： </p><p>（1）Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 </p><p>（2）Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。 </p><p>（3）Redis 支持数据的备份，即 master-slave 模式的数据备份。 </p><p><strong>Redis 优势</strong> </p><p>（1）性能极高 – Redis 能读的速度是 110000 次/s,写的速度是 81000 次/s 。 </p><p>（2）丰富的数据类型 – Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及Ordered Sets 数据类型操作。 </p><p>（3）原子 – Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC指令包起来。 </p><p>（4）丰富的特性 – Redis 还支持 publish/subscribe, 通知, key 过期等等特性。 </p><p><strong>Redis 与其他 key-value 存储有什么不同？</strong> </p><p>（1）Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p><p>（2）Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p><h3 id="1-2-常见数据类型"><a href="#1-2-常见数据类型" class="headerlink" title="1.2 常见数据类型"></a>1.2 常见数据类型</h3><p>了解下Redis内部内存管理中是如何描述这些不同数据类型的</p><p>首先Redis内部使用一个redisObject对象来表示所有的key和value,redisObject最主要的信息如上图所示：</p><p>type代表一个value对象具体是何种数据类型，</p><p>encoding是不同数据类型在redis内部的存储方式</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506130919.png"  alt=""></p><hr><p>redis支持五种数据类型作为其Value，<strong>redis的Key都是字符串类型</strong>的。Redis支持string（字符串），hash（哈希），list（列表），set（集合）和zset（sorted set有序集合）</p><p><strong>String</strong></p><p>类型是二进制安全的，在传输数据时，保证二进制数据的信息安全，也就是不被篡改、破译等，如果被攻击，能够及时检测出来。</p><ul><li><p>实现方式: <strong>String在redis内部存储默认就是一个字符串</strong>，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</p></li><li><p>应用场景：</p><ol><li>常用于<strong>保存单个字符串或JSON字符串数据</strong></li><li>因String是二进制安全的，可以把<strong>一个图片文件的内容作为字符串来存储</strong></li><li>计数器（常规key-value缓存应用。常规计数: 微博数, 粉丝数）</li><li>INCR等指令本身就具有原子操作的特性，所以我们完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果。实现业务上的统计计数需求。</li></ol></li><li><p>常用命令: set,get,decr,incr,mget 等</p></li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131034.png"  alt=""></p><p><strong>Hash</strong></p><p>类是一个string类型的field和value的映射表，<strong>hash特别适合用于存储对象。</strong>Redis 中每个 hash 可以存储 2^32^ - 1 键值对（40多亿），可以看成具有KEY和VALUE的MAP容器，该类型非常适合于存储值对象的信息， 如：uname,upass,age等</p><ul><li><p>实现方式：</p><p>上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为<code>zipmap</code>,当成员数量增大时会自动转成真正的HashMap,此时encoding为<code>ht</code>。</p></li><li><p>应用场景：</p><ol><li><p>常用于存储一个对象</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131103.png"  alt=""></p></li></ol></li></ul><ul><li>常用命令：hget,hset,hgetall 等</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131148.png"  alt=""></p><p><strong>为什么不用String存对象？</strong></p><p>hash是最接近关系数据库结构的数据类型，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中。<br>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：<br>第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增<strong>加了序列化/反序列化的开销</strong>，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131212.png"  alt=""></p><p>第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户<strong>ID为重复存储，如果存在大量这样的数据，内存还是挺浪费的</strong>。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131241.png"  alt=""></p><p><strong>List</strong></p><p>Redis列表是简单的字符串列表，按照<strong>插入顺序排序</strong>。你可以添加一个元素到列表的头部（左边）或者尾部（右边）一个列表最多可以包含 2^32^ - 1 个元素 (4294967295, 每个列表超过40亿个元素) 类似JAVA中的LinkedList。</p><ul><li><p>实现方式：</p><p>Redis list的实现为一个<strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p></li><li><p>应用场景</p><ol><li>对数据量大的集合数据删减<ul><li>列表数据显示、关注列表、粉丝列表、留言评价等…分页、热点新闻（Top5)等</li><li>利用LRANGE还可以很方便的实现分页的功能，在博客系统中，每片博文的评论也可以存入一个单独的list中。</li></ul></li><li>任务队列<ul><li>list通常用来实现一个消息队列，而且可以确保先后顺序。</li></ul></li></ol></li><li><p>常用命令：lpush,rpush,lpop,rpop,lrange等。</p></li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131308.png"  alt=""></p><p><strong>Set</strong></p><p>Redis 的 <strong>Set 是 String 类型的无序集合。</strong> <strong>集合成员是唯一的，这就意味着集合中不能出现重复的数据</strong>。Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。集合中最大的成员数为 2^32^ - 1 。<strong>类似于JAVA中的 Hashtable集合</strong><br>set的底层存储结构使用了intset和hashtable两种数据结构存储的，intset我们可以理解为数组，hashtable就是普通的哈希表（key为set的值，value为null）。<br>intset内部其实是一个数组（int8_t coentents[]数组），存储数据的时候是有序的，因为在查找数据的时候是通过二分查找来实现的。</p><ul><li><p>实现方式：</p><p>set 的内部实现是一个 <strong>value永远为null的HashMap</strong>，实际就是通过<strong>计算hash的方式来快速排重</strong>的，这也是set能提供判断一个成员是否在集合内的原因。</p></li><li><p>应用场景</p><ol><li>对两个集合间的数据计算进行交集、并集、差集运算</li><li>以非常方便的实现如共同关注、共同喜好、二度好友等功能。</li><li><strong>利用唯一性，可以统计访问网站的所有独立 IP</strong></li></ol></li><li><p>常用命令：sadd,spop,smembers,sunion 等</p></li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131332.png"  alt=""></p><p><strong>Zset有序集合(sorted set)</strong> </p><p>1、 Redis 有序集合和集合一样也是string类型元素的集合,且<strong>不允许重复的成员</strong>。<br>2、不同的是<strong>每个元素都会关联一个double类型的分数</strong>。redis正是通过分数来为集合中的成员进行从小到大的排序。<br>3、Redis的ZSet是有序、且不重复</p><ul><li><p>实现方式：</p><p>Redis sorted set的内部使用<strong>HashMap</strong>和<strong>跳跃表(SkipList)</strong>来保证数据的存储和有序，HashMap里放的是成员到score的映射，而<strong>跳跃表里存放的是所有的成员</strong>，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p></li><li><p>应用场景</p><ol><li>排行榜：成绩排行</li><li>带权重的队列，让重要的任务优先执行。</li></ol></li><li><p>常用命令：zadd,zrange,zrem,zcard等</p></li></ul><h2 id="二、底层数据结构"><a href="#二、底层数据结构" class="headerlink" title="二、底层数据结构"></a>二、底层数据结构</h2><p>参考<a href="https://segmentfault.com/a/1190000020770894?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020770894?utm_source=tag-newest</a></p><h3 id="2-1-简单动态字符串（SDS）"><a href="#2-1-简单动态字符串（SDS）" class="headerlink" title="2.1 简单动态字符串（SDS）"></a>2.1 简单动态字符串（SDS）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//等于 SDS 保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">//记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131410.png"  alt=""></p><p><strong>不使用C语言字符串实现，而是使用 SDS的好处</strong></p><ol><li><p><strong>常数复杂度获取字符串长度</strong></p><p>由于 len 属性的存在，我们<strong>获取 SDS 字符串的长度只需要读取 len 属性</strong>，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过<code>strlen key</code> 命令可以获取 key 的字符串长度。</p></li><li><p><strong>杜绝缓冲区溢出</strong></p><p>我们知道在 C 语言中使用 strcat 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 <strong>len 属性检查内存空间是否满足需求</strong>，如果不满足，会进行<strong>相应的空间扩展</strong>，然后在进行修改操作，所以不会出现缓冲区溢出。</p></li><li><p><strong>减少修改字符串的内存重新分配次数</strong></p><p>C语言由于不记录字符串的长度，所以如果要修改字符串，必须要<strong>重新分配内存（先释放再申请）</strong>，因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p><p>而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了<strong>空间预分配和惰性空间释放</strong>两种策略：</p><ol><li>空间预分配：对字符串进行空间扩展的时候，<strong>扩展的内存比实际需要的多</strong>，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li><li>惰性空间释放：对字符串进行缩短操作时，程序<strong>不立即使用内存重新分配来回收缩短后多余的字节</strong>，而是使用 <strong>free 属性将这些字节的数量记录下来</strong>，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</li></ol></li><li><p><strong>二进制安全</strong></p></li></ol><p>　　因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），<strong>内容可能包括空字符串，因此C字符串无法正确存取</strong>；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS <strong>不是以空字符串来判断是否结束</strong>，而是以 len 属性表示的长度来判断字符串是否结束。</p><ol start="5"><li><strong>兼容部分 C 字符串函数</strong></li></ol><p>　　虽然 SDS 是二进制安全的，但是一样<strong>遵从每个字符串都是以空字符串结尾的惯例</strong>，这样可以重用 C 语言库&lt;string.h&gt; 中的一部分函数。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131429.png"  alt=""></p><h3 id="2-2-双端链表"><a href="#2-2-双端链表" class="headerlink" title="2.2 双端链表"></a>2.2 双端链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">       <span class="comment">//前置节点</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">       <span class="comment">//后置节点</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">       <span class="comment">//节点的值</span></span><br><span class="line">       <span class="keyword">void</span> *value;  </span><br><span class="line">&#125;listNode</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">     <span class="comment">//表头节点</span></span><br><span class="line">     listNode *head;</span><br><span class="line">     <span class="comment">//表尾节点</span></span><br><span class="line">     listNode *tail;</span><br><span class="line">     <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">     <span class="comment">//节点值复制函数</span></span><br><span class="line">     <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值释放函数</span></span><br><span class="line">     <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值对比函数</span></span><br><span class="line">     <span class="keyword">int</span> (*match) (<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131448.png"  alt=""></p><p>Redis链表特性：</p><ol><li><p>双端：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。</p></li><li><p>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。　　</p></li><li><p>带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O(1)。</p></li><li><p>多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值</p></li></ol><h3 id="2-3-字典"><a href="#2-3-字典" class="headerlink" title="2.3 字典"></a>2.3 字典</h3><p>字典又称为符号表或者关联数组、或映射（map），是一种用于<strong>保存键值对的抽象数据结构</strong>。字典中的每一个键 key 都是唯一的，通过 key 可以对值来进行查找或修改。C 语言中没有内置这种数据结构的实现，所以字典依然是 Redis自己构建的。</p><p>Redis 的字典使用<strong>哈希表作为底层实现</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">     <span class="comment">//哈希表数组</span></span><br><span class="line">     dictEntry **table;</span><br><span class="line">     <span class="comment">//哈希表大小</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">     <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">     <span class="comment">//总是等于 size-1</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">     <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"> </span><br><span class="line">&#125;dictht</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">     <span class="comment">//键</span></span><br><span class="line">     <span class="keyword">void</span> *key;</span><br><span class="line">     <span class="comment">//值</span></span><br><span class="line">     <span class="keyword">union</span>&#123;</span><br><span class="line">          <span class="keyword">void</span> *val;</span><br><span class="line">          uint64_tu64;</span><br><span class="line">          int64_ts64;</span><br><span class="line">     &#125;v;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//指向下一个哈希表节点，形成链表</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry</span><br></pre></td></tr></table></figure><p>哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来解决<strong>哈希冲突</strong>。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131506.png"  alt=""></p><h3 id="2-4-跳跃表"><a href="#2-4-跳跃表" class="headerlink" title="2.4 跳跃表"></a>2.4 跳跃表</h3><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。具有如下性质：</p><ol><li><p>由很多层结构组成；</p></li><li><p>每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；</p></li><li><p>最底层的链表包含了所有的元素；</p></li><li><p>如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；</p></li><li><p>链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；</p></li></ol><p>　　<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131527.png"  alt="img"></p><p>　　Redis中跳跃表节点定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">     <span class="comment">//层</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">           <span class="comment">//前进指针</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">           <span class="comment">//跨度</span></span><br><span class="line">           <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">     &#125;level[];</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//后退指针</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">     <span class="comment">//分值</span></span><br><span class="line">     <span class="keyword">double</span> score;</span><br><span class="line">     <span class="comment">//成员对象</span></span><br><span class="line">     robj *obj;</span><br><span class="line"> </span><br><span class="line">&#125; zskiplistNode</span><br></pre></td></tr></table></figure><p>多个跳跃表节点构成一个跳跃表：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">     <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">     structz skiplistNode *header, *tail;</span><br><span class="line">     <span class="comment">//表中节点的数量</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">     <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">     <span class="keyword">int</span> level;</span><br><span class="line"> </span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure><p>　　<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131550.png"  alt="img"></p><p>　　①、搜索：从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。</p><p>　　②、插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数k后，则需要将新元素插入到从底层到k层。</p><p>　　③、删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。</p><h3 id="2-5-整数集合"><a href="#2-5-整数集合" class="headerlink" title="2.5 整数集合"></a>2.5 整数集合</h3><p>整数集合（<code>intset</code>）是Redis用于保存整数值的集合抽象数据类型，它可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素。</p><p>定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">     <span class="comment">//编码方式</span></span><br><span class="line">     <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">     <span class="comment">//集合包含的元素数量</span></span><br><span class="line">     <span class="keyword">uint32_t</span> length;</span><br><span class="line">     <span class="comment">//保存元素的数组</span></span><br><span class="line">     <span class="keyword">int8_t</span> contents[];</span><br><span class="line"> </span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure><p>整数集合的每个元素都是 contents 数组的一个数据项，它们按照从小到大的顺序排列，并且不包含任何重复项。</p><p>length 属性记录了 contents 数组的大小。</p><p>需要注意的是虽然 contents 数组声明为 int8_t 类型，但是实际上contents 数组并不保存任何 int8_t 类型的值，其真正类型有 encoding 来决定。</p><p><strong>升级</strong></p><p>当我们新增的元素类型比原集合元素类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中。具体步骤：</p><ol><li><p>根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。</p></li><li><p>将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的。</p></li><li><p>将新元素添加到整数集合中（保证有序）。</p></li></ol><p>　　升级能极大地节省内存。</p><p><strong>降级</strong></p><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p><h3 id="2-6-压缩列表"><a href="#2-6-压缩列表" class="headerlink" title="2.6 压缩列表"></a>2.6 压缩列表</h3><p>压缩列表（<code>ziplist</code>）是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><p><strong>压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。</strong></p><p>　　<img src="/" class="lazyload" data-src="https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180528215852732-1088896020.png"  alt="img"></p><p>压缩列表的每个节点构成如下：</p><p>　　<img src="/" class="lazyload" data-src="https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180528223605060-899108663.png"  alt="img"></p><ul><li><p>previous_entry_ength：记录压缩列表前一个字节的长度。previous_entry_ength的长度可能是1个字节或者是5个字节，如果上一个节点的长度小于254，则该节点只需要一个字节就可以表示前一个节点的长度了，如果前一个节点的长度大于等于254，则previous length的第一个字节为254，后面用四个字节表示当前节点前一个节点的长度。利用此原理即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置，压缩列表可以从尾部向头部遍历。这么做很有效地减少了内存的浪费。</p></li><li><p>encoding：节点的encoding保存的是节点的content的内容类型以及长度，encoding类型一共有两种，一种字节数组一种是整数，encoding区域长度为1字节、2字节或者5字节长。</p></li><li><p>content：content区域用于保存节点的内容，节点内容类型和长度由encoding决定。</p></li></ul><h2 id="三、持久化机制"><a href="#三、持久化机制" class="headerlink" title="三、持久化机制"></a>三、持久化机制</h2><p>数据保存在内存中，高效但也容易发生丢失。于是需要一种持久化的机制，Redis提供了RDB(Redis DataBase)和AOF(Append Only File)。</p><h3 id="3-1-数据持久化的过程"><a href="#3-1-数据持久化的过程" class="headerlink" title="3.1 数据持久化的过程"></a>3.1 数据持久化的过程</h3><p>（1）客户端向服务端发送写操作(数据在客户端的内存中)。</p><p>（2）数据库服务端接收到写请求的数据(数据在服务端的内存中)。</p><p>（3）服务端调用write方法，将数据从系统内存的缓冲区往磁盘缓存中写。</p><p>（4）磁盘控制器将数据写到磁盘的物理介质中(数据真正落到磁盘上)。</p><h3 id="3-2-RDB"><a href="#3-2-RDB" class="headerlink" title="3.2 RDB"></a>3.2 RDB</h3><p>RDB持久化是指在<strong>指定的时间间隔内将内存中的数据集快照写入磁盘</strong>。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。</p><p>既然RDB机制是通过把某个时刻的所有数据生成一个快照来保存，那么就应该有一种触发机制，是实现这个过程。对于RDB来说，提供了三种机制：save、bgsave、自动化</p><h4 id="3-2-1-save触发方式"><a href="#3-2-1-save触发方式" class="headerlink" title="3.2.1 save触发方式"></a>3.2.1 save触发方式</h4><p>该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。具体流程如下：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131654.png"  alt=""></p><p>执行完成时候如果存在老的RDB文件，就把新的替代掉旧的。我们的客户端可能都是几万或者是几十万，这种方式显然不可取。</p><h4 id="3-2-2-bgsave触发方式"><a href="#3-2-2-bgsave触发方式" class="headerlink" title="3.2.2 bgsave触发方式"></a>3.2.2 bgsave触发方式</h4><p>执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体流程如下：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131709.png"  alt=""></p><p>具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</p><h4 id="3-2-3-save与bgsave对比"><a href="#3-2-3-save与bgsave对比" class="headerlink" title="3.2.3 save与bgsave对比"></a>3.2.3 save与bgsave对比</h4><p>我们可以修改这些配置来实现我们想要的效果。因为第三种方式是配置的，所以我们对前两种进行一个对比：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131731.png"  alt="img"></p><h4 id="3-2-4-自动触发"><a href="#3-2-4-自动触发" class="headerlink" title="3.2.4 自动触发"></a>3.2.4 自动触发</h4><p>自动触发是在配置文件中配置bgsave相关操作，比如触发条件、失败停止写入等来完成的。</p><p>在redis.conf配置文件中，可以设置：</p><p><strong>①save：</strong>这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“<code>save m n</code>”。<strong>表示m秒内数据集存在n次修改时，自动触发</strong><code>bgsave</code>。</p><p>不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。</p><p><strong>②stop-writes-on-bgsave-error ：</strong>默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</p><p><strong>③rdbcompression ；</strong>默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。</p><p><strong>④rdbchecksum ：</strong>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p><p><strong>⑤dbfilename ：</strong>设置快照的文件名，默认是 dump.rdb</p><p><strong>⑥dir：</strong>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。</p><h4 id="3-2-5-RDB-的优势和劣势"><a href="#3-2-5-RDB-的优势和劣势" class="headerlink" title="3.2.5 RDB 的优势和劣势"></a>3.2.5 RDB 的优势和劣势</h4><ul><li>优势</li></ul><p>（1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</p><p>（2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p><p>（3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p><ul><li>劣势</li></ul><p>当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父<strong>进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据</strong>。</p><h3 id="3-3-AOF"><a href="#3-3-AOF" class="headerlink" title="3.3 AOF"></a>3.3 AOF</h3><p>全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的<strong>写命令都通过write函数追加到文件</strong>中。通俗的理解就是<strong>日志记录</strong>。</p><h4 id="3-3-1-持久化原理"><a href="#3-3-1-持久化原理" class="headerlink" title="3.3.1 持久化原理"></a>3.3.1 持久化原理</h4><p>他的原理看下面这张图：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131750.png"  alt="img"></p><p>每当有一个写命令过来时，就直接保存在我们的AOF文件中。</p><h4 id="3-3-2-文件重写原理"><a href="#3-3-2-文件重写原理" class="headerlink" title="3.3.2 文件重写原理"></a>3.3.2 文件重写原理</h4><p>AOF的方式也同时带来了另一个问题。<strong>持久化文件会变的越来越大。为了压缩aof的持久化文件</strong>。redis提供了<code>bgrewriteaof</code>命令。<strong>将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写</strong>。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131808.png"  alt="img"></p><p>重写aof文件的操作，并没有读取旧的aof文件，而是<strong>将整个内存中的数据库内容用命令的方式重写了一个新的aof文件</strong>，这点和快照有点类似。</p><h4 id="3-3-3-AOF也有三种触发机制"><a href="#3-3-3-AOF也有三种触发机制" class="headerlink" title="3.3.3 AOF也有三种触发机制"></a>3.3.3 AOF也有三种触发机制</h4><p>（1）always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好</p><p>（2）everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</p><p>（3）no：从不同步</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131826.png"  alt="img"></p><h4 id="3-3-4-优点"><a href="#3-3-4-优点" class="headerlink" title="3.3.4 优点"></a>3.3.4 优点</h4><p>（1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。</p><p>（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</p><p>（3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p><p>（4）AOF日志文件的命令通过可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p><h4 id="3-3-5-缺点"><a href="#3-3-5-缺点" class="headerlink" title="3.3.5 缺点"></a>3.3.5 缺点</h4><p>（1）对于同一份数据来说，<strong>AOF日志文件通常比RDB数据快照文件更大</strong></p><p>（2）<strong>AOF开启后，支持的写QPS会比RDB支持的写QPS低</strong>，<strong>因为AOF一般会配置成每秒fsync一次日志文件</strong>，当然，每秒一次fsync，性能也还是很高的</p><p>（3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。</p><h3 id="3-4-RDB和AOF到底该如何选择"><a href="#3-4-RDB和AOF到底该如何选择" class="headerlink" title="3.4 RDB和AOF到底该如何选择"></a>3.4 RDB和AOF到底该如何选择</h3><p>选择的话，两者加一起才更好。因为两个持久化机制你明白了，剩下的就是看自己的需求了，需求不同选择的也不一定，但是通常都是结合使用。有一张图可供总结：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506131841.png"  alt="img"></p><h2 id="四、数据淘汰策略"><a href="#四、数据淘汰策略" class="headerlink" title="四、数据淘汰策略"></a>四、数据淘汰策略</h2><p>减少内存紧张的情况，由此获取更为稳健的服务</p><h3 id="4-1-lru、lfu（redis-4新增）、random、ttl"><a href="#4-1-lru、lfu（redis-4新增）、random、ttl" class="headerlink" title="4.1 lru、lfu（redis 4新增）、random、ttl"></a>4.1 lru、lfu（redis 4新增）、random、ttl</h3><p>LRU：</p><p>（1）<strong>volatile-lru</strong>:从设置了过期时间的数据集中，选择最近最久未使用的数据释放； </p><p>（2）<strong>allkeys-lru</strong>:从数据集中(包括设置过期时间以及未设置过期时间的数据集中)，选择最近最久未使用的数据释放；</p><p>random：</p><p>（3）<strong>volatile-random</strong>:从设置了过期时间的数据集中，随机选择一个数据进行释放；</p><p>（4）<strong>allkeys-random</strong>:从数据集中随机选择一个数据进行释放</p><p>LFU：</p><p>（5）<strong>volatile-lfu</strong>：从设置过期时间的数据集挑选使用<strong>频率最低</strong>的数据淘汰。</p><p>（6）<strong>allkeys-lfu</strong>：从数据集中挑选使用频率最低的数据淘汰。</p><p>（7）<strong>volatile-ttl</strong>：从设置了过期时间的数据集中，选择<strong>马上就要过期的数据</strong>进行释放操作； </p><p>（8）<strong>no-eviction</strong>（默认策略）：不删除任意数据(但redis还会根据引用计数器进行释放),这时如果内存不够时，会直接返回错误。采用no-enviction策略可以保证数据不被丢失</p><h3 id="4-2-淘汰机制的实现"><a href="#4-2-淘汰机制的实现" class="headerlink" title="4.2 淘汰机制的实现"></a>4.2 淘汰机制的实现</h3><p><strong>删除失效主键</strong></p><p>既然是淘汰，那就需要把这些数据给删除，然后保存新的。Redis 删除失效键的方法主要有两种：</p><p>（1）消极方法（passive way），在主键被<strong>访问时如果发现它已经失效，那么就删除</strong>它。redis在实现GET、MGET、HGET、LRANGE等所有涉及到读取数据的命令时<strong>都会调用 expireIfNeeded</strong>，它存在的意义就是在读取数据之前先检查一下它有没有失效，如果失效了就删除它。</p><p>（2）积极方法（active way），<strong>周期性地探测，发现失效就删除</strong>。消极方法的缺点是，如果key 迟迟不被访问，就会占用很多内存空间，所以才有积极方式。</p><p>（3）主动删除：当内存超过maxmemory限定时，触发主动清理策略，该策略由启动参数的配置决定</p><h3 id="4-3-淘汰数据的量"><a href="#4-3-淘汰数据的量" class="headerlink" title="4.3 淘汰数据的量"></a>4.3 淘汰数据的量</h3><p>既然是淘汰数据，那么淘汰多少合适呢？</p><p>为了避免频繁的触发淘汰策略，每次会淘汰掉一批数据，<strong>淘汰的数据的大小其实是和置换的大小来确定的</strong>，如果置换的数据量大，淘汰的肯定也多。</p><h3 id="4-4-置换策略是如何工作"><a href="#4-4-置换策略是如何工作" class="headerlink" title="4.4 置换策略是如何工作"></a>4.4 置换策略是如何工作</h3><p>理解置换策略的执行方式是非常重要的，比如：</p><p>（1）客户端执行一条新命令，导致数据库需要增加数据（比如set key value）</p><p>（2）Redis会检查内存使用，如果内存使用超过maxmemory，就会按照置换策略删除一些key</p><p>（3）新的命令执行成功</p><h2 id="五、Mutil"><a href="#五、Mutil" class="headerlink" title="五、Mutil"></a>五、Mutil</h2><h3 id="5-1-redis事务特性"><a href="#5-1-redis事务特性" class="headerlink" title="5.1 redis事务特性"></a>5.1 redis事务特性</h3><p>我并没有把mutil称为事务，我更倾向于称作Redis的多任务命令。</p><p>事务需要具备ACID四个特性，redis提供的并不是严格的事务</p><p><strong>不保证原子性</strong></p><p>若在<code>待执行队列</code>中存在语法性错误,<code>exec</code>提交之后,其他正确命令也会被执行,这是单单的错误命令抛出异常。</p><p>Redis 开始事务 multi 命令后，Redis 会为这个事务生成一个队列，每次操作的命令都会按照顺序插入到这个队列中。</p><p><img src="/" class="lazyload" data-src="http://5b0988e595225.cdn.sohucs.com/images/20190706/6b4e27a6cb20487ba40eccddf18c60db.jpeg"  alt=""></p><p>这个队列里面的命令不会被马上执行，直到 exec 命令提交事务，所有队列里面的命令会被一次性，并且排他的进行执行。</p><p>但原子性有一个特点就是要么全部成功，要么全部失败，也就是我们传统 DB 里面说的回滚。</p><p><img src="/" class="lazyload" data-src="http://5b0988e595225.cdn.sohucs.com/images/20190706/4c110eeb82394054bbe77922027cec5c.jpeg"  alt=""></p><p>可以发现，就算中间出现了失败，set abc x 这个操作也已经被执行了，并没有进行回滚，从严格的意义上来说 Redis <strong>并不具备原子性</strong>。</p><p><strong>没有隔离级别的概念</strong></p><p>开启事务之后的操作全部是在<code>待执行队列</code>中缓存,并没有真正执行,也就不存在事务内部的查询要看到事务即将的更新,事务外部也不知道</p><h3 id="5-2-watch操作"><a href="#5-2-watch操作" class="headerlink" title="5.2 watch操作"></a>5.2 watch操作</h3><p>语法:<code>watch key</code><br>watch类似于乐观锁</p><p>如果在<code>watch</code>命令观测一个<code>key</code>之后,开启事务后修改该<code>key</code>.这个时候如果有其它连接修改了<code>key</code>,则会导致事务执行失败,在这个事务的其他操作也是失败<br><code>exec</code>之后,<code>watch</code>命令监控取消</p><p>在使用了<code>watch</code>之后可以保证一定的原子性和数据安全</p><h2 id="六、Redis-发布订阅"><a href="#六、Redis-发布订阅" class="headerlink" title="六、Redis 发布订阅"></a>六、Redis 发布订阅</h2><p><strong>简介</strong></p><ul><li>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</li><li>Redis 客户端可以订阅任意数量的频道。</li></ul><p><strong>示例</strong></p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="/" class="lazyload" data-src="https://uploadfiles.nowcoder.com/files/20200428/783233862_1588080567330_20200426220057339.png"  alt=""></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时，这个消息就会被发送给订阅它的三个客户端：</p><p><img src="/" class="lazyload" data-src="https://uploadfiles.nowcoder.com/files/20200428/783233862_1588080567668_20200426220222120.png"  alt=""></p><p><strong>应用场景</strong></p><ul><li>这一功能最明显的用法就是构建实时消息系统，比如普通的即时聊天，群聊等功能</li><li>在一个博客网站中，有100个粉丝订阅了你，当你发布新文章，就可以推送消息给粉丝们。</li></ul><h2 id="七、面试题"><a href="#七、面试题" class="headerlink" title="七、面试题"></a>七、面试题</h2><h3 id="7-1-Redis为什么是单线程的？"><a href="#7-1-Redis为什么是单线程的？" class="headerlink" title="7.1 Redis为什么是单线程的？"></a>7.1 Redis为什么是单线程的？</h3><blockquote><p>官方：因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p></blockquote><p>redis 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处理这个事。在内存的情况下，这个方案就是最佳方案 </p><h3 id="7-2-Redis为什么这么快"><a href="#7-2-Redis为什么这么快" class="headerlink" title="7.2 Redis为什么这么快"></a>7.2 Redis为什么这么快</h3><p>官方提供的数据可以达到 100000+ 的 QPS</p><ol><li><p>完全基于内存，<strong>绝大部分请求是纯粹的内存操作，非常快速</strong>。数据存在内存中，<strong>类似于HashMap</strong>，HashMap的优势就是<strong>查找和操作的时间复杂度都是O(1)</strong>；</p></li><li><p>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p></li><li><p><strong>采用单线程，避免了不必要的上下文切换和竞争条件</strong>，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p></li><li><p>使用<strong>多路I/O复用模型，非阻塞IO</strong>，采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求；</p></li><li><p>使用底层模型不同，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p></li></ol><h3 id="7-3-Redis应用场景"><a href="#7-3-Redis应用场景" class="headerlink" title="7.3 Redis应用场景"></a>7.3 Redis应用场景</h3><p>因为Redis的性能十分优越，可以支持每秒十几万次的读/写操作，并且它还支持持久化、集群部署、分布式、主从同步等，Redis在高并发的场景下数据的安全和一致性，所以它经常用于这些场景：</p><ol><li>经常要被查询，但是CUD操作频率低的数据；比如数据字典，确定了之后很少被修改，是可以放到<strong>缓存</strong>中的；还有热点数据，查询极为频繁的数据，放到Redis中可以减少MySQL的压力；</li><li>经常被查询，但是实时性要求不高数据，比如购物网站的<strong>热销排行榜</strong>，定时统计一次后把统计结果放到Redis中提供查询。</li><li>缓存还可以做<strong>数据共享</strong>（Session共享），在分布式的架构中，把用户的Session数据放到Redis中。</li><li>高并发场景下的<strong>计数器</strong>，比如秒杀，把商品库存数量放到Redis中（秒杀的场景会比较复杂，Redis只是其中之一，例如如果请求超过某个数量的时候，多余的请求就会被限流）；</li><li>因为Redis对高并发的支持和单线程机制，它也经常用作<strong>分布式锁</strong>；</li></ol><h3 id="7-4-Redis和MySql的区别？"><a href="#7-4-Redis和MySql的区别？" class="headerlink" title="7.4 Redis和MySql的区别？"></a>7.4 Redis和MySql的区别？</h3><ul><li><p>类型上</p><p>从类型上来说，mysql是关系型数据库，redis是缓存数据库</p></li><li><p>作用上</p><p>mysql用于持久化的存储数据到硬盘，功能强大，但是速度较慢</p><p>redis用于存储使用较为频繁的数据到缓存中，读取速度快</p></li><li><p>需求上</p><p>mysql和redis因为需求的不同，一般都是配合使用。</p></li></ul><h3 id="7-5-redis为什么不能代替mysql"><a href="#7-5-redis为什么不能代替mysql" class="headerlink" title="7.5 redis为什么不能代替mysql?"></a>7.5 redis为什么不能代替mysql?</h3><p>在使用一项技术的时候，不是看它能不能，而是要看它适合不适合；而在大部分场景下，Redis是无法替代MySQL的。</p><ul><li>MySQL是关系型数据库，数据储存在磁盘上，数据的格式是我们熟知的二维表格的样式。关系型数据库具有很多强大的功能；大部分都支持SQL语句查询，对事务也有很好的支持。</li><li>Redis被称作非关系型数据库，属于内存数据库，数据都储存在内存中（Redis有RDB持久化策略），Redis支持的数据类型也比较多，比如字符串，HASH，List等。</li><li>MySQL和Redis没有竞争的关系，通常当并发访问量比较大的时候，特别是读操作很多，架构中可以引入Redis，帮助提升架构的整体性能，减少Mysql(或其他关系型数据库)的压力；</li><li>不是MySQL or Redis；而是MySQL + Redis ；</li></ul><h3 id="7-6-Redis和memcached有什么区别？"><a href="#7-6-Redis和memcached有什么区别？" class="headerlink" title="7.6 Redis和memcached有什么区别？"></a>7.6 Redis和memcached有什么区别？</h3><ol><li><p>性能<br>都比较高，性能对我们来说应该都不是瓶颈<br>总体来讲，TPS方面redis和memcache差不多</p></li><li><p>操作的便利性<br>memcache数据结构单一<br>redis丰富一些，数据操作方面，redis更好一些</p></li><li><p>可靠性（持久化）</p><p>对于数据持久化和数据恢复，</p><p>redis支持（快照、AOF）：依赖快照进行持久化，aof增强了可靠性的同时，对性能有所影响</p><p>memcache不支持，通常用在做缓存,提升性能；</p></li><li><p>数据一致性（事务支持）</p><p>Memcache 在并发场景下，用cas保证一致性</p><p>redis事务支持比较弱，只能保证事务中的每个操作连续执行</p></li></ol><ul><li><strong>存储方式上：</strong>Memcache 会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis 有部分数据存在硬盘上，这样能保证数据的持久性。</li><li><strong>数据支持类型上：</strong>Memcache 对数据类型的支持简单，只支持简单的 key-value，，而 Redis 支持五种数据类型。</li><li><strong>使用底层模型不同：</strong>它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis 直接自己构建了 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li><strong>Value 的大小：</strong>Redis 可以达到 1GB，而 Memcache 只有 1MB。</li></ul><h3 id="7-7-redis为什么不能存大量的数据呢？"><a href="#7-7-redis为什么不能存大量的数据呢？" class="headerlink" title="7.7 redis为什么不能存大量的数据呢？"></a>7.7 redis为什么不能存大量的数据呢？</h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型与GC机制</title>
      <link href="/2020/05/03/Java/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3JVM/"/>
      <url>/2020/05/03/Java/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3JVM/</url>
      
        <content type="html"><![CDATA[<blockquote><p>可访问<a href="http://hhf443.github.io/" target="_blank" rel="noopener">个人网站</a>进行阅读最新版本</p></blockquote><h2 id="一、Java内存区域"><a href="#一、Java内存区域" class="headerlink" title="一、Java内存区域"></a>一、Java内存区域</h2><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020031919163066.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt=""></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200503202546.jpg"  alt=""></p><p>1.程序计数器：程序计数器（Program Counter Register）是一块较小的内存空间，可以看作是<strong>当前线程所执行字节码的行号指示器，指向下一个将要执行的指令代码，由执行引擎来读取下一条指令</strong>。更确切的说，一个线程的执行，是通过字节码解释器改变当前线程的计数器的值，来获取下一条需要执行的字节码指令，从而确保线程的正确执行。每个线程都有一个独立的程序计数器，是线程私有的内存</p><p>2.虚拟机栈：描述<strong>Java方法执行的内存模型</strong>，每个方法在执行的同时都会创建一个<strong>栈帧</strong>（Stack Frame） 用于存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。每一个方法从调用直至执行完成 的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>3.本地方法栈：本地方法栈则<strong>为 JVM 使用到的 Native 方法服务</strong>。Native 方法不是以 Java 语言实现的，而是以本地语言实现的（比如 C 或 C++）。个人理解Native 方法是与操作系统直接交互的。比如通知垃圾收集器进行垃圾回收的代码 System.gc()，就是使用 native 修饰的</p><p>4.堆：堆是Java虚拟机所管理的内存中最大的一块存储区域。堆内存被所有<strong>线程共享</strong>。主要存放使用<strong>new关键字创建的对象</strong>。所有对象实例以及数组都要在堆上分配。<strong>垃圾收集器就是根据GC算法，收集堆上对象所占用的内存空间</strong>（收集的是对象占用的空间而不是对象本身）</p><ul><li><p>Java堆分为年轻代（Young Generation）和老年代（Old Generation）；年轻代又分为伊甸园（Eden）和幸存区（Survivor区）；幸存区又分为From Survivor空间和 To Survivor空间。</p></li><li><p>年轻代存储“新生对象”，我们新创建的对象存储在年轻代中。当年轻内存占满后，会触发Minor GC，清理年轻代内存空间。</p></li><li><p>老年代存储长期存活的对象和大对象。年轻代中存储的对象，经过多次GC后仍然存活的对象会移动到老年代中进行存储。老年代空间占满后，会触发Full GC。</p><p>注：Full GC是清理整个堆空间，包括年轻代和老年代。如果Full GC之后，堆中仍然无法存储对象，就会抛出OutOfMemoryError异常。</p></li></ul><p>5.方法区：方法区同 Java 堆一样是被所有<strong>线程共享</strong>的区间，用于存储已<strong>被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>。更具体的说，静态变量+常量+类信息（版本、方法、字段等）+运行时常量池存在方法区中。常量池是方法区的一部分，<strong>常量池中存储编译器生成的各种字面量和符号引用</strong>。字面量就是Java中常量的意思。比如文本字符串，final修饰的常量等。方法引用则包括类和接口的全限定名，方法名和描述符，字段名和描述符等。</p><ul><li>注：JDK1.8 使用<strong>元空间 MetaSpace 替代方法区</strong>，元空间并不在 JVM中，而是<strong>使用本地内存</strong>。元空间两个参数：<br>MetaSpaceSize：初始化元空间大小，控制发生GC阈值<br>MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存</li></ul><h2 id="二、GC算法"><a href="#二、GC算法" class="headerlink" title="二、GC算法"></a>二、GC算法</h2><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200319201224280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt=""></p><h3 id="2-1-确定垃圾算法"><a href="#2-1-确定垃圾算法" class="headerlink" title="2.1 确定垃圾算法"></a>2.1 确定垃圾算法</h3><h4 id="2-1-1-引用计数法"><a href="#2-1-1-引用计数法" class="headerlink" title="2.1.1 引用计数法"></a>2.1.1 引用计数法</h4><p>在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单 的办法是通过<strong>引用计数来判断一个对象是否可以回收</strong>。简单说，给每个对象一个引用计数器，每当有一个地方引用它时，计数器就会加1；当引用失效时，计数器的值就会减1；任何时刻计数器的值为0的对象就是不可能再被使用的。</p><p>存在<strong>循环引用</strong>问题。</p><h4 id="2-1-2-可达性分析"><a href="#2-1-2-可达性分析" class="headerlink" title="2.1.2 可达性分析"></a>2.1.2 可达性分析</h4><p>通过一系列称为“GC Roots”的对象为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个<strong>对象到GC Roots没有任何引用链相连</strong>（用图论的话来说，就是GC Roots到这个对象不可达）时，则说明<strong>此对象是不可用的。</strong></p><p>要注意的是，不可达对象不等价于可回收对象，<strong>不可达对象变为可回收对象至少要经过两次标记过程</strong>。两次标记后仍然是可回收对象，则将面临回收。</p><ul><li><p>那么那些对象可以作为GC Roots呢？以Java为例，有以下几种：</p><p>1、栈（栈帧中的本地变量表）中引用的对象。</p><p>2、方法区中的静态成员。</p><p>3、方法区中的常量引用的对象（全局变量）。</p><p>4、本地方法栈中JNI（一般说的Native方法）引用的对象。</p><p>注：第一和第四种都是指的方法的本地变量表，第二种表达的意思比较清晰，第三种主要指的是声明为final的常量值。</p></li></ul><h3 id="2-2-垃圾收集算法"><a href="#2-2-垃圾收集算法" class="headerlink" title="2.2 垃圾收集算法"></a>2.2 垃圾收集算法</h3><h4 id="2-2-1-标记清除算法（mark-sweep）"><a href="#2-2-1-标记清除算法（mark-sweep）" class="headerlink" title="2.2.1 标记清除算法（mark-sweep）"></a>2.2.1 标记清除算法（mark-sweep）</h4><p>最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清 除阶段回收被标记的对象所占用的空间<br>缺陷：大的问题是<strong>内存碎片化严重</strong>，后续可能发生大对象不能找到可利用空间的问题</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200319203309576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt=""></p><h4 id="2-2-2-复制算法（coping）"><a href="#2-2-2-复制算法（coping）" class="headerlink" title="2.2.2 复制算法（coping）"></a>2.2.2 复制算法（coping）</h4><p>为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小 的两块。<strong>每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</strong><br>缺陷：这种算法虽然实现简单，内存效率高，不易产生碎片，但是大的问题是可用<strong>内存被压缩到了原本的一半</strong>。且存活对象增多的话，Copying算法的效率会大大降低</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200319203356390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt=""></p><h4 id="2-2-3-标记整理算法（mark-compact）"><a href="#2-2-3-标记整理算法（mark-compact）" class="headerlink" title="2.2.3 标记整理算法（mark-compact）"></a>2.2.3 标记整理算法（mark-compact）</h4><p>结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清理对象，而是<strong>将存活对象移向内存的一端</strong>，然后清除端边界外的对象。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200319203442654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt=""></p><h4 id="2-2-4-分代收集算法"><a href="#2-2-4-分代收集算法" class="headerlink" title="2.2.4 分代收集算法"></a>2.2.4 分代收集算法</h4><p>分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的<strong>不同生命周期</strong>将内存划分为不同的域，一般情况下将<strong>GC堆划分为老生代</strong>(Tenured/Old Generation)和<strong>新生代</strong>(Young Generation)。<strong>老生代</strong>的特点是每次垃圾回收时<strong>只有少量对象需要被回收</strong>，<strong>新生代</strong>的特点是每次垃 圾回收时都有<strong>大量垃圾需要被回收</strong>，因此可以根据不同区域选择不同的算法</p><h5 id="1-新生代"><a href="#1-新生代" class="headerlink" title="1.新生代"></a>1.新生代</h5><p>是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发 <strong>MinorGC</strong>进行垃圾回收。新生代又分为 Eden区、ServivorFrom、ServivorTo三个区。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200319203609276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt=""></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200319204426987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p><strong>新生代-复制算法</strong>：目前大部分JVM的GC 对于新生代都采取<strong>复制</strong>算法，因为<strong>新生代中每次垃圾回收都要 回收大部分对象，即要复制的操作比较少</strong>，但通常并不是按照1：1来划分新生代。一般将新生代 划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用 <strong>Eden空间和其中的Survivor From</strong>空间，当进行回收时，将该两块空间中还存活的对象<strong>复制到Survivor To</strong>空间中</p><p><strong>MinorGC的过程</strong><br>采用复制算法<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200319204506524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>当对象在Survivor区躲过一次GC 后，其年龄就会+1。默认情况下年龄到达15 的对象会被 移到老生代中</p><h5 id="2-老年代"><a href="#2-老年代" class="headerlink" title="2.老年代"></a>2.老年代</h5><p>老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行 了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足 够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。</p><p><strong>老年代-标记整理算法</strong>：因为<strong>对象存活率高、没有额外空间</strong>对它进行分配担保, 就必须采用“<strong>标记—清理</strong>”或“<strong>标 记—整理</strong>”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。</p><p><strong>MajorGC</strong> 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没 有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减 少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的 时候，就会抛出OOM（Out of Memory）异常。</p><h4 id="2-2-5-分区收集算法"><a href="#2-2-5-分区收集算法" class="headerlink" title="2.2.5 分区收集算法"></a>2.2.5 分区收集算法</h4><p>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的 好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是 整个堆), 从而减少一次GC 所产生的停顿。</p><h2 id="三、垃圾回收器"><a href="#三、垃圾回收器" class="headerlink" title="三、垃圾回收器"></a>三、垃圾回收器</h2><p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法； 年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不 同的垃圾收集器，JDK1.6中Sun HotSpot虚拟机的垃圾收集器如下</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200319204758130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt=""></p><h3 id="3-1-新生代垃圾收集器"><a href="#3-1-新生代垃圾收集器" class="headerlink" title="3.1 新生代垃圾收集器"></a>3.1 新生代垃圾收集器</h3><h4 id="3-1-1-Serial"><a href="#3-1-1-Serial" class="headerlink" title="3.1.1 Serial"></a>3.1.1 Serial</h4><p>基本垃圾收集器，使用<strong>复制</strong>算法。Serial 是一个<strong>单线程</strong>的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工 作，并且在<strong>进行垃圾收集的同时，必须暂停其他所有的工作线程</strong>，直到垃圾收集结束。 Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，<strong>但是它简单高效，对于限 定单个 CPU 环境来说，没有线程交互的开销，可以获得高的单线程垃圾收集效率</strong>，因此 Serial 垃圾收集器依然是java<strong>虚拟机运行在Client模式下默认的新生代垃圾收集器</strong></p><h4 id="3-1-2-ParNew"><a href="#3-1-2-ParNew" class="headerlink" title="3.1.2 ParNew"></a>3.1.2 ParNew</h4><p><strong>ParNew</strong>垃圾收集器其实是Serial收集器的<strong>多线程版本</strong>，也使用<strong>复制</strong>算法，除了使用多线程进行垃 圾收集之外，其余的行为和Serial收集器完全一样，ParNew垃圾收集器<strong>在垃圾收集过程中同样也 要暂停所有其他的工作线程</strong>。<br>ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限 制垃圾收集器的线程数。</p><p>【Parallel：平行的】 ParNew虽然是<strong>除了多线程外和Serial收集器几乎完全一样</strong>，但是ParNew垃圾收集器是很多java 虚拟机运行在<strong>Server模式</strong>下新生代的默认垃圾收集器</p><h4 id="3-1-3-Parallel-Scavenge"><a href="#3-1-3-Parallel-Scavenge" class="headerlink" title="3.1.3 Parallel Scavenge"></a>3.1.3 Parallel Scavenge</h4><p>Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用<strong>复制</strong>算法，也是一个<strong>多线程</strong>的垃 圾收集器，它重点关注的是<strong>程序达到一个可控制的吞吐量</strong>（Thoughput，CPU 用于运行用户代码 的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）， <strong>高吞吐量可以高效率地利用 CPU 时间</strong>，尽快地完成程序的运算任务，主要适用于在后台运算而 不需要太多交互的任务。</p><p><strong>自适应调节策略</strong>也是 ParallelScavenge 收集器与 ParNew 收集器的一个 重要区别</p><p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，<strong>虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量</strong>，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小。</li></ul><h3 id="3-2-老年代垃圾收集器"><a href="#3-2-老年代垃圾收集器" class="headerlink" title="3.2 老年代垃圾收集器"></a>3.2 老年代垃圾收集器</h3><h4 id="3-2-1-Serial-Old"><a href="#3-2-1-Serial-Old" class="headerlink" title="3.2.1 Serial Old"></a>3.2.1 Serial Old</h4><p>Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个<strong>单线程</strong>的收集器，使用<strong>标记-整理</strong>算法， 这个收集器也主要是<strong>运行在Client默认的java虚拟机默认的年老代垃圾收集器</strong>。<br>在<strong>Server模式</strong>下，主要有两个用途：<br>（1）在<strong>JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配</strong>使用。<br>（2）作为<strong>年老代中使用CMS收集器的后备垃圾收集方案</strong>。 新生代Serial与年老代Serial Old搭配垃圾收集过程图：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020031920535836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt=""></p><p>（3）新生代Parallel Scavenge收集器与ParNew收集器工作原理类似，都是<strong>多线程</strong>的收集器，都使 用的是<strong>复制</strong>算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代Parallel Scavenge/ParNew与年老代Serial Old搭配垃圾收集过程图：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200319205605515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt=""></p><h4 id="3-2-2-Parallel-Old"><a href="#3-2-2-Parallel-Old" class="headerlink" title="3.2.2 Parallel Old"></a>3.2.2 Parallel Old</h4><p>Parallel Old收集器是<strong>Parallel Scavenge的年老代版本</strong>，使用<strong>多线程的标记-整理</strong>算法，在JDK1.6 才开始提供。 在 JDK1.6 之前，新生代使用 Parallel Scavenge 收集器只能搭配年老代的 Serial Old 收集器，只 能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在<strong>年老代同样提供吞 吐量优先的垃圾收集器</strong>，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge 和年老代Parallel Old收集器的搭配策略。 新生代Parallel Scavenge和年老代Parallel Old收集器搭配运行过程图：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200319205808779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt=""></p><h4 id="3-2-3-CMS"><a href="#3-2-3-CMS" class="headerlink" title="3.2.3 (CMS)"></a>3.2.3 (CMS)</h4><p>Concurrent mark sweep收集器是一种<strong>年老代</strong>垃圾收集器，其主要目标是<strong>获取短垃圾 回收停顿时间</strong>，<strong>和其他年老代</strong>使用标记-整理算法<strong>不同</strong>，它使用多线程的<strong>标记-清除</strong>算法。 <strong>短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验</strong>。 CMS工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下4个阶段：</p><p><strong>初始标记</strong>：<strong>只是标记</strong>一下GC Roots能直接关联的对象，速度很快，<strong>仍然需要暂停所有的工作线程</strong>。<br><strong>并发标记</strong>：进行GC Roots跟踪的过程，<strong>和用户线程一起工作，不需要暂停工作线程</strong>。<br><strong>重新标记</strong>：为了<strong>修正</strong>在并发标记期间，因用户程序继续运行而导致标记产生变动的那<strong>一部分对象的标记</strong> 记录，仍然需要<strong>暂停所有</strong>的工作线程。<br><strong>并发清除</strong>：清除GC Roots不可达对象，和用户线程一起工作，<strong>不需要暂停</strong>工作线程。由于<strong>耗时长的并 发标记和并发清除</strong>过程中，垃圾收集线程<strong>可以和用户现在一起并发工作</strong>，所以总体上来看 CMS收集器的内存回收和用户线程是一起并发地执行。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200319210038429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt=""></p><h4 id="3-2-4-G1收集器"><a href="#3-2-4-G1收集器" class="headerlink" title="3.2.4 G1收集器"></a>3.2.4 G1收集器</h4><p>G1收集器：<strong>通过把Java堆分成多个独立区域，回收时计算出每个区域回收所获得的空间以及所需时间的经验值，根据记录两个值来判断哪个区域最具有回收价值，所以叫Garbage First（垃圾优先）</strong></p><p><strong>初始标记</strong>（Initial Marking）：仅仅只是<strong>标记一下GC Roots能直接关联到的对象</strong>，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要 <strong>停顿线程，但耗时很短</strong>，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。<br><strong>并发标记</strong>（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归<strong>扫描整个堆 里的对象图</strong>，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以 后，还要重新处理SATB记录下的在并发时有引用变动的对象。<br><strong>最终标记</strong>（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。<br><strong>筛选回收</strong>（Live Data Counting and Evacuation）：负责更新Region的统计数据，<strong>对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划</strong>，可以自由<strong>选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间</strong>。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行 完成的。</p><p>TAMS：</p><p>程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设 计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过 程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上</p><p>G1 收 集器两个突出的<strong>改进</strong>是：<br>1.基于<strong>标记-整理</strong>算法，不产生内存碎片。<br>2.可以非常<strong>精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收</strong>。 G1 收集器<strong>避免全区域垃圾收集</strong>，它把<strong>堆内存划分为大小固定的几个独立区域</strong>，并且跟踪这些区域 的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾 多的区域。<strong>区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得高的垃圾收 集效率</strong>。</p><p>G1执行垃圾回收的处理方式与CMS相似. G1在全局标记阶段(global marking phase)并发执行, 以确定堆内存中哪些对象是存活的。标记阶段完成后,G1就可以知道哪些heap区的empty空间最大。它会首先回收这些区,通常会得到大量的自由空间. </p><p>被G1标记为适合回收的heap区将使用转移(evacuation)的方式进行垃圾回收. G1将一个或多个heap区域中的对象拷贝到其他的单个区域中,并在此过程中压缩和释放内存. 在多核CPU上转移是并行执行的(parallel on multi-processors), 这样能减少停顿时间并增加吞吐量. 因此,每次垃圾收集时, G1都会持续不断地减少碎片, 并且在用户给定的暂停时间内执行. 这比以前的方法强大了很多. CMS垃圾收集器(Concurrent Mark Sweep,并发标记清理)不进行压缩. ParallelOld 垃圾收集只对整个堆执行压缩,从而导致相当长的暂停时间。</p><p>需要强调的是, G1并不是一款实时垃圾收集器(real-time collector). 能以极高的概率在设定的目标暂停时间内完成,但不保证绝对在这个时间内完成。 基于以前收集的各种监控数据, G1会根据用户指定的目标时间来预估能回收多少个heap区. 因此,收集器有一个相当精确的heap区耗时计算模型,并根据该模型来确定在给定时间内去回收哪些heap区.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap实现原理及源码阅读</title>
      <link href="/2020/05/03/Java/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2020/05/03/Java/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考自</p><ul><li><a href="https://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/" target="_blank" rel="noopener">https://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/</a></li><li><a href="https://juejin.im/post/5c8276216fb9a049d51a4cd6" target="_blank" rel="noopener">https://juejin.im/post/5c8276216fb9a049d51a4cd6</a></li></ul></blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>并发安全机制<br>分段锁机制<br>synchronized + CAS<br>内部数据结构</p><h3 id="ConcurrentHashMap安全的原理"><a href="#ConcurrentHashMap安全的原理" class="headerlink" title="ConcurrentHashMap安全的原理"></a>ConcurrentHashMap安全的原理</h3><p>ConcurrentHashMap是线程安全也就是说多线程下写操作不会发生数据不一致的问题，那么就以put方法举例。当要put(key)时，首先计算出要插入数组的哪个位置，如果该位置还没存值，则通过cas插入；如果存在值了，则将当前位置用synchronized锁住，并以拉链法的形式插入链表尾部。通过CAS和synchronized就保证了线程安全。</p><h2 id="一、了解Hashtable"><a href="#一、了解Hashtable" class="headerlink" title="一、了解Hashtable"></a>一、了解Hashtable</h2><blockquote><p>在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p></blockquote><p>在讲ConcurrentHashMap之前，先讲下Hashtable，它使用 synchronized 关键字实现线程安全，比如 get 方法和 put 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>注意到，synchronized 关键字加在非静态方法上，说明同步锁对象即是 Hashtable 对象本身，只有一个锁。</p><h3 id="1-1-Hashtable与ConcurrentHashMap区别"><a href="#1-1-Hashtable与ConcurrentHashMap区别" class="headerlink" title="1.1 Hashtable与ConcurrentHashMap区别"></a>1.1 Hashtable与ConcurrentHashMap区别</h3><p><strong>线程安全的实现</strong>：<code>Hashtable</code>采用<strong>对象锁</strong>(synchronized修饰对象方法)来保证线程安全，也就是一个<code>Hashtable</code>对象只有一把锁，如果线程1拿了对象A的锁进行有<code>synchronized</code>修饰的<code>put</code>方法，其他线程是无法操作对象A中有<code>synchronized</code>修饰的方法的(如<code>get</code>方法、<code>remove</code>方法等)，竞争激烈所以效率低下。而<code>ConcurrentHashMap</code>采用<code>CAS</code> + <code>synchronized</code>来保证并发安全性，且<code>synchronized</code>关键字不是用在方法上而是用在了具体的对象上，实现了更小粒度的锁。</p><p>数据结构的实现：<code>Hashtable</code>采用的是<strong>数组 + 链表</strong>，当链表过长会影响查询效率，而<code>ConcurrentHashMap</code>采用<strong>数组 + 链表 + 红黑树</strong>，当链表长度超过某一个值，则将链表转成红黑树，提高查询效率。</p><h2 id="二、底层数据结构"><a href="#二、底层数据结构" class="headerlink" title="二、底层数据结构"></a>二、底层数据结构</h2><p>jdk1.7中 ConcurrentHashMap 使用了锁分段技术</p><blockquote><p>假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个Segment都是一个ReentrantLock锁，同时它内部保存着一个HashEntry数组</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets next field with volatile write semantics.  (See above</span></span><br><span class="line"><span class="comment">     * about use of putOrderedObject.)</span></span><br><span class="line"><span class="comment">     * 设置next，注意unsafe的使用，ConcurrentHashMap中很多这种操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(HashEntry&lt;K,V&gt; n)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class k = HashEntry<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            <span class="comment">//计算 nextOffset ，以使用设置next</span></span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>jdk1.7</strong></p><p>在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个<strong>Segment数组和多个HashEntry</strong>组成，主要实现原理是实现了<strong>锁分离</strong>的思路解决了多线程的安全问题，<code>Segment</code>在实现上继承了<code>ReentrantLock</code>，这样就自带了锁的功能。如下图所示：</p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MDMxMzcxLTM3NTMzMDU4NWEzZTE4NjkucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMDAwL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png"  alt=""></p><p>一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 每个Segment元素 里包含一个HashEntry数组，每个HashEntry元素是一个链表结构的元素， 每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p><p><strong>jdk1.8</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示正在转移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示已经转换成树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="comment">//默认没初始化的数组，用来保存元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="comment">//转移的时候用的数组</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来控制表初始化和扩容的，默认值为0，当在初始化的时候指定了大小，这会将这个大小保存在sizeCtl中，大小为数组的0.75</span></span><br><span class="line"><span class="comment">     * 当为负的时候，说明表正在初始化或扩张，</span></span><br><span class="line"><span class="comment">     *     -1表示初始化</span></span><br><span class="line"><span class="comment">     *     -(1+n) n:表示活动的扩张线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Node是最核心的内部类，包装了key-value键值对，所有插入ConcurrentHashMap的数据都包装在这里面。 </span></span><br><span class="line"><span class="comment">它与HashMap中的定义很相似，但是有一些差别它对value和next属性设置了volatile同步锁，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//key的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;       <span class="comment">//key</span></span><br><span class="line">    <span class="keyword">volatile</span> V val;    <span class="comment">//value</span></span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next; <span class="comment">//表示链表中的下一个节点</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">树节点类，另外一个核心的数据结构。 当链表长度过长的时候，会转换为TreeNode。 </span></span><br><span class="line"><span class="comment">但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。 </span></span><br><span class="line"><span class="comment">而且TreeNode在ConcurrentHashMap继承自Node类，而并非HashMap中的集成自LinkedHashMap.Entry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeBin 用作树的头结点，只存储root和first节点，不存储节点的key、value值。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ForwardingNode在转移的时候放在头部的节点，是一个空节点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. </span></span><br><span class="line"><span class="comment">这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">        ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本。</p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MDMxMzcxLTViYTg0NTRkMWJjNmYzZTcucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMDAwL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png"  alt=""></p><h3 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造函数，什么也不做，table的初始化放在了第一次插入数据时，默认容量大小是16和HashMap的一样，默认sizeCtl为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入容量大小的构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果传入的容量大小小于0 则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果传入的容量大小大于允许的最大容量值 则cap取允许的容量最大值 否则cap =</span></span><br><span class="line">    <span class="comment">//((传入的容量大小 + 传入的容量大小无符号右移1位 + 1)的结果向上取最近的2幂次方)，</span></span><br><span class="line">    <span class="comment">//即如果传入的容量大小是12 则 cap = 32(12 + (12 &gt;&gt;&gt; 1) + 1=19</span></span><br><span class="line">    <span class="comment">//向上取2的幂次方即32)，这里为啥一定要是2的幂次方，原因和HashMap的threshold一样，都是为</span></span><br><span class="line">    <span class="comment">//了让位运算和取模运算的结果一样。</span></span><br><span class="line">    <span class="comment">//MAXIMUM_CAPACITY即允许的最大容量值 为2^30。</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               <span class="comment">//tableSizeFor这个函数即实现了将一个整数取2的幂次方。</span></span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//将上面计算出的cap 赋值给sizeCtl，注意此时sizeCtl为正数，代表进行扩容的容量大小。</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含指定Map的构造函数。</span></span><br><span class="line"><span class="comment">//置sizeCtl为默认容量大小 即16。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入容量大小和负载因子的构造函数。</span></span><br><span class="line"><span class="comment">//默认并发数大小是1。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入容量大小、负载因子和并发数大小的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果传入的容量大小 小于 传入的并发数大小，</span></span><br><span class="line">    <span class="comment">//则容量大小取并发数大小，这样做的原因是确保每一个Node只会分配给一个线程，而一个线程则</span></span><br><span class="line">    <span class="comment">//可以分配到多个Node，比如当容量大小为64，并发数大</span></span><br><span class="line">    <span class="comment">//小为16时，则每个线程分配到4个Node。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">//size = 1.0 + (long)initialCapacity / loadFactor 这里计算方法和上面的构造函数不一样。</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">//如果size大于允许的最大容量值则 sizeCtl = 允许的最大容量值 否则 sizeCtl =</span></span><br><span class="line">    <span class="comment">//size取2的幂次方。</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcurrentHashMap</code>的构造函数有5个，从数量上看就和<code>HashMap</code>、<code>Hashtable</code>(4个)的不同，多出的那个构造函数是<code>public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)</code>，即除了传入容量大小、负载因子之外还多传入了一个整型的<code>concurrencyLevel</code>，这个整型是我们预先估计的并发量，比如我们估计并发是<code>30</code>，那么就可以传入<code>30</code>。<br> 其他的4个构造函数的参数和<code>HashMap</code>的一样，而具体的初始化过程却又不相同，<code>HashMap</code>和<code>Hashtable</code>传入的容量大小和负载因子都是为了计算出<strong>初始阈值</strong>(threshold)，而<code>ConcurrentHashMap</code>传入的容量大小和负载因子是为了计算出<strong>sizeCtl</strong>用于初始化<code>table</code>，这个sizeCtl即table数组的大小，不同的构造函数计算sizeCtl方法都不一样。</p><h3 id="2-2-unSafe方法"><a href="#2-2-unSafe方法" class="headerlink" title="2.2 unSafe方法"></a>2.2 unSafe方法</h3><p>在ConcurrentHashMap中，大量使用了U.compareAndSwapXXX的方法，这个方法是利用一个CAS算法实现无锁化的修改值的操作，他可以大大降低锁代理的性能消耗。这个算法的基本思想就是<strong>不断地去比较当前内存中的变量值与你指定的一个变量值是否相等，如果相等，则接受你指定的修改的值，否则拒绝你的操作</strong>。因为当前线程中的值已经不是最新的值，你的修改很可能会覆盖掉其他线程修改的结果。这一点与乐观锁，SVN的思想是比较类似的。<br>unsafe代码块控制了一些属性的修改工作，比如最常用的SIZECTL 。 在这一版本的concurrentHashMap中，大量应用来的CAS方法进行变量、属性的修改工作。 利用CAS进行无锁操作，可以大大提高性能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 用来返回节点数组的指定位置的节点的原子操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * cas原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">       U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="三、存取机制"><a href="#三、存取机制" class="headerlink" title="三、存取机制"></a>三、存取机制</h2><h3 id="3-1-put方法"><a href="#3-1-put方法" class="headerlink" title="3.1 put方法"></a>3.1 put方法</h3><p>put()能将对应的key与value保存到map中。在<strong>ConcurrentHashMap中，key与value都不能为空</strong>，否则会抛出NullPointerException异常。如果put()时，key已经存在，则会返回put()前该key对应的value。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不允许键值为null，这点与线程安全的Hashtable保持一致，和HashMap不同。</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//取键key的hashCode()和HashMap、Hashtable都一样，然后再执行spread()方法计算得到哈希地</span></span><br><span class="line">    <span class="comment">//址，这个spread()方法和HashMap的hash()方法一样，都是将hashCode()做无符号右移16位，只不</span></span><br><span class="line">    <span class="comment">//过spread()加多了 &amp;0x7fffffff，让结果为正数。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果table数组为空或者长度为0(未初始化)，则调用initTable()初始化table，初始化函数</span></span><br><span class="line">        <span class="comment">//下面介绍。</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//调用实现了CAS原子性操作的tabAt方法</span></span><br><span class="line">        <span class="comment">//tabAt方法的第一个参数是Node数组的引用，第二个参数在Node数组的下标，实现的是在Nod</span></span><br><span class="line">        <span class="comment">//e数组中查找指定下标的Node，如果找到则返回该Node节点(链表头节点)，否则返回null，</span></span><br><span class="line">        <span class="comment">//这里的i = (n - 1)&amp;hash即是计算待插入的节点在table的下标，即table容量-1的结果和哈</span></span><br><span class="line">        <span class="comment">//希地址做与运算，和HashMap的算法一样。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果该下标上并没有节点(即链表为空)，则直接调用实现了CAS原子性操作的</span></span><br><span class="line">            <span class="comment">//casTable()方法，</span></span><br><span class="line">            <span class="comment">//casTable()方法的第一个参数是Node数组的引用，第二个参数是待操作的下标，第三</span></span><br><span class="line">            <span class="comment">//个参数是期望值，第四个参数是待操作的Node节点，实现的是将Node数组下标为参数二</span></span><br><span class="line">            <span class="comment">//的节点替换成参数四的节点，如果期望值和实际值不符返回false，否则参数四的节点成</span></span><br><span class="line">            <span class="comment">//功替换上去，返回ture，即插入成功。注意这里：如果插入成功了则跳出for循环，插入</span></span><br><span class="line">            <span class="comment">//失败的话(其他线程抢先插入了)，那么会执行到下面的代码。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该下标上的节点的哈希地址为-1(即链表的头节点为ForwardingNode节点)，则表示</span></span><br><span class="line">        <span class="comment">//table需要扩容，值得注意的是ConcurrentHashMap初始化和扩容不是用同一个方法，而</span></span><br><span class="line">        <span class="comment">//HashMap和Hashtable都是用同一个方法，当前线程会去协助扩容，扩容过程后面介绍。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//如果该下标上的节点既不是空也不是需要扩容，则表示这个链表可以插入值，将进入到链表</span></span><br><span class="line">        <span class="comment">//中，将新节点插入或者覆盖旧值。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//通过关键字synchroized对该下标上的节点加锁(相当于锁住锁住</span></span><br><span class="line">            <span class="comment">//该下标上的链表)，其他下标上的节点并没有加锁，所以其他线程</span></span><br><span class="line">            <span class="comment">//可以安全的获得其他下标上的链表进行操作，也正是因为这个所</span></span><br><span class="line">            <span class="comment">//以提高了ConcurrentHashMap的效率，提高了并发度。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//如果该下标上的节点的哈希地址大于等于0，则表示这是</span></span><br><span class="line">                    <span class="comment">//个链表。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//如果哈希地址、键key相同 或者 键key不为空</span></span><br><span class="line">                            <span class="comment">//且键key相同，则表示存在键key和待插入的键</span></span><br><span class="line">                            <span class="comment">//key相同，则执行更新值value的操作。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//如果找到了链表的最后一个节点都没有找到相</span></span><br><span class="line">                            <span class="comment">//同键Key的，则是插入操作，将插入的键值新建</span></span><br><span class="line">                            <span class="comment">//个节点并且添加到链表尾部，这个和HashMap一</span></span><br><span class="line">                            <span class="comment">//样都是插入到尾部。</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果该下标上的节点的哈希地址小于0 且为树节点</span></span><br><span class="line">                    <span class="comment">//则将带插入键值新增到红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//如果插入的结果不为null，则表示为替换</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash,</span><br><span class="line">                        key,value)) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断链表的长度是否大于等于链表的阈值(8)，大于则将链表转成</span></span><br><span class="line">            <span class="comment">//红黑树，提高效率。这点和HashMap一样。</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结流程：</p><ol><li>判断键值是否为<code>null</code>，为<code>null</code>抛出异常。</li><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址，这个HashMap相似。</li><li>如果当前table为空，则初始化table，需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong>尝试</strong>初始化table，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程。</li><li>使用 <strong>容量大小-1 &amp; 哈希地址</strong> 计算出待插入键值的下标，如果该下标上的bucket为<code>null</code>，则直接调用实现<code>CAS</code>原子性操作的<code>casTabAt()</code>方法将节点插入到table中，如果插入成功则完成put操作，结束返回。插入失败(被别的线程抢先插入了)则继续往下执行。</li><li>如果该下标上的节点(头节点)<strong>MOVED(-1)的哈希地址为-1</strong>，代表需要扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li><li>如果该下标上的bucket不为空，且又不需要扩容，则进入到bucket中，同时<strong>synchronized锁住这个bucket</strong>，注意只是锁住该下标上的bucket而已，其他的bucket并未加锁，其他线程仍然可以操作其他未上锁的bucket，这个就是ConcurrentHashMap为什么高效的原因之一。</li><li>进入到bucket里面，首先判断这个bucket存储的是红黑树(哈希地址小于0，原因后面分析)还是链表。</li><li>如果是<strong>链表</strong>，则遍历链表看看是否有哈希地址和键key相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点<strong>插入到链表尾部</strong>。如果是<strong>红黑树</strong>，则将节点插入。到这里<strong>结束加锁</strong>。</li><li>最后判断该bucket上的链表长度是否大于<strong>链表转红黑树的阈值(8)</strong>，大于则调用<code>treeifyBin()</code>方法将链表转成红黑树，以免链表过长影响效率。</li><li>调用<code>addCount()</code>方法，作用是将ConcurrentHashMap的键值对数量+1，还有另一个作用是检查ConcurrentHashMap是否需要扩容。</li></ol><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502185635.png"  alt=""></p><p><strong>补充说明</strong>：</p><p><strong>为什么ConcurrentHashMap中，key与value都不能为空</strong></p><p>ConcurrentHashMap的使用场景为多线程，如果有A、B两个线程，线程A调用concurrentHashMap.get(key)方法,返回为null，我们还是不知道这个null是没有映射的null还是存的值就是null。虽然可以用concurrentHashMap.containsKey(key)来判断，但是多线程下，如果A调用concurrentHashMap.get(key)方法之后，containsKey方法之前，有一个线程B执行了concurrentHashMap.put(key,null)的操作。那么我们调用containsKey方法返回的就是true了。这就与我们的假设的真实情况不符合了。也就是上面说的二义性。</p><p><strong>spread()具体干了什么？有什么意义？</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算hash值</span></span><br><span class="line"><span class="comment">// 让高16位 异或 低16位，再把高的16位置为0</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;        <span class="comment">// &amp; HASH_BITS用于把hash值转化为正数</span></span><br><span class="line">        <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里我也实在是迷惑了，和hashmap的hash()方法实现一样的，只是多了个HASH_BITS=0x7fffffff</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-get方法"><a href="#3-2-get方法" class="headerlink" title="3.2 get方法"></a>3.2 get方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//运用键key的hashCode()计算出哈希地址</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//如果table不为空 且 table长度大于0 且 计算出的下标上bucket不为空，</span></span><br><span class="line">    <span class="comment">//则代表这个bucket存在，进入到bucket中查找，</span></span><br><span class="line">    <span class="comment">//其中(n - 1) &amp; h为计算出键key相对应的数组下标的算法。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果哈希地址、键key相同则表示查找到，返回value，这里查找到的是头节点。</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果bucket头节点的哈希地址小于0，则代表bucket为红黑树，在红黑树中查找。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果bucket头节点的哈希地址不小于0，则代表bucket为链表，遍历链表，在链表中查找。</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结流程：</p><ol><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址。</li><li>计算出键key所在的下标，算法是(n - 1) &amp; h，如果table不为空，且下标上的bucket不为空，则到bucket中查找。</li><li>如果bucket的头节点的哈希地址小于0，则代表这个bucket存储的是红黑树，否则是链表。</li><li>到红黑树或者链表中查找，找到则返回该键key的值，找不到则返回null。</li></ol><h3 id="3-3-initTable初始化方法"><a href="#3-3-initTable初始化方法" class="headerlink" title="3.3 initTable初始化方法"></a>3.3 initTable初始化方法</h3><p>调用ConcurrentHashMap的构造方法仅仅是设置了一些参数而已，而整个table的初始化是在向ConcurrentHashMap中插入元素的时候发生的。如调用put、computeIfAbsent、compute、merge等方法的时候，调用时机是检查table==null。<br>初始化方法主要应用了关键属性sizeCtl 如果这个值 &lt; 0，表示其他线程正在进行初始化，就放弃这个操作。<br>在这也可以看出ConcurrentHashMap的初始化只能由一个线程完成。如果获得了初始化权限，就用CAS方法将sizeCtl置为-1，防止其他线程进入。初始化数组后，将sizeCtl的值改为0.75*n</p><p><strong>sizeCtl含义</strong> </p><ol><li>负数代表正在进行初始化或扩容操作 </li><li>-1代表正在初始化 </li><li>-N 表示有N-1个线程正在进行扩容操作 </li><li>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，这一点类似于扩容阈值的概念。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//如果table为null或者长度为0， //则一直循环试图初始化table(如果某一时刻别的线程将table初始化好了，那table不为null，该//线程就结束while循环)。</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sizeCtl小于0，</span></span><br><span class="line">        <span class="comment">//即有其他线程正在初始化或者扩容，执行Thread.yield()将当前线程挂起，让出CPU时间，</span></span><br><span class="line">        <span class="comment">//该线程从运行态转成就绪态。</span></span><br><span class="line">        <span class="comment">//如果该线程从就绪态转成运行态了，此时table可能已被别的线程初始化完成，table不为</span></span><br><span class="line">        <span class="comment">//null，该线程结束while循环。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//如果此时sizeCtl不小于0，即没有别的线程在做table初始化和扩容操作，</span></span><br><span class="line">        <span class="comment">//那么该线程就会调用Unsafe的CAS操作compareAndSwapInt尝试将sizeCtl的值修改成</span></span><br><span class="line">        <span class="comment">//-1(sizeCtl=-1表示table正在初始化，别的线程如果也进入了initTable方法则会执行</span></span><br><span class="line">        <span class="comment">//Thread.yield()将它的线程挂起 让出CPU时间)，</span></span><br><span class="line">        <span class="comment">//如果compareAndSwapInt将sizeCtl=-1设置成功 则进入if里面，否则继续while循环。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//再次确认当前table为null即还未初始化，这个判断不能少。</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果sc(sizeCtl)大于0，则n=sc，否则n=默认的容量大</span></span><br><span class="line">                    小<span class="number">16</span>，</span><br><span class="line">                    <span class="comment">//这里的sc=sizeCtl=0，即如果在构造函数没有指定容量</span></span><br><span class="line">                    大小，</span><br><span class="line">                    <span class="comment">//否则使用了有参数的构造函数，sc=sizeCtl=指定的容量大小。</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">//创建指定容量的Node数组(table)。</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//计算阈值，n - (n &gt;&gt;&gt; 2) = 0.75n当ConcurrentHashMap储存的键值对数量</span></span><br><span class="line">                    <span class="comment">//大于这个阈值，就会发生扩容。</span></span><br><span class="line">                    <span class="comment">//这里的0.75相当于HashMap的默认负载因子，可以发现HashMap、Hashtable如果</span></span><br><span class="line">                    <span class="comment">//使用传入了负载因子的构造函数初始化的话，那么每次扩容，新阈值都是=新容</span></span><br><span class="line">                    <span class="comment">//量 * 负载因子，而ConcurrentHashMap不管使用的哪一种构造函数初始化，</span></span><br><span class="line">                    <span class="comment">//新阈值都是=新容量 * 0.75。</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断table是否为<code>null</code>，即需不需要首次初始化，如果某个线程进到这个方法后，其他线程已经将table初始化好了，那么该线程结束该方法返回。</li><li>如果table为<code>null</code>，进入到while循环，如果<code>sizeCtl</code>小于0(其他线程正在对table初始化)，那么该线程调用<code>Thread.yield()</code>挂起该线程，让出CPU时间，该线程也从运行态转成就绪态，等该线程从就绪态转成运行态的时候，别的线程已经table初始化好了，那么该线程结束while循环，结束初始化方法返回。如果从就绪态转成运行态后，table仍然为<code>null</code>，则继续while循环。</li><li>如果table为<code>null</code>且<code>sizeCtl</code>不小于0，则调用实现<code>CAS</code>原子性操作的<code>compareAndSwap()</code>方法将sizeCtl设置成-1，告诉别的线程我正在初始化table，这样别的线程无法对table进行初始化。如果设置成功，则再次判断table是否为空，不为空则初始化table，容量大小为默认的容量大小(16)，或者为sizeCtl。其中sizeCtl的初始化是在构造函数中进行的，sizeCtl = ((传入的容量大小 + 传入的容量大小无符号右移1位 + 1)的结果向上取最近的2幂次方)</li></ol><h2 id="四、扩容机制"><a href="#四、扩容机制" class="headerlink" title="四、扩容机制"></a>四、扩容机制</h2><h3 id="4-1-transfer扩容方法"><a href="#4-1-transfer扩容方法" class="headerlink" title="4.1 transfer扩容方法"></a>4.1 transfer扩容方法</h3><p><code>transfer()</code>方法为<code>ConcurrentHashMap</code>扩容操作的核心方法。由于<code>ConcurrentHashMap</code>支持多线程扩容，而且也没有进行加锁，所以实现会变得有点儿复杂。整个扩容操作分为两步：</p><ol><li>构建一个nextTable，其大小为原来大小的<strong>两倍</strong>，这个步骤是在单线程环境下完成的</li><li>将原来table里面的内容复制到nextTable中，这个步骤是允许<strong>多线程</strong>操作的，所以性能得到提升，减少了扩容的时间消耗</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment">     * above for explanation.</span></span><br><span class="line"><span class="comment">     * 把数组中的节点复制到新的数组的相同位置，或者移动到扩张部分的相同位置</span></span><br><span class="line"><span class="comment">     * 在这里首先会计算一个步长，表示一个线程处理的数组长度，用来控制对CPU的使用，</span></span><br><span class="line"><span class="comment">     * 每个CPU最少处理16个长度的数组元素,也就是说，如果一个数组的长度只有16，那只有一个线程会对其进行扩容的复制移动操作</span></span><br><span class="line"><span class="comment">     * 扩容的时候会一直遍历，知道复制完所有节点，每处理一个节点的时候会在链表的头部设置一个fwd节点，这样其他线程就会跳过他，</span></span><br><span class="line"><span class="comment">     * 复制后在新数组中的链表不是绝对的反序的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)    <span class="comment">//MIN_TRANSFER_STRIDE 用来控制不要占用太多CPU</span></span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range    //MIN_TRANSFER_STRIDE=16</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果复制的目标nextTab为null的话，则初始化一个table两倍长的nextTab</span></span><br><span class="line"><span class="comment">         * 此时nextTable被设置值了(在初始情况下是为null的)</span></span><br><span class="line"><span class="comment">         * 因为如果有一个线程开始了表的扩张的时候，其他线程也会进来帮忙扩张，</span></span><br><span class="line"><span class="comment">         * 而只是第一个开始扩张的线程需要初始化下目标数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建一个fwd节点，这个是用来控制并发的，当一个节点为空或已经被转移之后，就设置为fwd节点</span></span><br><span class="line"><span class="comment">         * 这是一个空的标志节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;    <span class="comment">//是否继续向前查找的标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep(清扫) before committing nextTab,在完成之前重新在扫描一遍数组，看看有没完成的没</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing) &#123;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;        <span class="comment">//已经完成转移</span></span><br><span class="line">                    nextTable = <span class="keyword">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);    <span class="comment">//设置sizeCtl为扩容后的0.75</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)            <span class="comment">//数组中把null的元素设置为ForwardingNode节点(hash值为MOVED[-1])</span></span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;                <span class="comment">//加锁操作</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;        <span class="comment">//该节点的hash值大于等于0，说明是一个Node节点</span></span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                 * 因为n的值为数组的长度，且是power(2,x)的，所以，在&amp;操作的结果只可能是0或者n</span></span><br><span class="line"><span class="comment">                                 * 根据这个规则</span></span><br><span class="line"><span class="comment">                                 *         0--&gt;  放在新表的相同位置</span></span><br><span class="line"><span class="comment">                                 *         n--&gt;  放在新表的（n+原来位置）</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n; </span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * lastRun 表示的是需要复制的最后一个节点</span></span><br><span class="line"><span class="comment">                             * 每当新节点的hash&amp;n -&gt; b 发生变化的时候，就把runBit设置为这个结果b</span></span><br><span class="line"><span class="comment">                             * 这样for循环之后，runBit的值就是最后不变的hash&amp;n的值</span></span><br><span class="line"><span class="comment">                             * 而lastRun的值就是最后一次导致hash&amp;n 发生变化的节点(假设为p节点)</span></span><br><span class="line"><span class="comment">                             * 为什么要这么做呢？因为p节点后面的节点的hash&amp;n 值跟p节点是一样的，</span></span><br><span class="line"><span class="comment">                             * 所以在复制到新的table的时候，它肯定还是跟p节点在同一个位置</span></span><br><span class="line"><span class="comment">                             * 在复制完p节点之后，p节点的next节点还是指向它原来的节点，就不需要进行复制了，自己就被带过去了</span></span><br><span class="line"><span class="comment">                             * 这也就导致了一个问题就是复制后的链表的顺序并不一定是原来的倒序</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;    <span class="comment">//n的值为扩张前的数组的长度</span></span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 构造两个链表，顺序大部分和原来是反的</span></span><br><span class="line"><span class="comment">                             * 分别放到原来的位置和新增加的长度的相同位置(i/n+i)</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同为0的节点)设置到旧的table的第一个hash计算后为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值不为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同不为0的节点)设置到旧的table的第一个hash计算后不为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);    </span><br><span class="line">                            &#125;</span><br><span class="line">                            setTabAt(nextTab, i, ln);    </span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    <span class="comment">//否则的话是一个树节点</span></span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 在复制完树节点之后，判断该节点处构成的树还有几个节点，</span></span><br><span class="line"><span class="comment">                             * 如果≤6个的话，就转回为一个链表</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体流程</p><p>首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素：</p><ol><li>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点；</li><li>如果这个位置是Node节点（fh&gt;=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</li><li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</li><li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍，完成扩容。 </li></ol><p>多线程遍历节点，处理了一个节点，就把对应点的值set为forward，另一个线程看到forward，就向后继续遍历，再加上给节点上锁的机制，就完成了多线程的控制。这样交叉就完成了复制工作。而且还很好的解决了线程安全的问题。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20161104100903076"  alt=""></p><h3 id="4-2-红黑树转换"><a href="#4-2-红黑树转换" class="headerlink" title="4.2 红黑树转换"></a>4.2 红黑树转换</h3><p>在putVal函数中，treeifyBin是在链表长度达到一定阈值（8）后转换成红黑树的函数。 但是并不是直接转换，而是进行一次容量判断，如果容量没有达到转换的要求，直接进行扩容操作并返回；如果满足条件才将链表的结构转换为TreeBin ，这与HashMap不同的是，它并没有把TreeNode直接放入红黑树，而是利用了TreeBin这个小容器来封装所有的TreeNode。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、面试题"><a href="#五、面试题" class="headerlink" title="五、面试题"></a>五、面试题</h2><h3 id="5-1-HashMap、Hashtable、ConcurrentHashMap三者对比"><a href="#5-1-HashMap、Hashtable、ConcurrentHashMap三者对比" class="headerlink" title="5.1 HashMap、Hashtable、ConcurrentHashMap三者对比"></a>5.1 HashMap、Hashtable、ConcurrentHashMap三者对比</h3><table><thead><tr><th align="left"></th><th align="left"><strong>HashMap</strong></th><th align="left"><strong>Hashtable</strong></th><th align="left"><strong>ConcurrentHashMap</strong></th></tr></thead><tbody><tr><td align="left">是否线程安全</td><td align="left">否</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">线程安全采用的方式</td><td align="left"></td><td align="left">采用<code>synchronized</code>类锁，效率低</td><td align="left">采用<code>CAS</code> + <code>synchronized</code>，锁住的只有当前操作的<strong>bucket</strong>，不影响其他线程对其他bucket的操作，效率高</td></tr><tr><td align="left">数据结构</td><td align="left">数组+链表+红黑树(链表长度超过8则转红黑树)</td><td align="left">数组+链表</td><td align="left">数组+链表+红黑树(链表长度超过8则转红黑树)</td></tr><tr><td align="left">是否允许<code>null</code>键值</td><td align="left">是</td><td align="left">否</td><td align="left">否</td></tr><tr><td align="left">哈希地址算法</td><td align="left">(key的hashCode)^(key的hashCode无符号右移16位)</td><td align="left">key的hashCode</td><td align="left">( (key的hashCode)^(key的hashCode无符号右移16位) )&amp;0x7fffffff</td></tr><tr><td align="left">定位算法</td><td align="left">哈希地址&amp;(容量大小-1)，1.8之后：<strong>扩容前的原始位置+扩容的大小值</strong></td><td align="left">(哈希地址&amp;0x7fffffff)%容量大小</td><td align="left">哈希地址&amp;(容量大小-1)</td></tr><tr><td align="left">扩容算法</td><td align="left">当键值对数量大于阈值，则容量扩容到原来的2倍。</td><td align="left">当键值对数量大于等于阈值，则容量扩容到原来的2倍+1</td><td align="left">当键值对数量大于等于sizeCtl，<strong>单线程创建新哈希表，多线程复制bucket到新哈希表</strong>，容量扩容到原来的2倍</td></tr><tr><td align="left">链表插入</td><td align="left">将新节点插入到链表<strong>尾部</strong></td><td align="left">将新节点插入到链表<strong>头部</strong></td><td align="left">将新节点插入到链表<strong>尾部</strong></td></tr><tr><td align="left">继承的类</td><td align="left">继承<code>abstractMap</code>抽象类</td><td align="left">继承<code>Dictionary</code>抽象类</td><td align="left">继承<code>abstractMap</code>抽象类</td></tr><tr><td align="left">实现的接口</td><td align="left">实现<code>Map</code>接口</td><td align="left">实现<code>Map</code>接口</td><td align="left">实现<code>ConcurrentMap</code>接口</td></tr><tr><td align="left">默认容量大小</td><td align="left">16</td><td align="left">11</td><td align="left">16</td></tr><tr><td align="left">默认负载因子</td><td align="left">0.75</td><td align="left">0.75</td><td align="left">0.75</td></tr><tr><td align="left">统计size方式</td><td align="left">直接返回成员变量<code>size</code></td><td align="left">直接返回成员变量<code>count</code></td><td align="left">遍历<code>CounterCell</code>数组的值进行累加，最后加上<code>baseCount</code>的值即为<code>size</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Map </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap实现原理及源码阅读</title>
      <link href="/2020/05/02/Java/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2020/05/02/Java/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="重点概念"><a href="#重点概念" class="headerlink" title="重点概念"></a>重点概念</h2><ul><li>底层数据结构</li><li>hash冲突解决</li><li>1.7和1.8区别</li><li>扩容机制（为什么是2倍）</li><li>rehash过程</li><li>红黑树的左右旋</li></ul><h2 id="一、底层数据结构"><a href="#一、底层数据结构" class="headerlink" title="一、底层数据结构"></a>一、底层数据结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 初始容量16  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">//最大容量  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;<span class="comment">//填充比，占满0.75进行resize</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 链表长度达到8时将链表转换为红黑树 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;   <span class="comment">// 树大小为6，就转回链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;  </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;<span class="comment">//存储元素的数组  </span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;  </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;<span class="comment">//存放元素的个数  </span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;<span class="comment">//被修改的次数fast-fail机制  </span></span><br><span class="line">    <span class="keyword">int</span> threshold;<span class="comment">//临界值 当实际大小(容量*填充比)超过临界值时，会进行扩容   </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;<span class="comment">//填充比</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.位桶数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;k,v&gt;[] table;<span class="comment">//存储（位桶）的数组&lt;/k,v&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.数组元素Node&lt;K,V&gt;实现了Entry接口</span></span><br><span class="line"><span class="comment">//Node是单向链表，它实现了Map.Entry接口  </span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  </span><br><span class="line">    <span class="keyword">final</span> K key;  </span><br><span class="line">    V value;  </span><br><span class="line">    Node&lt;k,v&gt; next;  </span><br><span class="line">    <span class="comment">//构造函数Hash值 键 值 下一个节点  </span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;k,v&gt; next) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.hash = hash;  </span><br><span class="line">        <span class="keyword">this</span>.key = key;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">        <span class="keyword">this</span>.next = next;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + = + value; &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;  </span><br><span class="line">        V oldValue = value;  </span><br><span class="line">        value = newValue;  </span><br><span class="line">        <span class="keyword">return</span> oldValue;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;  </span><br><span class="line">            Map.Entry&lt;!--?,?--&gt; e = (Map.Entry&lt;!--?,?--&gt;)o;  </span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;  </span><br><span class="line">                Objects.equals(value, e.getValue()))  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; </span>&#123;  </span><br><span class="line">    TreeNode&lt;k,v&gt; parent;  <span class="comment">// 父节点  </span></span><br><span class="line">    TreeNode&lt;k,v&gt; left; <span class="comment">//左子树  </span></span><br><span class="line">    TreeNode&lt;k,v&gt; right;<span class="comment">//右子树  </span></span><br><span class="line">    TreeNode&lt;k,v&gt; prev;    <span class="comment">// needed to unlink next upon deletion  </span></span><br><span class="line">    <span class="keyword">boolean</span> red;    <span class="comment">//颜色属性  </span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;k,v&gt; next) &#123;  </span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//返回当前节点的根节点  </span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;k,v&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;k,v&gt; r = <span class="keyword">this</span>, p;;) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)  </span><br><span class="line">                <span class="keyword">return</span> r;  </span><br><span class="line">            r = p;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200320130148608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200320130253116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>总结：1.7的hashmap是由位桶数组+链表组成，1.8之后的hashmap由位桶数组+链表+红黑树组成。其中数组指bucket数组，数组中的元素是实现了map.Entry&lt;k,v&gt;接口的Node&lt;k,v&gt;，每个Node&lt;k,v&gt;包含key，value，next指针，hash值。当put元素时会调用hashcode计算hash值，相同key而value不同的元素会发生哈希碰撞，采用拉链拉解决，将该元素插入到链表中。当<code>TREEIFY_THRESHOLD</code>&gt;8时，会转化成红黑树。</p><h3 id="1-1-构造函数"><a href="#1-1-构造函数" class="headerlink" title="1.1 构造函数"></a>1.1 构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数1  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//指定的初始容量非负  </span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Illegal initial capacity:  +  </span><br><span class="line">                                           initialCapacity);  </span><br><span class="line">    <span class="comment">//如果指定的初始容量大于最大容量,置为最大容量  </span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)  </span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;  </span><br><span class="line">    <span class="comment">//填充比为正  </span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Illegal load factor:  +  </span><br><span class="line">                                           loadFactor);  </span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;  </span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//新的扩容临界值  </span></span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="comment">//构造函数2  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="comment">//构造函数3  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted  </span></span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="comment">//构造函数4用m的元素初始化散列映射  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;!--? extends K, ? extends V--&gt; m)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;  </span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、存取机制"><a href="#二、存取机制" class="headerlink" title="二、存取机制"></a>二、存取机制</h2><p>在明白它是怎么取之前需要先明白是怎么存的</p><h3 id="2-1-put-K-key-V-value"><a href="#2-1-put-K-key-V-value" class="headerlink" title="2.1 put(K key, V value)"></a>2.1 put(K key, V value)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value 元素已经存在，是否改变现值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode. 区别通过put添加还是创建时初始化数据的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,  </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] tab;   </span><br><span class="line">    Node&lt;K,V&gt; p;   </span><br><span class="line">    <span class="keyword">int</span> n, i;  </span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">// 空表，需要初始化</span></span><br><span class="line">            n = (tab = resize()).length; <span class="comment">// resize()不仅用来调整大小，还用来进行初始化配置 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*如果table的在（n-1）&amp;hash的值是空，就新建一个节点插入在该位置*/</span> </span><br><span class="line">    <span class="comment">// （n-1）&amp;hash相当于hash%(n-1)</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)  </span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);  </span><br><span class="line">    <span class="comment">/*表示有冲突,该位置已存值，开始处理冲突，采用拉链法或是红黑树*/</span>  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            Node&lt;K,V&gt; e;   </span><br><span class="line">        K k;  </span><br><span class="line">    <span class="comment">/*检查第一个Node，p是不是要找的值*/</span>  </span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">                e = p;  <span class="comment">//已存在就记住该位置</span></span><br><span class="line">            <span class="comment">/*如果不是，判断第一个元素是链表元素还是红黑树头结点*/</span>  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//按红黑树方式插入</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);  </span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">// 遍历链表插入链尾</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;  </span><br><span class="line">        <span class="comment">/*指针为空就挂在后面*/</span>  </span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);  </span><br><span class="line">             <span class="comment">//如果冲突的节点数已经达到8个，看是否需要改变冲突节点的存储结构，  </span></span><br><span class="line">　　　　　　　　　　　　<span class="comment">//treeifyBin首先判断当前hashMap的长度，如果不足64，只进行  </span></span><br><span class="line">                        <span class="comment">//resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树  </span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                            treeifyBin(tab, hash);  </span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">        <span class="comment">/*找到了对应元素，就可以停止*/</span>  </span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                    <span class="comment">// 继续向后</span></span><br><span class="line">                    p = e;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">    <span class="comment">/*就是链表上有相同的key值，修改元素值*/</span>  </span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key，就是key的Value存在  </span></span><br><span class="line">                V oldValue = e.value;  </span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)  </span><br><span class="line">                    e.value = value;  </span><br><span class="line">                afterNodeAccess(e);  </span><br><span class="line">                <span class="keyword">return</span> oldValue;<span class="comment">//返回存在的Value值  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ++modCount;  <span class="comment">// 修改次数+1</span></span><br><span class="line">     <span class="comment">/*如果当前大小大于门限，门限原本是初始容量*0.75*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)  </span><br><span class="line">            resize();<span class="comment">//扩容两倍  </span></span><br><span class="line">        afterNodeInsertion(evict);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面简单说下添加键值对put(key,value)的过程：</p><ol><li><p>判断位桶数组是否为空数组，是则通过resize初始化</p></li><li><p>通过hash(key)计算hash值判断该Node&lt;k,v&gt;应该插入的位置(不同的key可能有相同的hashcode)</p></li><li><p>如果该位置还没插入值，则直接插入；如果已存在值</p><ul><li>判断key是否相同，是：则用e记录该结点；</li><li>否：则判断table[i]是否为树结点，<ul><li>是：则以红黑树的方式插入，用e记录；</li><li>否：则遍历链表插入到链尾（如果长度&gt;8转成红黑树)；遇到已存该元素的情况下，用e记录，并退出</li></ul></li></ul></li><li><p>在上述步骤中，都有用e记录了数组中或链表或红黑树已存在该元素的信息。通过修改e来覆盖原值</p></li><li><p>判断加入结点后是否超过门限值，是否需要扩容</p></li></ol><p><img src="/" class="lazyload" data-src="https://img2018.cnblogs.com/blog/1677914/201907/1677914-20190708102644222-1828130118.png"  alt=""></p><h4 id="2-1-1-hash-方法与hashcode-方法"><a href="#2-1-1-hash-方法与hashcode-方法" class="headerlink" title="2.1.1 hash()方法与hashcode()方法"></a>2.1.1 hash()方法与hashcode()方法</h4><p>我们通过hash方法计算索引，得到数组中保存的位置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到HashMap中的hash算法是<strong>通过key的hashcode值与其hashcode右移16位后得到的值进行异或运算</strong>得到的，那么为什么不直接使用key.hashCode()，而要进行异或操作？我们知道hash的目的是为了得到进行索引，而hash是有可能冲突的，也就是不同的key得到了同样的hash值，这样就很容易产业碰撞，如何减少这种情况的发生呢，就通过上述的hash(Object key)算法将hashcode 与 hashcode的低16位做异或运算，混合了高位和低位得出的最终hash值，冲突的概率就小多了</p><h4 id="2-1-2-Fail-Fast-机制"><a href="#2-1-2-Fail-Fast-机制" class="headerlink" title="2.1.2 Fail-Fast 机制"></a>2.1.2 Fail-Fast 机制</h4><p>我们知道 java.util.HashMap 不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，对HashMap 内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的 expectedModCount。在迭代过程中，判断 modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了 Map：注意到 modCount 声明为 volatile，保证线程之间修改的可见性。</p><p>所以在这里和大家建议，当大家遍历那些非线程安全的数据结构时，尽量使用迭代器</p><h3 id="2-2-get-key"><a href="#2-2-get-key" class="headerlink" title="2.2 get(key)"></a>2.2 get(key)</h3><p>通过put过程，我们已经知道Node(k,v)是怎么保存到map中的，现在来看看怎么取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">    Node&lt;K,V&gt; e;  </span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 该key的hash值和key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] tab;<span class="comment">//Entry对象数组  </span></span><br><span class="line">    Node&lt;K,V&gt; first,e; <span class="comment">//在tab数组中经过散列的第一个位置  </span></span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    K k;  </span><br><span class="line">    <span class="comment">/*找到插入的第一个Node，方法是hash值和n-1相与，tab[(n - 1) &amp; hash]*/</span>  </span><br><span class="line">    <span class="comment">//也就是说在一条链上的hash值相同的  </span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="comment">/*检查第一个Node是不是要找的Node*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node  </span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//判断条件是hash值要相同，key值要相同  </span></span><br><span class="line">            <span class="keyword">return</span> first;  </span><br><span class="line">        <span class="comment">/*检查first后面的node*/</span>  </span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)  </span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);  </span><br><span class="line">            <span class="comment">/*遍历后面的链表，找到key值和hash值都相同的Node*/</span>  </span><br><span class="line">            <span class="keyword">do</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">                    <span class="keyword">return</span> e;  </span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过hash(key)找到bucket数组中该hash值的位置，判断该位置的元素也就是first的key是否与要找的这个key相同<ul><li>是：则返回该first元素</li><li>否：判断first是否是树节点<ul><li>是：则通过红黑树的方式进行查找</li><li>否：遍历链表查找到key相同的Node并返回</li></ul></li></ul></li><li>如果没找到，则返回null</li></ol><h3 id="2-3-面试题"><a href="#2-3-面试题" class="headerlink" title="2.3 面试题"></a>2.3 面试题</h3><h4 id="2-3-1-hashcode-与equals-区别"><a href="#2-3-1-hashcode-与equals-区别" class="headerlink" title="2.3.1 hashcode()与equals()区别"></a>2.3.1 hashcode()与equals()区别</h4><p>get()查找元素的过程：计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p><p>Object的equals()是基于比较内存地址实现的，hashcode()是比较内存地址的hash值</p><p>在map中，hashcode(实际是hash方法，封装了hashcode和低16位异或运算)用来计算key应该放在数组中的哪个位置，equals是用在有多个hashcode相同的情况下查找需要的key。</p><h4 id="2-3-2-为什么要重写equals-方法？"><a href="#2-3-2-为什么要重写equals-方法？" class="headerlink" title="2.3.2 为什么要重写equals()方法？"></a>2.3.2 为什么要重写equals()方法？</h4><p>因为object中的equals()方法比较的是对象的引用地址是否相等，如何你需要判断对象里的内容是否相等，则需要重写equals()方法。</p><h4 id="2-3-3-为什么改写了equals-，也需要改写hashcode"><a href="#2-3-3-为什么改写了equals-，也需要改写hashcode" class="headerlink" title="2.3.3 为什么改写了equals()，也需要改写hashcode()"></a>2.3.3 为什么改写了equals()，也需要改写hashcode()</h4><p>如果你重载了equals，比如说是基于对象的内容实现的，而保留hashCode的实现（基于内存地址的hash值）不变，那么在添加进map中时需要比对hashcode，很可能某两个对象明明是“相等”，而hashCode却不一样。</p><h4 id="2-3-4-为什么改写了hashcode-，也需要改写equals"><a href="#2-3-4-为什么改写了hashcode-，也需要改写equals" class="headerlink" title="2.3.4 为什么改写了hashcode()，也需要改写equals()"></a>2.3.4 为什么改写了hashcode()，也需要改写equals()</h4><p>Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写。</p><p>在改写equals方法的时候，需要满足以下三点：<br>(1) 自反性：就是说a.equals(a)必须为true。<br>(2) 对称性：就是说a.equals(b)=true的话，b.equals(a)也必须为true。<br>(3) 传递性：就是说a.equals(b)=true，并且b.equals(c)=true的话，a.equals(c)也必须为true。<br>通过改写key对象的equals和hashcode方法，我们可以将任意的业务对象作为map的key(前提是你确实有这样的需要)。</p><h2 id="三、扩容机制"><a href="#三、扩容机制" class="headerlink" title="三、扩容机制"></a>三、扩容机制</h2><p>当hashmap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16\</em>0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大为原来2倍，然后重新调用hash方法找到新的bucket位置。</p><h3 id="3-1-resize"><a href="#3-1-resize" class="headerlink" title="3.1 resize()"></a>3.1 resize()</h3><p><strong>jdk1.7的源码</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建一个新的 Hash Table</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将 Old Hash Table 上的数据迁移到 New Hash Table 上</span></span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迁移数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//下面这段代码的意思是：</span></span><br><span class="line">    <span class="comment">//  从OldTable里摘一个元素出来，然后放到NewTable中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迁移过程：</p><p><strong>单线程</strong>下的迁移：在扩容之后，重新计算hash定位到新数组中，相同hash值的元素照样连接成链表，只是链表相对位置进行了反转。</p><p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/7557373-04a86c08537518e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/623/format/webp"  alt=""></p><p><strong>多线程</strong>下的迁移：</p><p>线程1在获取next结点之后被挂起，Thread 1 的 e 指向了 key(3)，而 next 指向了 key(7)。线程2顺利完成rehash过程，链表反转。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next; <span class="comment">//  假设线程一执行到这里就被调度挂起了</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">    e.next = newTable[i];</span><br><span class="line">    newTable[i] = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/7557373-11c54ec1d172a3b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/616/format/webp"  alt=""></p><p>线程1继续执行，仍会把线程二的新表当成原始的hash表，将原来e指向的key(3)节点当成是线程二中的key(3)，放在自己所建newTable[3]的头节点，线程1的next仍然指向key(7)，此时key(3)的next已经是null。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e.next = newTable[i];<span class="comment">// key(3)的 next 指向了线程1的新 Hash 表，因为新 Hash 表为空，所以e.next = null</span></span><br><span class="line">newTable[i] = e;<span class="comment">// 线程1的新 Hash 表第一个元素指向了线程2新 Hash 表的 key(3)。e 处理完毕</span></span><br><span class="line">e = next;<span class="comment">// 将 e 指向 next，所以新的 e 是 key(7)</span></span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/7557373-b0fa15a9e28d9040.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/591/format/webp"  alt=""></p><p>线程1的e指向了上一次循环的next，也就是key(7)，此时key(7)的next已经是key(3)。将key(7)插入到table[0]的头节点，并且将key(7)的next设置为key(3), e 和next继续往下移。此时仍然没有问题。</p><p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/7557373-b1cf3d84815cecf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/627/format/webp"  alt=""></p><p>继续下一次循环，e.next = newTable[i] 导致 key(3).next 指向了 key(7)，但此时的 key(7).next 已经指向了 key(3)， 环形链表就这样出现了。</p><p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/7557373-6917fd770bbb5a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/623/format/webp"  alt=""></p><p><strong>jdk1.8的源码</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//以前的容量大于0，也就是hashMap中已经有元素了，或者new对象的时候设置了初始容量</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果以前的容量大于限制的最大容量1&lt;&lt;30,则设置临界值为int的最大值2^31-1</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果以前容量的2倍小于限制的最大容量，同时大于或等于默认的容量16，则设置临界值为以前临界值的2</span></span><br><span class="line"><span class="comment">         * 倍，因为threshold = loadFactor*capacity，capacity扩大了2倍，loadFactor不变，</span></span><br><span class="line"><span class="comment">         * threshold自然也扩大2倍。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在HashMap构造器Hash(int initialCapacity, float loadFactor)中有一句代码，this.threshold  </span></span><br><span class="line"><span class="comment">     * = tableSizeFor(initialCapacity)， 表示在调用构造器时，默认是将初始容量暂时赋值给了</span></span><br><span class="line"><span class="comment">     * threshold临界值，因此此处相当于将上一次的初始容量赋值给了新的容量。什么情况下会执行到这句？当调用  </span></span><br><span class="line"><span class="comment">     * 了HashMap(int initialCapacity)构造器，还没有添加元素时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用了默认构造器，初始容量没有设置，因此使用默认容量DEFAULT_INITIAL_CAPACITY（16），临界值</span></span><br><span class="line"><span class="comment">     * 就是16*0.75</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对临界值做判断，确保其不为0，因为在上面第二种情况(oldThr &gt; 0)，并没有计算newThr</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">/**构造新表，初始化表中数据*/</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//将刚创建的新表赋值给table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历将原来table中的数据放到扩容后的新表中来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//没有链表Node节点，直接放到新的table中下标为[e.hash &amp; (newCap - 1)]位置即可</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果是treeNode节点，则树上的节点放到newTab中</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//如果e后面还有链表节点，则遍历e所在的链表，</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 保证顺序</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">//记录下一个节点</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * newTab的容量是以前旧表容量的两倍,因为数组table下标并不是根据循环逐步递增</span></span><br><span class="line"><span class="comment">                         * 的，而是通过（table.length-1）&amp; hash计算得到，因此扩容后，存放的位置就</span></span><br><span class="line"><span class="comment">                         * 可能发生变化，那么到底发生怎样的变化呢，就是由下面的算法得到.</span></span><br><span class="line"><span class="comment">                         *</span></span><br><span class="line"><span class="comment">                         * 通过e.hash &amp; oldCap来判断节点位置通过再次hash算法后，是否会发生改变，如</span></span><br><span class="line"><span class="comment">                         * 果为0表示不会发生改变，如果为1表示会发生改变。到底怎么理解呢，举个例子：</span></span><br><span class="line"><span class="comment">                         * e.hash = 13 二进制：0000 1101</span></span><br><span class="line"><span class="comment">                         * oldCap = 32 二进制：0001 0000</span></span><br><span class="line"><span class="comment">                         *  &amp;运算：  0  二进制：0000 0000</span></span><br><span class="line"><span class="comment">                         * 结论：元素位置在扩容后不会发生改变</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * e.hash = 18 二进制：0001 0010</span></span><br><span class="line"><span class="comment">                         * oldCap = 32 二进制：0001 0000</span></span><br><span class="line"><span class="comment">                         * &amp;运算：  32 二进制：0001 0000</span></span><br><span class="line"><span class="comment">                         * 结论：元素位置在扩容后会发生改变，那么如何改变呢？</span></span><br><span class="line"><span class="comment">                         * newCap = 64 二进制：0010 0000</span></span><br><span class="line"><span class="comment">                         * 通过(newCap-1)&amp;hash</span></span><br><span class="line"><span class="comment">                         * 即0001 1111 &amp; 0001 0010 得0001 0010，32+2 = 34</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 若(e.hash &amp; oldCap) == 0，下标不变，将原表某个下标的元素放到扩容表同样</span></span><br><span class="line"><span class="comment">                         * 下标的位置上</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 若(e.hash &amp; oldCap) != 0，将原表某个下标的元素放到扩容表中</span></span><br><span class="line"><span class="comment">                         * [下标+增加的扩容量]的位置上</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><p>如果table == null, 则为HashMap的初始化, 生成空table返回即可;</p></li><li><p>如果table不为空, 需要重新计算table的长度, newLength = oldLength &lt;&lt; 1(注, 如果原oldLength已经到了上限, 则newLength = oldLength);</p></li><li><p>遍历oldTable，oldTable[i]为空，遍历下一个</p><ul><li>否：判断oldTable[i].next是否为空<ul><li>是：存放到newTable中newTab[<code>e.hash &amp; (newCap - 1</code>)]</li><li>否：判断是否红黑树<ul><li>是：走红黑树的重定位</li><li>否：<strong>JAVA7时还需要重新计算hash位, 但是JAVA8做了优化, 通过<code>(e.hash &amp; oldCap)</code>== 0来判断节点位置通过再次hash算法后，是否会发生改变</strong><ul><li>是：移动到当前hash槽位 + oldCap的位置</li><li>否：移动到新表中原下标的位置</li></ul></li></ul></li></ul></li></ul></li></ol><p><strong>注：newCap/oldCap为容量</strong></p><h2 id="四、面试题"><a href="#四、面试题" class="headerlink" title="四、面试题"></a>四、面试题</h2><h3 id="4-1-扩容为什么是2倍？"><a href="#4-1-扩容为什么是2倍？" class="headerlink" title="4.1 扩容为什么是2倍？"></a>4.1 扩容为什么是2倍？</h3><p>主要与HashMap计算添加元素的位置时，使用的位运算有关，这是特别高效的运算；HashMap的初始容量是2的n次幂，扩容也是2倍的形式进行扩容，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502144909.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502145124.png"  alt=""></p><h3 id="4-2-为什么String-Interger这样的wrapper类适合作为键？"><a href="#4-2-为什么String-Interger这样的wrapper类适合作为键？" class="headerlink" title="4.2 为什么String, Interger这样的wrapper类适合作为键？"></a>4.2 为什么String, Interger这样的wrapper类适合作为键？</h3><p>如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能，也就适合做Hashmap的键。因为获取对象的时候要用到equals()和hashCode()方法，键对象正确的重写这两个方法是非常重要的。<br>因此，String，Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。<strong>不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象</strong></p><h3 id="4-3-线程不安全的原因"><a href="#4-3-线程不安全的原因" class="headerlink" title="4.3 线程不安全的原因"></a>4.3 线程不安全的原因</h3><p>HashMap在并发场景下可能存在以下问题：</p><p><strong>死循环</strong>：在jdk1.7中，resize过程中，从旧数组重新迁移至新数组的过程中，仍可能会发生hash冲突，形成链表，链表的相对位置发生了反转，那么在并发环境下，容易出现多线程同时resize的情况，那么就有可能在迁移过程中发生闭环，一旦发生闭环，进行get()操作的时候就会陷入死循环。在jdk1.8中，用 head 和 tail 来保证链表的顺序和之前一样，因此不会出现发生闭环的情况。</p><p><strong>数据丢失</strong>：</p><ol><li><p>如果多个线程同时使用 put 方法添加元素，而且假设正好存在两个 put 的 key 发生了碰撞（根据 hash 值计算的 bucket 一样），那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程 put 的数据被覆盖</p></li><li><p>如果多个线程同时检测到元素个数超过数组大小 * loadFactor，这样就会发生多个线程同时对 Node 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失</p></li></ol><h3 id="4-4-你了解重新调整HashMap大小存在什么问题吗？"><a href="#4-4-你了解重新调整HashMap大小存在什么问题吗？" class="headerlink" title="4.4 你了解重新调整HashMap大小存在什么问题吗？"></a>4.4 你了解重新调整HashMap大小存在什么问题吗？</h3><p>Jdk1.7 当多线程的情况下，可能产生条件竞争(race condition)。</p><p>当重新调整HashMap大小的时候，如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调 整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部， 这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。</p><p><strong>注：尾部遍历（避免尾部遍历是为了避免在新列表插入数据时，遍历队尾的位置。因为，直接插入的效率更高。）</strong></p><p><strong>死循环的发生</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Map </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解排序算法</title>
      <link href="/2020/05/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/05/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载至<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p></blockquote><h3 id="0、算法概述"><a href="#0、算法概述" class="headerlink" title="0、算法概述"></a>0、算法概述</h3><h4 id="0-1-算法分类"><a href="#0-1-算法分类" class="headerlink" title="0.1 算法分类"></a>0.1 算法分类</h4><p>十种常见排序算法可以分为两大类：</p><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其<strong>时间复杂度不能突破O(nlogn)</strong>，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </li></ul><p><img src="/" class="lazyload" data-src="https://img2018.cnblogs.com/blog/849589/201903/849589-20190306165258970-1789860540.png"  alt="img"></p><h4 id="0-2-算法复杂度"><a href="#0-2-算法复杂度" class="headerlink" title="0.2 算法复杂度"></a>0.2 算法复杂度</h4><p><img src="/" class="lazyload" data-src="https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png"  alt="img"></p><h4 id="0-3-相关概念"><a href="#0-3-相关概念" class="headerlink" title="0.3 相关概念"></a>0.3 相关概念</h4><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。<strong>快些选堆</strong></li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机</li></ul><p>内执行时所需存储空间的度量，它也是数据规模n的函数。 </p><h3 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h4 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><strong>1.2 动图演示</strong></p><p><img src="/" class="lazyload" data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif"  alt="img"></p><h4 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**冒泡排序(加入了判断是否已经排序了的boolean变量) */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = arr.length-<span class="number">1</span>; end &gt; <span class="number">0</span>; end--)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSort = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(arr,i,i+<span class="number">1</span>);</span><br><span class="line">                isSort = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSort)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a><strong>2.2 动图演示</strong></h4><p><img src="/" class="lazyload" data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif"  alt="img">　　</p><h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;<span class="comment">/**记录后面的最小值的下标*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) <span class="comment">//注意从i+1开始</span></span><br><span class="line">            minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">        swap(arr,i,minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 算法分析</h4><p>表现最稳定的排序算法之一，因为无论什么数据进去<strong>都是O(n2)的时间复杂度</strong>，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><h3 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h4 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h4 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h4><p><img src="/" class="lazyload" data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif"  alt="img"></p><h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j-<span class="number">1</span>]; j--)</span><br><span class="line">            swap(arr,j,j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = arr[i];</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分结束之后　L = 刚好大于key(不是等于)的那个位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= L; j--)</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        arr[L] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-算法分析"><a href="#3-4-算法分析" class="headerlink" title="3.4 算法分析"></a>3.4 算法分析</h4><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><h4 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h4><p><img src="/" class="lazyload" data-src="https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif"  alt="img"></p><h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//步长为 n*3+1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(; gap &lt;= arr.length; gap = gap*<span class="number">3</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(; gap &gt; <span class="number">0</span>; gap = (gap-<span class="number">1</span>)/<span class="number">3</span>) &#123; <span class="comment">//增量序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;  <span class="comment">//从数组第gap个元素开始</span></span><br><span class="line">            <span class="keyword">int</span> key = arr[i],j;  <span class="comment">//每个元素与自己组内的数据进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span>(j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; key &lt; arr[j]; j -= gap) arr[j+gap] = arr[j];</span><br><span class="line">            arr[j+gap] = key; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h4><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p><h3 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h4 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h4><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h4 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h4><p><img src="/" class="lazyload" data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif"  alt="img"></p><h4 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arrays = &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>&#125;;</span><br><span class="line">       mergeSort(arrays, <span class="number">0</span>, arrays.length - <span class="number">1</span>);</span><br><span class="line">       System.out.println(<span class="string">" "</span> + arrays);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arrays, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果只有一个元素，那就不用排序了</span></span><br><span class="line">   <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//取中间的数，进行拆分</span></span><br><span class="line">           <span class="keyword">int</span> M = (L + R) / <span class="number">2</span>;</span><br><span class="line">           <span class="comment">//左边的数不断进行拆分</span></span><br><span class="line">           mergeSort(arrays, L, M);</span><br><span class="line">           <span class="comment">//右边的数不断进行拆分</span></span><br><span class="line">           mergeSort(arrays, M + <span class="number">1</span>, R);</span><br><span class="line">           <span class="comment">//合并</span></span><br><span class="line">           merge(arrays, L, M + <span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arrays, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//左边的数组的大小</span></span><br><span class="line">       <span class="keyword">int</span>[] leftArray = <span class="keyword">new</span> <span class="keyword">int</span>[M - L];</span><br><span class="line">       <span class="comment">//右边的数组大小</span></span><br><span class="line">       <span class="keyword">int</span>[] rightArray = <span class="keyword">new</span> <span class="keyword">int</span>[R - M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">       <span class="comment">//往这两个数组填充数据</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; M; i++) &#123;</span><br><span class="line">           leftArray[i - L] = arrays[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt;= R; i++) &#123;</span><br><span class="line">           rightArray[i - M] = arrays[i];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// arrays数组的第一个元素</span></span><br><span class="line">       <span class="keyword">int</span>  k = L;</span><br><span class="line">       </span><br><span class="line">          <span class="comment">//比较这两个数组的值，哪个小，就往数组上放</span></span><br><span class="line">       <span class="keyword">while</span> (i &lt; leftArray.length &amp;&amp; j &lt; rightArray.length) &#123;</span><br><span class="line">           <span class="comment">//谁比较小，谁将元素放入大数组中,移动指针，继续比较下一个</span></span><br><span class="line">           <span class="keyword">if</span> (leftArray[i] &lt; rightArray[j]) &#123;</span><br><span class="line">               arrays[k] = leftArray[i];</span><br><span class="line">               i++;</span><br><span class="line">               k++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               arrays[k] = rightArray[j];</span><br><span class="line">               j++;</span><br><span class="line">               k++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">//如果左边的数组还没比较完，右边的数都已经完了，那么将左边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">       <span class="keyword">while</span> (i &lt; leftArray.length) &#123;</span><br><span class="line">           arrays[k] = leftArray[i];</span><br><span class="line">           i++;</span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果右边的数组还没比较完，左边的数都已经完了，那么将右边的数抄到大数组中(剩下的都是大数字)</span></span><br><span class="line">       <span class="keyword">while</span> (j &lt; rightArray.length) &#123;</span><br><span class="line">           arrays[k] = rightArray[j];</span><br><span class="line">           k++;</span><br><span class="line">           j++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h4><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h3 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="/" class="lazyload" data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif"  alt="img"></p><h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    quickProcess(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = partition(arr, L, R);</span><br><span class="line">    quickProcess(arr, L, p - <span class="number">1</span>);</span><br><span class="line">    quickProcess(arr, p + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">* 返回p, 使得arr[L...p-1] &lt; arr[p] ; arr[p+1...R] &gt; arr[p]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接选取 arr[L]作为pivot(中心点)</span></span><br><span class="line">    <span class="keyword">int</span> key = arr[L];</span><br><span class="line">    <span class="keyword">int</span> pivot = L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt;= R; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; key)</span><br><span class="line">            swap(arr, i, ++pivot);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, L); <span class="comment">// 将arr[L]放到pivot位置(中间) --&gt; 完全了按照arr[L]划分数组的目的</span></span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h4><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h4 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h4><p><img src="/" class="lazyload" data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif"  alt="img"></p><h4 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        siftUp(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length - <span class="number">1</span>;</span><br><span class="line">    swap(arr, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        siftDown(arr, <span class="number">0</span>, size);</span><br><span class="line">        swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上浮的过程  --&gt;  把新插入的数调整为大根堆的过程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] &gt; arr[(i - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        swap(arr, i, (i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下沉的过程  --&gt;  这个函数就是一个数变小了，往下沉的函数,改变的数为index  目前的自己指定的堆的大小为heapSize</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; heapSize) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = L + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[L + <span class="number">1</span>] &gt; arr[L] ? L + <span class="number">1</span> : L;</span><br><span class="line">        maxIndex = arr[i] &gt; arr[maxIndex] ? i : maxIndex;</span><br><span class="line">        <span class="keyword">if</span> (maxIndex == i) <span class="keyword">break</span>; <span class="comment">//自己就是最大的， 不用忘下沉</span></span><br><span class="line">        <span class="comment">//否则就要一直往下沉</span></span><br><span class="line">        swap(arr, i, maxIndex);</span><br><span class="line">        i = maxIndex;</span><br><span class="line">        L = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//继续往下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h4 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h4><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h4 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h4><p><img src="/" class="lazyload" data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231740840-6968181.gif"  alt="img"></p><h4 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 计数排序   count 统计数组， tmp 目标填充数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> RANGE)</span> </span>&#123; <span class="comment">/**数组中最大的元素不能超过 RANGE*/</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[RANGE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        count[arr[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**现在的count[i]表示小于i的数有count[i]个，排序后元素i就放在第C[i]个输出位置上*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= RANGE; i++)</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)</span></span><br><span class="line"><span class="comment">         * 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        tmp[--count[arr[i]]] = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝回原来的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h4><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h3 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h4 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h4 id="9-2-图片演示"><a href="#9-2-图片演示" class="headerlink" title="9.2 图片演示"></a>9.2 图片演示</h4><p><img src="/" class="lazyload" data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232107090-1920702011.png"  alt="img"></p><h4 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> bucketNum = <span class="number">100</span>; <span class="comment">//桶的个数 0 ～ 9号桶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mapToBucket</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;   <span class="comment">// 映射函数f(x)</span></span><br><span class="line">    <span class="keyword">return</span> x / bucketNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[bucketNum];  <span class="comment">// 计数数组，存放桶的边界信息</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)  <span class="comment">//count[i]保存着i号桶中元素的个数</span></span><br><span class="line">        count[mapToBucket(arr[i])]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bucketNum; i++)  <span class="comment">// 定位桶边界初始时，count[i]-1(下标从0开始)为i号桶最后一个元素的位置</span></span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//count[0]~count[9]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        tmp[--count[mapToBucket(arr[i])]] = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        arr[i] = tmp[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用计数排序确定各个桶的边界（分桶）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> L = count[i];     <span class="comment">//count[i]为i号桶第一个元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> R = (i == bucketNum - <span class="number">1</span> ? arr.length - <span class="number">1</span> : count[i + <span class="number">1</span>] - <span class="number">1</span>); <span class="comment">//count[i+1]-1为i号桶最后一个元素的位置</span></span><br><span class="line">        <span class="comment">//for(int j = L; j &lt;= R; j++)System.out.print( arr[j] + " "); System.out.println();  //print</span></span><br><span class="line">        <span class="keyword">if</span> (L &lt; R)  <span class="comment">//对每个桶里面进行排序</span></span><br><span class="line">            Arrays.sort(arr, L, R + <span class="number">1</span>);<span class="comment">//注意这里是R+1，系统库的sort的右边界是开区间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><h3 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h4 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h4><p><img src="/" class="lazyload" data-src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232453668-1397662527.gif"  alt="img"> </p><h4 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将整形数按照每位(从低到高)拆分，然后从低位(个位)到高位依次比较各个位，得到所在的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//dn表示最大的数的位数 3位的话只能表示到999</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> dn = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得元素x的第d位数字</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] radix = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>&#125;; <span class="comment">//这里只排序总共有三位数,分别代表 个位，十位，百位</span></span><br><span class="line">    <span class="keyword">return</span> (num / radix[d]) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据数组arr中每个元素 的第d位数,来对整个arr数组排序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lsdRadixSortInfo</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];      <span class="comment">//  单独考虑每一个位的时候， 数字都是从[0~9]</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        count[getDigit(arr[i], d)]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit = getDigit(arr[i], d);  <span class="comment">//元素arr[i]当前 的d位的数字为dight</span></span><br><span class="line">        tmp[--count[digit]] = arr[i];    <span class="comment">//根据当前位数字digit来排序，把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) arr[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lsdRadixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; dn; d++) <span class="comment">//从低位(个位)到高位 按照每一位排序</span></span><br><span class="line">        lsdRadixSortInfo(arr, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h4><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown中使用flow绘制流程图</title>
      <link href="/2020/05/01/%E5%B7%A5%E5%85%B7/Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8flow%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
      <url>/2020/05/01/%E5%B7%A5%E5%85%B7/Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8flow%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>栗子1：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">out1=&gt;inputoutput: 显示系统主菜单</span><br><span class="line">op3=&gt;operation: 选择模块</span><br><span class="line"></span><br><span class="line">out4=&gt;inputoutput: 显示模块子菜单</span><br><span class="line">op5=&gt;operation: 选择功能</span><br><span class="line"></span><br><span class="line">out6=&gt;inputoutput: 输出结果</span><br><span class="line">cond7=&gt;condition: 是否继续操作</span><br><span class="line">op8=&gt;operation: 退出系统</span><br><span class="line"></span><br><span class="line">st-&gt;out1</span><br><span class="line">out1-&gt;op3-&gt;out4-&gt;op5-&gt;out6-&gt;cond7</span><br><span class="line"></span><br><span class="line">cond7(yes)-&gt;out4</span><br><span class="line">cond7(no)-&gt;op8</span><br><span class="line">op8-&gt;e</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">out1&#x3D;&gt;inputoutput: 显示系统主菜单</span><br><span class="line">op3&#x3D;&gt;operation: 选择模块</span><br><span class="line"></span><br><span class="line">out4&#x3D;&gt;inputoutput: 显示模块子菜单</span><br><span class="line">op5&#x3D;&gt;operation: 选择功能</span><br><span class="line"></span><br><span class="line">out6&#x3D;&gt;inputoutput: 输出结果</span><br><span class="line">cond7&#x3D;&gt;condition: 是否继续操作</span><br><span class="line">op8&#x3D;&gt;operation: 退出系统</span><br><span class="line"></span><br><span class="line">st-&gt;out1</span><br><span class="line">out1-&gt;op3-&gt;out4-&gt;op5-&gt;out6-&gt;cond7</span><br><span class="line"></span><br><span class="line">cond7(yes)-&gt;out4</span><br><span class="line">cond7(no)-&gt;op8</span><br><span class="line">op8-&gt;e</span><br></pre></td></tr></table></figure><p>栗子2：增加读者</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">op1=&gt;operation: 选择增加读者</span><br><span class="line">in2=&gt;inputoutput: 录入读者信息</span><br><span class="line">op3=&gt;operation: 建立链表结点</span><br><span class="line">out4=&gt;inputoutput: 录入完毕</span><br><span class="line">cond5=&gt;condition: 是否继续录入</span><br><span class="line">op6=&gt;operation: 保存链表</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;in2-&gt;op3-&gt;out4-&gt;cond5</span><br><span class="line">cond5(yes)-&gt;in2</span><br><span class="line">cond5(no)-&gt;e</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">op1&#x3D;&gt;operation: 选择增加读者</span><br><span class="line">in2&#x3D;&gt;inputoutput: 录入读者信息</span><br><span class="line">op3&#x3D;&gt;operation: 建立链表结点</span><br><span class="line">out4&#x3D;&gt;inputoutput: 录入完毕</span><br><span class="line">cond5&#x3D;&gt;condition: 是否继续录入</span><br><span class="line">op6&#x3D;&gt;operation: 保存链表</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;in2-&gt;op3-&gt;out4-&gt;cond5</span><br><span class="line">cond5(yes)-&gt;in2</span><br><span class="line">cond5(no)-&gt;e</span><br></pre></td></tr></table></figure><p>栗子3：查询读者</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">op1&#x3D;&gt;operation: 选择查询读者</span><br><span class="line">in2&#x3D;&gt;inputoutput: 录入读者证件号&#x2F;姓名</span><br><span class="line">op3&#x3D;&gt;operation: 打开文件</span><br><span class="line">op4&#x3D;&gt;operation: fscanf读数据</span><br><span class="line">cond5&#x3D;&gt;condition: 是否符合查找条件</span><br><span class="line">out6&#x3D;&gt;inputoutput: 输出结果</span><br><span class="line">op7&#x3D;&gt;operation: 关闭文件</span><br><span class="line">st-&gt;op1-&gt;in2-&gt;op3-&gt;op4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;op4</span><br><span class="line">cond5(yes)-&gt;out6-&gt;op7-&gt;e</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">op1&#x3D;&gt;operation: 选择查询读者</span><br><span class="line">in2&#x3D;&gt;inputoutput: 录入读者证件号&#x2F;姓名</span><br><span class="line">op3&#x3D;&gt;operation: 打开文件</span><br><span class="line">op4&#x3D;&gt;operation: fscanf读数据</span><br><span class="line">cond5&#x3D;&gt;condition: 是否符合查找条件</span><br><span class="line">out6&#x3D;&gt;inputoutput: 输出结果</span><br><span class="line">op7&#x3D;&gt;operation: 关闭文件</span><br><span class="line">st-&gt;op1-&gt;in2-&gt;op3-&gt;op4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;op4</span><br><span class="line">cond5(yes)-&gt;out6-&gt;op7-&gt;e</span><br></pre></td></tr></table></figure><p>栗子4：修改读者</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1&#x3D;&gt;operation: 读取文件</span><br><span class="line">op2&#x3D;&gt;operation: 建立单链表</span><br><span class="line">op3&#x3D;&gt;inputoutput: 输入证件号</span><br><span class="line">op4&#x3D;&gt;operation: 查找链表</span><br><span class="line">cond5&#x3D;&gt;condition: 是否找到</span><br><span class="line">op6&#x3D;&gt;operation: 修改记录</span><br><span class="line">op7&#x3D;&gt;operation: 保存链表</span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;e</span><br><span class="line">cond5(yes)-&gt;op6-&gt;op7-&gt;e</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1&#x3D;&gt;operation: 读取文件</span><br><span class="line">op2&#x3D;&gt;operation: 建立单链表</span><br><span class="line">op3&#x3D;&gt;inputoutput: 输入证件号</span><br><span class="line">op4&#x3D;&gt;operation: 查找链表</span><br><span class="line">cond5&#x3D;&gt;condition: 是否找到</span><br><span class="line">op6&#x3D;&gt;operation: 修改记录</span><br><span class="line">op7&#x3D;&gt;operation: 保存链表</span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;e</span><br><span class="line">cond5(yes)-&gt;op6-&gt;op7-&gt;e</span><br></pre></td></tr></table></figure><p>栗子5：浏览所有读者</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1&#x3D;&gt;operation: 读取文件</span><br><span class="line">op2&#x3D;&gt;operation: 遍历</span><br><span class="line">op3&#x3D;&gt;inputoutput: 输出读者记录</span><br><span class="line">cond4&#x3D;&gt;condition: 是否到文件尾</span><br><span class="line">op5&#x3D;&gt;operation: 退出</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;cond4-&gt;op5</span><br><span class="line">cond4(no)-&gt;op2</span><br><span class="line">cond5(yes)-&gt;op5-&gt;e</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1&#x3D;&gt;operation: 读取文件</span><br><span class="line">op2&#x3D;&gt;operation: 遍历</span><br><span class="line">op3&#x3D;&gt;inputoutput: 输出读者记录</span><br><span class="line">cond4&#x3D;&gt;condition: 是否到文件尾</span><br><span class="line">op5&#x3D;&gt;operation: 退出</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;cond4-&gt;op5</span><br><span class="line">cond4(no)-&gt;op2</span><br><span class="line">cond4(yes)-&gt;op5-&gt;e</span><br></pre></td></tr></table></figure><p>栗子6：证件挂失</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1=&gt;operation: 读取文件</span><br><span class="line">op2=&gt;operation: 建立单链表</span><br><span class="line">op3=&gt;inputoutput: 输入证件号</span><br><span class="line">op4=&gt;operation: 查找链表</span><br><span class="line">cond5=&gt;condition: 是否找到</span><br><span class="line">op6=&gt;operation: 将该记录标记为挂失</span><br><span class="line">op7=&gt;operation: 保存链表</span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;e</span><br><span class="line">cond5(yes)-&gt;op6-&gt;op7-&gt;e</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1&#x3D;&gt;operation: 读取文件</span><br><span class="line">op2&#x3D;&gt;operation: 建立单链表</span><br><span class="line">op3&#x3D;&gt;inputoutput: 输入证件号</span><br><span class="line">op4&#x3D;&gt;operation: 查找链表</span><br><span class="line">cond5&#x3D;&gt;condition: 是否找到</span><br><span class="line">op6&#x3D;&gt;operation: 将该记录标记为挂失</span><br><span class="line">op7&#x3D;&gt;operation: 保存链表</span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;e</span><br><span class="line">cond5(yes)-&gt;op6-&gt;op7-&gt;e</span><br></pre></td></tr></table></figure><hr><p>栗子7：修改分类</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1=&gt;operation: 输入分类编号</span><br><span class="line">op3=&gt;operation: 打开文件</span><br><span class="line">op4=&gt;operation: fread读数据</span><br><span class="line">cond5=&gt;condition: 是否符合查找条件</span><br><span class="line">out6=&gt;inputoutput: fseek定位</span><br><span class="line">op7=&gt;operation: fwrite修改记录</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op3-&gt;op4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;op4</span><br><span class="line">cond5(yes)-&gt;out6-&gt;op7-&gt;e</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1&#x3D;&gt;operation: 输入分类编号</span><br><span class="line">op3&#x3D;&gt;operation: 打开文件</span><br><span class="line">op4&#x3D;&gt;operation: fread读数据</span><br><span class="line">cond5&#x3D;&gt;condition: 是否符合查找条件</span><br><span class="line">out6&#x3D;&gt;inputoutput: fseek定位</span><br><span class="line">op7&#x3D;&gt;operation: fwrite修改记录</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op3-&gt;op4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;op4</span><br><span class="line">cond5(yes)-&gt;out6-&gt;op7-&gt;e</span><br></pre></td></tr></table></figure><p>栗子8：输出分类目录树</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1=&gt;operation: 打开文件</span><br><span class="line">op2=&gt;operation: 建立双亲存储结构</span><br><span class="line">out3=&gt;inputoutput: 输出根节点</span><br><span class="line">op4=&gt;operation: 检索孩子结点</span><br><span class="line">cond5=&gt;condition: 是否有孩子</span><br><span class="line">cond6=&gt;condition: 是否第一个</span><br><span class="line">op7=&gt;operation: level++</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;out3-&gt;op4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;e</span><br><span class="line">cond5(yes)-&gt;cond6</span><br><span class="line">cond6(no)-&gt;out3</span><br><span class="line">cond6(yes)-&gt;op7-&gt;out3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1&#x3D;&gt;operation: 打开文件</span><br><span class="line">op2&#x3D;&gt;operation: 建立双亲存储结构</span><br><span class="line">out3&#x3D;&gt;inputoutput: 输出根节点</span><br><span class="line">op4&#x3D;&gt;operation: 检索孩子结点</span><br><span class="line">cond5&#x3D;&gt;condition: 是否有孩子</span><br><span class="line">cond6&#x3D;&gt;condition: 是否第一个</span><br><span class="line">op7&#x3D;&gt;operation: level++</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;out3-&gt;op4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;e</span><br><span class="line">cond5(yes)-&gt;cond6</span><br><span class="line">cond6(no)-&gt;out3</span><br><span class="line">cond6(yes)-&gt;op7-&gt;out3</span><br></pre></td></tr></table></figure><p>栗子9：增加分类</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1=&gt;operation: 选择增加分类</span><br><span class="line">in2=&gt;inputoutput: 录入分类信息</span><br><span class="line">op3=&gt;operation: 以二进制录入文件</span><br><span class="line">out4=&gt;inputoutput: 录入完毕</span><br><span class="line">cond5=&gt;condition: 是否读入<span class="string">"#"</span></span><br><span class="line">op6=&gt;operation: 保存链表</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;in2-&gt;op3-&gt;out4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;in2</span><br><span class="line">cond5(yes)-&gt;e</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1&#x3D;&gt;operation: 选择增加分类</span><br><span class="line">in2&#x3D;&gt;inputoutput: 录入分类信息</span><br><span class="line">op3&#x3D;&gt;operation: 以二进制录入文件</span><br><span class="line">out4&#x3D;&gt;inputoutput: 录入完毕</span><br><span class="line">cond5&#x3D;&gt;condition: 是否读入&quot;#&quot;</span><br><span class="line">op6&#x3D;&gt;operation: 保存链表</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;in2-&gt;op3-&gt;out4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;in2</span><br><span class="line">cond5(yes)-&gt;e</span><br></pre></td></tr></table></figure><p>栗子9：删除分类</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1=&gt;operation: 输入分类编号</span><br><span class="line">op3=&gt;operation: 打开文件</span><br><span class="line">op4=&gt;operation: fread读数据</span><br><span class="line">cond5=&gt;condition: 是否符合查找条件</span><br><span class="line">out6=&gt;inputoutput: fseek定位</span><br><span class="line">op7=&gt;operation: fwrite删除记录</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op3-&gt;op4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;op4</span><br><span class="line">cond5(yes)-&gt;out6-&gt;op7-&gt;e</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line"></span><br><span class="line">op1&#x3D;&gt;operation: 输入分类编号</span><br><span class="line">op3&#x3D;&gt;operation: 打开文件</span><br><span class="line">op4&#x3D;&gt;operation: fread读数据</span><br><span class="line">cond5&#x3D;&gt;condition: 是否符合查找条件</span><br><span class="line">out6&#x3D;&gt;inputoutput: fseek定位</span><br><span class="line">op7&#x3D;&gt;operation: fwrite删除记录</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op3-&gt;op4-&gt;cond5</span><br><span class="line">cond5(no)-&gt;op4</span><br><span class="line">cond5(yes)-&gt;out6-&gt;op7-&gt;e</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记基础篇</title>
      <link href="/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="hofe.work">欢迎来我的个人网站</a>，里面有最新的版本</p><p>这篇介绍了下Mysql面试题常考内容，并做了延伸；个人觉得MVCC部分讲的应该是网上较为清楚的了。</p><p>参考：</p><p><a href="https://www.codercto.com/a/88775.html" target="_blank" rel="noopener">https://www.codercto.com/a/88775.html</a></p><p><a href="https://baijiahao.baidu.com/s?id=1629409989970483292&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1629409989970483292&amp;wfr=spider&amp;for=pc</a></p><p>如果有图片失效的情况，可能是因为我用的github图库，网站无法爬到，大家可以进入个人网站进行阅读。</p></blockquote><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>mysql 有那些存储引擎，有哪些区别（innodb 与myisam 的区别？ ）</p><p>mysql 索引在什么情况下会失效 </p><p>mysql 的索引模型 </p><p>数据库为什么用B+树。联合索引特点</p><p>可重复读是什么；</p><p>有一段代码，两个session，判断结果是什么（和重复读有关）；</p><p>数据库用什么实现可重复读。</p><h2 id="二、存储引擎"><a href="#二、存储引擎" class="headerlink" title="二、存储引擎"></a>二、存储引擎</h2><h3 id="2-1-什么是存储引擎"><a href="#2-1-什么是存储引擎" class="headerlink" title="2.1 什么是存储引擎"></a>2.1 什么是存储引擎</h3><blockquote><p>MySQL中的数据用各种不同的技术存储在文件(或者内存)中。每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p></blockquote><h3 id="2-2-存储引擎分类"><a href="#2-2-存储引擎分类" class="headerlink" title="2.2 存储引擎分类"></a>2.2 存储引擎分类</h3><p>使用<code>show engines;</code>可查看引擎种类，有<strong>MEMORY</strong>、<strong>ARCHIVE</strong>、<strong>MERGE</strong>等等，主要的是<strong>MyISAM</strong>和<strong>InnoDB</strong>。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163020.png"  alt=""></p><h3 id="2-3-MyISAM和InnoDB的区别"><a href="#2-3-MyISAM和InnoDB的区别" class="headerlink" title="2.3 MyISAM和InnoDB的区别"></a>2.3 MyISAM和InnoDB的区别</h3><ol><li><p>存储结构</p><ul><li><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。 .frm文件存储表定义，数据文件的扩展名为.MYD(MYD)，索引文件的扩展名是.MYI(MYIndex)。</p></li><li><p>InnoDB:所在的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p></li></ul></li><li><p>存储空间</p><ul><li><p>MyISAM:可被压缩，存储空间较小。支持三种不同的存储格式：静态表、动态表、压缩表。</p></li><li><p>InnoDB:需要更多的内存和存储，它会在主内存中建立其专用的<strong>缓冲池用于高速缓冲数据和索引</strong>。</p></li></ul></li><li><p>事务支持</p><ul><li><p>MyISAM:强调的是<strong>性能</strong>，每次查询具有原子性，其执行速度比Innodb类型更快，但是不提供事务支持。</p></li><li><p>InnoDB:提供事务支持。具有提交（commit）、回滚（rollback）和崩溃修复能力（crach recovery capabilities）的事务安全（transaction-safe ACID compliant）型表。</p></li></ul></li><li><p>CURD操作</p><ul><li><p>MyISAM: 如果执行大量的select, MyISAM是更好的选择。（因为没有支持行级锁），在增删的时候需要锁定整个表格，效率会低一些。</p></li><li><p>InnoDB:如果你的数据执行大量的insert或update，出于性能方面的考虑，应该使用InnoDB表。innoDB支持行级锁，删除插入的时候只需要锁定该行就行，效率较高。但delete from table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p></li></ul></li><li><p>外键</p><ul><li><p>MyISAM: 不支持。</p></li><li><p>InoDB:支持。</p></li></ul></li><li><p>索引</p><ul><li><p>MyISAM:采用<strong>非聚集索引</strong>，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是<strong>辅索引不用保证唯一性</strong>。支持全文索引和空间索引。</p></li><li><p>InnoDB:主键索引采用<strong>聚集索引</strong>（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问主键索引。</p></li></ul></li></ol><h2 id="三、索引"><a href="#三、索引" class="headerlink" title="三、索引"></a>三、索引</h2><h3 id="3-1-索引是什么"><a href="#3-1-索引是什么" class="headerlink" title="3.1 索引是什么"></a>3.1 索引是什么</h3><p>索引(Index)是帮助MySQL高效获取数据的数据结构。可以简单理解为：<strong>快速查找排好序的一种数据结构</strong>，可以提高数据检索的效率，降低数据库的IO成本</p><h4 id="3-1-1为什么要使用索引"><a href="#3-1-1为什么要使用索引" class="headerlink" title="3.1.1为什么要使用索引"></a>3.1.1为什么要使用索引</h4><p>查询数据时需要从磁盘中全表扫描读取数据，会遇上两个问题</p><ul><li>数据量过大的时候，从磁盘中读数据到内存，内存是否有足够容量存放</li><li>如果表非常大，那么我们不可能一次将所有的数据读到内存，需要分多次读取磁盘，而操作磁盘相对于内存来说是一个非常耗时的操作</li></ul><p><strong>优点</strong>：</p><ol><li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性</li><li>大大加快数据的查询速度</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li></ol><p><strong>缺点</strong>：</p><ol><li><p>创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加</p></li><li><p>索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值</p></li><li><p>当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。</p></li></ol><p><strong>使用原则</strong>：</p><p>通过上面说的优点和缺点，我们应该可以知道，并不是每个字段都设置索引就好，也不是索引越多越好，而是需要自己合理的使用。</p><p><strong>加在哪些列上？</strong></p><ol><li>在经<strong>常需要搜索的列</strong>上，可以加快搜索的速度；</li><li>在作为<strong>主键的列</strong>上，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在<strong>连接</strong>的列上，这些列主要是一些外键，可以加快连接的速度；</li><li>在经常需要根据<strong>范围进行搜索</strong>的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常需要<strong>排序的列</strong>上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>在经常使用在<strong>WHERE子句中的列</strong>上面创建索引，加快条件的判断速度</li></ol><p><strong>不该加在哪些列上？</strong></p><ol><li><p>对于那些在<strong>查询中很少使用</strong>或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p></li><li><p>对于那些只有<strong>很少数据值的列</strong>也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p></li><li><p>第三，对于那些定义为<strong>text, image和bit数据类型</strong>的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p></li><li><p>第四，当<strong>修改性能远远大于检索性能时，不应该创建索引</strong>。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p></li></ol><h3 id="3-2-索引分类"><a href="#3-2-索引分类" class="headerlink" title="3.2 索引分类"></a>3.2 索引分类</h3><p>按照<strong>索引形式</strong>不同可以分为：</p><ul><li><p>普通索引：仅加速查询</p></li><li><p>唯一索引：加速查询 + 列值唯一（可以有null）</p></li><li><p>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</p></li><li><p>全文索引：对文本的内容进行分词，进行搜索</p></li><li><p>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于<strong>索引合并</strong></p></li></ul><p>按照<strong>索引实现方式</strong>不同可以分为：</p><table><thead><tr><th></th><th>描述</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td>B+ Tree索引</td><td>使用B+ Tree作为底层实现</td><td>对树进行搜索，查找速度快分为聚簇索引和非聚簇索引</td><td>查找、排序、分组</td></tr><tr><td>哈希索引</td><td>使用哈希作为底层实现</td><td>无法用于排序与分组只支持精确查找，时间复杂度为O(1)</td><td>当索引值使用的频繁时，会在B+ Tree索引之上再创建一个哈希索引</td></tr><tr><td>全文索引</td><td>全文索引使用倒排索引实现，记录着关键词到其所在文档的映射</td><td></td><td>查找文本中的关键词</td></tr><tr><td>空间索引</td><td></td><td>从所有维度来索引数据</td><td>用于地理数据存储</td></tr></tbody></table><h3 id="3-3-索引数据结构"><a href="#3-3-索引数据结构" class="headerlink" title="3.3 索引数据结构"></a>3.3 索引数据结构</h3><p>数据库<strong>索引是存储在磁盘</strong>上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应<strong>索引树的节点</strong>）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。</p><p>通过对比各种数据结构的特点，可以回答为什么要用B+Tree作为数据库的索引的问题</p><p><strong>和其他数据结构对比来看</strong>：</p><p>二叉搜索树：如果数据是单边增长的情况，那么出现的就是和链表一样的数据结构了，树高度大。</p><p>红黑树：在二叉树的基础上多了树平衡，也叫二叉平衡树，不像二叉树那样极端的情况会往一个方向发展，但数据量大的话，红黑树的深度会很深，也就是说深度不可控，这样一来查找数据还是会很耗时。</p><p>Hash表：通过hash函数计算出数据映射位置，相比较于红黑树，hash可以固定“深度”，且映射到磁盘存储引用，但是 hash 还是有些不足：只能用于精确查找的场景，无法进行范围查询。</p><p>BTree：每个节点是一个二元数组，存放着key，value， 从左到右递增排列。节点之间存放着指向这相应区间范围内的节点。然而也存在着一些缺陷：</p><ol><li>在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。造成IO操作频繁。</li><li>区间查找可能需要返回上层节点重复遍历，IO操作繁琐。</li></ol><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163215.png"  alt=""></p><p>B+Tree：非叶子结点不存储data，只存储索引（减小内存占用，这样可以多读入一些节点）</p><p>叶子结点包含所有索引字段，存放所有的data</p><p>叶子结点用指针连接，提高区间访问的性能（不用回到上层节点再往下找）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163232.png"  alt=""></p><p>b+树相比于b树的查询优势：</p><ol><li>一次IO只能加载一个磁盘页（对应一个节点），b树的节点是由key,data组成的，而b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，可以使得树更加矮胖；</li><li>b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；</li><li>对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历，如下两图：</li></ol><p>总结：B+Tree 既减少查询次数又提供了很好的范围查询</p><h3 id="3-4-MyISAM和InnoDB索引实现"><a href="#3-4-MyISAM和InnoDB索引实现" class="headerlink" title="3.4 MyISAM和InnoDB索引实现"></a>3.4 MyISAM和InnoDB索引实现</h3><p>索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的。它们实现的都是<strong>B+Tree索引模型</strong></p><h4 id="3-4-1-MyISAM实现"><a href="#3-4-1-MyISAM实现" class="headerlink" title="3.4.1 MyISAM实现"></a>3.4.1 MyISAM实现</h4><p>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</p><ul><li><p>MyISAM的主索引图：索引文件的每个<strong>数据域存储指向数据文件的指针</strong>(每个索引指向了数据地址)</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163301.png"  alt=""></p></li><li><p>MyISAM的辅索引：索引文件的<strong>每个数据域存储指向数据文件的指针</strong>(每个索引指向了数据地址)，辐索引不用保证唯一性。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163331.png"  alt=""></p></li></ul><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分</p><h4 id="3-4-2-InnoDB实现"><a href="#3-4-2-InnoDB实现" class="headerlink" title="3.4.2 InnoDB实现"></a>3.4.2 InnoDB实现</h4><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，<strong>表数据文件本身就是按B+Tree组织的一个索引结构</strong>，这棵树的叶结点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p>Innodb的主索引图: <strong>叶子节点存储数据本身</strong></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163412.png"  alt=""></p><p>Innodb的辐索引图: <strong>叶子结点存储主键的值</strong>。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163434.png"  alt=""></p><h3 id="3-5-其他关于索引的问题"><a href="#3-5-其他关于索引的问题" class="headerlink" title="3.5 其他关于索引的问题"></a>3.5 其他关于索引的问题</h3><p><strong>主键索引三问</strong>：</p><ul><li><p>为什么非主键索引结构叶子节点存储的是主键值？</p><p>一是保证一致性，更新数据的时候只需要更新主键索引树；二是节省存储空间。</p></li><li><p>为什么推荐InnoDB表必须有主键？</p><p>保证会有主键索引树的存在（因为数据存放在主键索引树上面），如果没有mysql会自己生成一个rowid作为自增的主键主键索引</p></li><li><p>为什么推荐使用整型的自增主键？</p><p>一是方便查找比较，二是新增数据的时候只需要在最后加入，不会大规模调整树结构，如果是UUID的话，大小不好比较，新增的时候也极有可能在中间插入数据，会导致树结构大规调整，造成插入数据变慢。</p></li></ul><p><strong>索引合并</strong>：使用多个单列索引组合搜索</p><p><strong>索引覆盖</strong>：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖</p><p><strong>索引下推</strong>：如果没有索引下推优化（或称ICP优化），当进行索引查询时，首先根据索引来查找记录，然后再根据where条件来过滤记录；在支持ICP优化后，MySQL会在取出索引的同时，判断是否可以进行where条件过滤，也就是说提前执行where的部分过滤操作，在某些场景下，可以大大减少回表次数，从而提升整体性能。</p><p>对于user_table表，我们现在有（username,age）联合索引<br> 如果现在有一个需求，查出名称中以“张”开头且年龄小于等于10的用户信息，语句C如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">and</span> age &gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><p> 语句C有两种执行可能：</p><ol><li><p>根据（username,age）联合索引查询所有满足名称以“张”开头的索引，然后回表查询出相应的全行数据，然后再筛选出满足年龄小于等于10的用户数据。</p></li><li><p>根据（username,age）联合索引查询所有满足名称以“张”开头的索引，然后直接再筛选出年龄小于等于10的索引，之后再回表查询全行数据。</p></li></ol><p>明显的，第二种方式需要回表查询的全行数据比较少，这就是mysql的索引下推</p><p>注意点：<br> 1、innodb引擎的表，索引下推只能用于二级索引。</p><blockquote><p>就像之前提到的，innodb的主键索引树叶子结点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。</p></blockquote><p>2、索引下推一般可用于所求查询字段（select列）不是/不全是联合索引的字段，查询条件为多条件查询且查询条件子句（where/order by）字段全是联合索引。</p><blockquote><p>假设表t有联合索引（a,b）,下面语句可以使用索引下推提高效率<br> select * from t where a &gt; 2 and b &gt; 10;</p></blockquote><p><strong>索引失效</strong></p><ol><li>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</li><li>使用查询的时候遵循mysql组合索引的”<strong>最左前缀</strong>“规则，假设现在有组合索引（a，b，c），查询语句就只能是<code>a=1</code>或<code>a=1and b=1</code>或<code>a=1 and b=1 and c=1</code>。这里有两点需要注意<ul><li><code>a=1 and b=1</code>和<code>b=1 and a=1</code>一样，没有区别，都会使用索引。<code>b = 1</code>和<code>b = 1 and c=1</code>无法使用索引</li><li>组合索引（a，b，c）的最左前缀是a；组合索引（c，b，a）的最左前缀是c，最左前缀和表字段顺序无关。在组合索引中，如果where查询条件中某个列使用了范围查询（不管%在哪），则其右边的所有列都无法使用索引优化查询</li></ul></li><li>like查询以%开头</li><li>如果<strong>列类型是字符串，那一定要在条件中将数据使用引号引用</strong>起来,否则不使用索引</li><li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li><li>需要将打算加索引的列设置为 not  NULL，否则将导致引擎放弃使用索引而进行全表扫描。</li><li><strong>索引列不能是表达式的一部分，也不能作为函数的参数</strong>，否则无法使用索引查询</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_test <span class="keyword">WHERE</span> user_name = <span class="keyword">concat</span>(user_name, <span class="string">'fei'</span>);</span><br></pre></td></tr></table></figure><h2 id="四、事务"><a href="#四、事务" class="headerlink" title="四、事务"></a>四、事务</h2><h3 id="4-1-特性ACID"><a href="#4-1-特性ACID" class="headerlink" title="4.1 特性ACID"></a>4.1 特性ACID</h3><p>原子性(Atomicity)：指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做</p><p>一致性(Consistency)：事务使得系统从一个一致的状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度，也导致了事务的不同隔离级别。</p><p>隔离性(Isolation)：事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><p>持久性(Durability)：事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p><h3 id="4-2-实现原理"><a href="#4-2-实现原理" class="headerlink" title="4.2 实现原理"></a>4.2 实现原理</h3><p><strong>首先思考事务想要做到什么效果？</strong></p><p>按我理解，无非是要做到<strong>可靠性</strong>以及<strong>并发处理</strong></p><p>可靠性：数据库要保证当insert或update操作时抛异常或者数据库crash的时候需要保障数据的操作前后的一致，想要做到这个，我需要知道我修改之前和修改之后的状态，所以就有了undo log和redo log。</p><p>并发处理：也就是说当多个并发请求过来，并且其中有一个请求是对数据修改操作的时候会有影响，为了避免读到脏数据，所以需要对事务之间的读写进行隔离，至于隔离到啥程度得看业务系统的场景了，实现这个就得用MySQL 的隔离级别。</p><h4 id="4-2-1-原子性"><a href="#4-2-1-原子性" class="headerlink" title="4.2.1 原子性"></a>4.2.1 原子性</h4><p>要实现原子性，即需要保证操作要么全做，要么全不做，对于做到一半无法完成的操作就应该进行回滚。那么就需要有日志文件记录数据被修改前的信息，这样才能达到回到修改前的状态，undo log 回滚日志就实现了这一需求。</p><h4 id="4-2-2-持久性"><a href="#4-2-2-持久性" class="headerlink" title="4.2.2 持久性"></a>4.2.2 持久性</h4><p>事务一旦提交，对数据库的改变就该是永久性的。那么由于数据是存放在磁盘中的，如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。但如果MySQL宕机了，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p><p>于是引入redo log，当数据修改时，除了修改Buffer Pool中的数据，还会<strong>在redo log记录这次操作</strong>；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，<strong>重启时可以读取redo log中的数据，对数据库进行恢复</strong>。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p><h4 id="4-2-3-隔离性"><a href="#4-2-3-隔离性" class="headerlink" title="4.2.3 隔离性"></a>4.2.3 隔离性</h4><p>事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。主要考虑读写操作下的隔离，可以分为两个方面：</p><ul><li>(一个事务)<strong>写</strong>操作对(另一个事务)<strong>写</strong>操作的影响：<strong>锁机制</strong>保证隔离性</li><li>(一个事务)<strong>写</strong>操作对(另一个事务)<strong>读</strong>操作的影响：<strong>MVCC</strong>保证隔离性</li></ul><h4 id="4-2-4-一致性"><a href="#4-2-4-一致性" class="headerlink" title="4.2.4 一致性"></a>4.2.4 一致性</h4><p>事务执行结束后，<strong>数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</strong></p><p>实现一致性的措施包括：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</li></ul><h4 id="4-2-5-并发一致性问题"><a href="#4-2-5-并发一致性问题" class="headerlink" title="4.2.5 并发一致性问题"></a>4.2.5 并发一致性问题</h4><ul><li><p>丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；</p></li><li><p>脏读（Dirty Read）：读到了其他事务未提交的脏数据。</p></li><li><p>不可重复读（Nonrepeatable Read）：由于其他事务对某个记录进行了 <strong>修改(更新或删除)</strong> 而导致当前事务对某个数据的两次读取结果不同。</p></li><li><p>幻读（Phantom Read）：由于其他事务 <strong>插入了一条记录</strong> 而导致当前事务对某个数据的两次读取结果不同。对于幻读必须加表级锁，防止在这个表中新增一条数据。</p></li></ul><h4 id="4-2-6-隔离级别"><a href="#4-2-6-隔离级别" class="headerlink" title="4.2.6 隔离级别"></a>4.2.6 隔离级别</h4><p>MySQL数据的四种隔离级别：</p><ol><li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li><li>Read committed (读已提交)：可避免脏读的发生。</li><li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li><li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li></ol><table><thead><tr><th>隔离级别</th><th>可以处理的并发问题</th><th>描述</th><th>实现</th><th>性能</th></tr></thead><tbody><tr><td><code>SERIALIZABLE</code> (串行化)</td><td>全部</td><td>事务一个接着一个执行</td><td>三级 + GAP 锁</td><td>1星</td></tr><tr><td><code>REPEATABLE READ</code> (可重复读)</td><td>脏读，不可重复读</td><td>所有被 SELECT 的数据不能被修改</td><td>三级</td><td>2星</td></tr><tr><td><code>READ COMMITTED</code> (读已提交)</td><td>脏读</td><td>不可重复读，幻读</td><td>二级</td><td>3星</td></tr><tr><td><code>READ UNCOMMITTED</code> (读未提交)</td><td>无</td><td>允许其他事务读取未提交的数据</td><td></td><td></td></tr></tbody></table><p>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。<br>像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，<br>所以平时选用何种隔离级别应该根据实际情况。<br>在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163536.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://images2015.cnblogs.com/blog/476810/201608/476810-20160802234328293-1886690666.png"  alt=""></p><p>可以看到，隔离级别只解决了脏读、不可重复读、幻读问题，却没解决丢失修改的问题。至于为什么隔离性级别不解决丢失修改，我猜是有更好的解决方案吧。这也就解释了为什么“<strong>防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决</strong>”</p><p>repeatable read能解决脏读和不可重复读，但不能解决丢失修改。</p><h2 id="五、锁机制"><a href="#五、锁机制" class="headerlink" title="五、锁机制"></a>五、锁机制</h2><p>按锁的粒度划分：表级锁、行级锁、页级锁</p><p>按锁级别划分：共享锁、排它锁、意向锁</p><p>按加锁方式划分：自动锁、显示锁</p><p>按使用方式划分：乐观锁、悲观锁</p><p><strong>行锁、页锁、表锁</strong></p><p>锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</p><p>按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。<strong>表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源，因此在锁定数据较多情况下使用表锁可以节省大量资源</strong>。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p><p><strong>行级锁</strong>：行级锁分为共享锁和排他锁。行级锁是MySQL中锁定粒度最细的锁。InnoDB引擎支持行级锁和表级锁，<strong>只有在通过索引检索数据的时候，才使用行级锁</strong>，否就使用表级锁。行级锁开销大，加锁慢，锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p><p><strong>表级锁：</strong>表级锁分为表共享锁和表独占锁。表级锁开销小，加锁快，锁定粒度大，发生锁冲突最高，并发度最低</p><p><strong>页级锁：</strong>页级锁是MySQL中锁定粒度<strong>介于行级锁和表级锁中间的一种锁</strong>。<strong>表级锁速度快，但冲突多，行级冲突少，但速度慢</strong>。所以取了折中的页级，一次<strong>锁定相邻的一组记录</strong>。BDB支持页级锁。开销和加锁时间界于表锁和行锁之间；会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p><p><strong>触发行锁、表锁时机</strong></p><ul><li><p>如果where条件中只用到索引项，则加的是行锁；否则加的是表锁。比如说主键索引，唯一索引和聚簇索引等。如果sql的where是全表扫描的，想加行锁也爱莫能助。</p></li><li><p>行锁和表锁对我们编程有什么影响，要在where中尽量只用索引项，否则就会触发表锁。</p></li></ul><p>innodb一般情况下走索引或者主键更新都是锁行，其余都是锁表，在并发的时候可以加select for update手工锁</p><h3 id="5-1-什么是乐观锁和悲观锁"><a href="#5-1-什么是乐观锁和悲观锁" class="headerlink" title="5.1 什么是乐观锁和悲观锁"></a>5.1 什么是乐观锁和悲观锁</h3><ul><li>悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于数据更新比较频繁的场景；</li><li>乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于读多写少的场景。</li></ul><p>乐观锁的实现方式有：</p><ul><li>加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；</li><li>先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新</li></ul><h3 id="5-2-事务隔离是怎么实现的？有哪些锁？"><a href="#5-2-事务隔离是怎么实现的？有哪些锁？" class="headerlink" title="5.2  事务隔离是怎么实现的？有哪些锁？"></a>5.2  事务隔离是怎么实现的？有哪些锁？</h3><p>事务隔离通过排他锁、共享锁实现</p><ul><li><p>排他写锁（X 锁）：若事务 T对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其他任何事物都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁为止。</p></li><li><p>共享读锁（S 锁）：若事务 T 对数据 A 加上 S 锁，则事务 T 可以读 A 但是不能修改 A，其他事务只能对 A 加 S 锁而不能加 X 锁，直到 T 释放 A 上的 S 锁为止。所以它的最主要作用是阻塞 X 锁。</p></li><li><p>意向锁：事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。所以需要<strong>意向锁，当事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，其他事务B要加锁的时候先判断表是否已被其他事务用表锁锁表，发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞</strong>。</p></li></ul><h3 id="5-3-三级加锁协议（可解决脏读和不可重复读）"><a href="#5-3-三级加锁协议（可解决脏读和不可重复读）" class="headerlink" title="5.3 三级加锁协议（可解决脏读和不可重复读）"></a>5.3 三级加锁协议（可解决脏读和不可重复读）</h3><p><strong>一级加锁协议（无法避免脏读、不可重复读）</strong>–读不加锁，写加X锁</p><ul><li>如果只对数据进行读操作，不需要加锁。</li><li>如果对数据进行写操作，需要加 X 锁直至事务结束。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。</li></ul><p><strong>二级加锁协议（可避免脏读，无法避免不可重复读）</strong>–读加S锁（读完释放），写加X锁</p><p>在一级加锁协议的基础上，添加操作：事务 T 在读取数据 R 前要对 R 加上 S 锁，<strong>读完之后即可释放 S 锁</strong>，无需等待事务结束。</p><p><strong>三级加锁协议（可避免脏读、不可重复读）</strong>–读加S锁（事务结束释放），写加X锁</p><p><strong>基本与二级加锁协议相同</strong>，只是 S 锁加上之后要等到<strong>事务结束才能释放</strong>。</p><p><strong>3 种锁：</strong></p><ul><li>Record Locks（记录锁）：在索引记录上加锁。</li><li>Gap Locks（间隙锁）：在索引记录之间加锁，或者在第一个索引记录之前加锁，或者在最后一个索引记录之后加锁，可避免幻读。</li><li>Next-Key Locks：在索引记录上加锁，并且在索引记录之前的间隙加锁。它相当于是 Record Locks 与 Gap Locks 的一个结合。</li></ul><h2 id="六、MVCC"><a href="#六、MVCC" class="headerlink" title="六、MVCC"></a>六、MVCC</h2><h3 id="6-1-什么是MVCC"><a href="#6-1-什么是MVCC" class="headerlink" title="6.1 什么是MVCC"></a>6.1 什么是MVCC</h3><p>多版本并发控制 ，是现代数据库（包括 <code>MySQL</code> 、 <code>Oracle</code> 、 <code>PostgreSQL</code> 等）引擎实现中常用的<strong>处理读写冲突的手段</strong>， 目的在于提高数据库高并发场景下的吞吐性能 。</p><p><strong>作用</strong>：</p><p>如此一来不同的事务在并发过程中， <code>SELECT</code> 操作可以不加锁而是通过 <code>MVCC</code> 机制读取指定的版本历史记录，并通过一些手段保证保证读取的记录值符合事务所处的隔离级别，从而<strong>解决并发场景下的读写冲突</strong>。</p><h3 id="6-2-什么是读写冲突"><a href="#6-2-什么是读写冲突" class="headerlink" title="6.2 什么是读写冲突"></a>6.2 什么是读写冲突</h3><p>先来看下什么是版本冲突，也就知道为什么要引入MVCC解决版本冲突问题。</p><p>设想一种常见，事务A <code>begin</code>之后修改了数据但还没commit或者rollback这段时间内，事务B <code>select</code>查找数据，那事务B读到的值应该是什么？很明显，理论上来说，既然还没提交，那肯定B读到的是旧数据，但<strong>在不同隔离级别下，B读到的值也会不一样</strong>！</p><ol><li>如果事务 <code>B</code> 的隔离级别是读未提交（RU），那么两次读取均读取到 <code>x</code> 的最新值，即 <code>20</code> 。</li><li>如果事务 <code>B</code> 的隔离级别是读已提交（RC），那么第一次读取到旧值 <code>10</code> ，第二次因为事务 <code>A</code> 已经提交，则读取到新值 20。</li><li>如果事务 <code>B</code> 的隔离级别是可重复读或者串行（RR，S），则两次均读到旧值 <code>10</code> ，不论事务 <code>A</code> 是否已经提交。</li></ol><p>可见在不同的隔离级别下，数据库通过 <code>MVCC</code> 和隔离级别，让事务之间并行操作遵循了某种规则，来保证单个事务内前后数据的一致性。</p><p><strong>注意</strong>：这里大家会发现RR和S隔离级别读到的数据是一样的，但实现原理不同，RR是由MVCC实现，S由加锁来实现。因此，MVCC用于RC和RR级别下。</p><h3 id="6-3-为什么需要MVCC"><a href="#6-3-为什么需要MVCC" class="headerlink" title="6.3 为什么需要MVCC"></a>6.3 为什么需要MVCC</h3><h4 id="6-3-1-事务所带来的问题"><a href="#6-3-1-事务所带来的问题" class="headerlink" title="6.3.1 事务所带来的问题"></a>6.3.1 事务所带来的问题</h4><p><code>InnoDB</code> 相比 <code>MyISAM</code> 有两大特点，一是支持事务二是支持行级锁，事务的引入带来了一些新的挑战。相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况：</p><ol><li>更新丢失（ <code>Lost Update</code> ）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 —— 最后的更新覆盖了其他事务所做的更新。如何避免这个问题呢，最好在一个事务对数据进行更改但还未提交时，其他事务不能访问修改同一个数据。</li><li>脏读（ <code>Dirty Reads</code> ）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些尚未提交的脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做 “脏读” 。</li><li>不可重复读（ <code>Non-Repeatable Reads</code> ）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</li><li>幻读（ <code>Phantom Reads</code> ）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为 “幻读” 。</li></ol><p>以上是并发事务过程中会存在的问题，解决更新丢失可以交给应用，但是后三者需要数据库提供<strong>事务间的隔离机制</strong>来解决。 <strong>实现隔离机制的方法主要有两种</strong> ：</p><ol><li>加读写锁</li><li>一致性快照读，即 <code>MVCC</code></li></ol><p>但本质上，隔离级别是一种在并发性能和并发产生的副作用间的妥协，通常数据库均倾向于采用 <code>Weak Isolation</code> </p><p>总结来说，使用MVCC的开销比使用加读写锁的开销来的小，所以需要MVCC。</p><h3 id="6-4-MVCC原理"><a href="#6-4-MVCC原理" class="headerlink" title="6.4 MVCC原理"></a>6.4 MVCC原理</h3><h4 id="6-4-1-行记录结构"><a href="#6-4-1-行记录结构" class="headerlink" title="6.4.1 行记录结构"></a>6.4.1 行记录结构</h4><p>InnoDB 中 <code>MVCC</code> 的实现方式为：每一行记录都有两个隐藏列： <code>DATA_TRX_ID</code> 、 <code>DATA_ROLL_PTR</code></p><table><thead><tr><th>column1</th><th>column1</th><th>……</th><th>DATA_TRX_ID</th><th>DATA_ROLL_PTR</th><th>DB_ROW_ID</th></tr></thead><tbody><tr><td>id</td><td>name</td><td></td><td>事务版本号</td><td>上一版本地址</td><td>没有主键的时候才出现</td></tr></tbody></table><p>实现MVCC，最主要的就是 <code>DATA_TRX_ID</code> 、 <code>DATA_ROLL_PTR</code>这两个隐藏列</p><p><strong>DATA_TRX_ID</strong>：记录最近更新这条行记录的 <code>事务 ID</code> ，大小为 <code>6</code> 个字节。也就是标记是哪个事务修改的。</p><p><strong>DATA_ROLL_PTR</strong>：表示指向该行回滚段 <code>（rollback segment）</code> 的指针，大小为 <code>7</code> 个字节， <code>InnoDB</code> 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在 <code>undo</code> 中都通过链表的形式组织。</p><p>这里需要大家了解了上文讲到的事务原子性由undo log记录更改前的版本来实现这部分知识。</p><h4 id="6-4-2-版本链"><a href="#6-4-2-版本链" class="headerlink" title="6.4.2 版本链"></a>6.4.2 版本链</h4><p>在多个事务并行操作某行数据的情况下，不同事务对该行数据的 UPDATE 会产生多个版本，然后通过回滚指针组织成一条 <code>Undo Log</code> 链，这节我们通过一个简单的例子来看一下 <code>Undo Log</code> 链是如何组织的， <code>DATA_TRX_ID</code> 和 <code>DATA_ROLL_PTR</code> 两个参数在其中又起到什么样的作用。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506150324.png"  alt=""></p><p>事务200的操作过程</p><ol><li>对 column1 = 20 的这行记录加排他锁</li><li>将column1 = 20 的这一行原本的值原样拷贝到 undo log 中</li><li>修改该行的值这时产生一个新版本，更新 <code>DATA_TRX_ID</code> 为修改记录的事务 <code>ID</code> ，将 <code>DATA_ROLL_PTR</code> 指向刚刚拷贝到 <code>undo log</code> 链中的旧版本记录。如果对同一行记录执行连续的 <code>UPDATE</code> ， <code>Undo Log</code> 会组成一个链表，遍历这个链表可以看到这条记录的变迁。</li><li>记录 <code>redo log</code> ，包括 <code>undo log</code> 中的修改</li></ol><p>那么 <code>INSERT</code> 和 <code>DELETE</code> 会怎么做呢？其实相比 <code>UPDATE</code> 这二者很简单， <code>INSERT</code> 会产生一条新纪录，它的 <code>DATA_TRX_ID</code> 为当前插入记录的事务 <code>ID</code> ； <code>DELETE</code> 某条记录时可看成是一种特殊的 <code>UPDATE</code> ，其实是软删，真正执行删除操作会在 <code>commit</code> 时， <code>DATA_TRX_ID</code> 则记录下删除该记录的事务 <code>ID</code> 。</p><h4 id="6-4-3-ReadView"><a href="#6-4-3-ReadView" class="headerlink" title="6.4.3 ReadView"></a>6.4.3 ReadView</h4><p>上面说了，通过版本链的方式控制不同隔离级别下，并发事务读到的版本不一样。那事务怎么知道自己能读哪些版本呢？这就由ReadView来解决，读已提交（RC）和可重复读（RR）的生成ReadView策略是不一样的。</p><p>ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是<strong>begin了还未提交的事务</strong>。<strong>通过这个列表来判断记录的某个版本是否对当前事务可见</strong>。</p><p>总结：ReadView记录了当前活跃着的读写事务id的列表，称之为 <code>m_ids</code>，它有个[ up_limit_id，low_limit_id]范围（是的，没写错，up_limit_id就是左界限），这个左右界限就决定了哪些版本的数据是事务可以访问的。</p><ol><li>如果被访问版本的 <code>trx_id</code> 小于 <code>m_ids</code> 中的最小值 <code>up_limit_id</code> ，说明生成该版本的事务在 <code>ReadView</code> 生成前就已经提交了，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 <code>trx_id</code> 大于 <code>m_ids</code> 列表中的最大值 <code>low_limit_id</code> ，说明生成该版本的事务在生成 <code>ReadView</code> 后才生成，所以该版本不可以被当前事务访问。需要根据 <code>Undo Log</code> 链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性。</li><li>如果被访问版本的 <code>trx_id</code> 属性值在 <code>m_ids</code> 列表中最大值和最小值之间（包含），那就需要判断一下 <code>trx_id</code> 的值是不是在 <code>m_ids</code> 列表中。如果在，说明创建 <code>ReadView</code> 时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的 <code>DB_TRX_ID</code> 再从头计算一次可见性；如果不在，说明创建 <code>ReadView</code> 时生成该版本的事务已经被提交，该版本可以被访问。</li><li>此时经过一系列判断我们已经得到了这条记录相对 <code>ReadView</code> 来说的可见结果。此时，如果这条记录的 <code>delete_flag</code> 为 <code>true</code> ，说明这条记录已被删除，不返回。否则说明此记录可以安全返回给客户端。</li></ol><p>举个例子吧</p><p>假设当前列表里的事务id为[80,100]。</p><ul><li>如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。</li><li>如果你要访问的记录版本的事务id为90, 发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。</li><li>如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。</li></ul><p>这些记录都是去版本链里面找的，先找最近记录，如果最近这一条记录事务id不符合条件，不可见的话，再去找上一个版本再比较当前事务的id和这个版本事务id看能不能访问，以此类推直到返回可见的版本或者结束。</p><h4 id="6-4-4-不同隔离级别下的ReadView"><a href="#6-4-4-不同隔离级别下的ReadView" class="headerlink" title="6.4.4 不同隔离级别下的ReadView"></a>6.4.4 不同隔离级别下的ReadView</h4><p>大致的流程就像上面说讲的那样，但是根据不同的ReadView也会有不一样的结果。这是因为<strong>已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView</strong></p><ol><li><p>RC下的MVCC判断流程</p><p>当事务 <code>A</code> 未提交时，事务 <code>B</code> 进行查询，假设事务 <code>B</code> 的事务 <code>ID</code> 为 <code>300</code> ，此时生成 <code>ReadView</code> 的 <code>m_ids</code> 为 [200，300]，而最新版本的 <code>trx_id</code> 为 <code>200</code> ，处于 <code>m_ids</code> 中，则该版本记录不可被访问，查询版本链得到上一条记录的 trx_id 为 <code>100</code> ，小于 <code>m_ids</code> 的最小值 <code>200</code> ，因此可以被访问，此时事务 <code>B</code> 就查询到值 <code>10</code> 而非 <code>20</code> 。</p><p>待事务 <code>A</code> 提交之后，事务 <code>B</code> 进行查询，此时生成的 <code>ReadView</code> 的 <code>m_ids</code> 为 [300]，而最新的版本记录中 <code>trx_id</code> 为 <code>200</code> ，小于 <code>m_ids</code> 的最小值 <code>300</code> ，因此可以被访问到，此时事务 <code>B</code> 就查询到 <code>20</code> 。</p></li><li><p>RR下的MVCC判断流程</p><p>如果在 <code>RR</code> 隔离级别下，为什么事务 <code>B</code> 前后两次均查询到 <code>10</code> 呢？ <code>RR</code> 下生成 <code>ReadView</code> 是在事务开始时，m_ids 为 [200,300]，后面不发生变化，因此即使事务 <code>A</code> 提交了， <code>trx_id</code> 为 <code>200</code> 的记录依旧处于 <code>m_ids</code> 中，不能被访问，只能访问版本链中的记录 <code>10</code> 。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库学习笔记</title>
      <link href="/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><p>第一范式：属性不可分割。也就是每个字段都是不可再拆分的</p><p>第二范式：非主属性完全依赖于主属性。也就是说每一行数据都可以通过主键的唯一标识获取自身其它的非主属性</p><p>第三范式：属性间不能存在传递依赖，会造成数据的冗余，这种情况需要将表拆分，并做外键关联</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS协议详解</title>
      <link href="/2020/04/28/%E7%BD%91%E7%BB%9C/Https%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/04/28/%E7%BD%91%E7%BB%9C/Https%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="hofe.work">欢迎来我的个人网站</a>，里面有最新的版本</p><p>这篇介绍了下HTTPS面试题常考内容，并做了延伸，解释了原理。</p></blockquote><h2 id="一、常见面试题"><a href="#一、常见面试题" class="headerlink" title="一、常见面试题"></a>一、常见面试题</h2><p><strong>先来看看一些常见的面试题</strong></p><p>Https的过程（对称加密和非对称加密，CA，还有随机数生成秘钥的方式）</p><h2 id="二、Http和Https的区别"><a href="#二、Http和Https的区别" class="headerlink" title="二、Http和Https的区别"></a>二、Http和Https的区别</h2><p>Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了<strong>加密和认证机制的HTTP</strong>。二者之间存在如下不同：</p><p>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</p><p>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</p><p>开销：Https通信需要证书，而证书一般需要向认证机构购买；<br>　<br>Https的加密机制是一种共享密钥加密（SSL）和公开密钥加密（TLS）并用的混合加密机制。SSL/TLS分别为对称加密和非对称加密两种方式。</p><h2 id="三、对称加密与非对称加密"><a href="#三、对称加密与非对称加密" class="headerlink" title="三、对称加密与非对称加密"></a>三、对称加密与非对称加密</h2><h3 id="3-1-对称加密"><a href="#3-1-对称加密" class="headerlink" title="3.1 对称加密"></a>3.1 对称加密</h3><p>对称加密是指加密和解密都用同一份密钥。A和B通过协商确定加密算法（不同客户端与服务器之间的加密算法需要不同）以及密钥。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200508175056.png"  alt=""></p><p>但是存在着一个问题，A通过明文传输和server协商采用了加密算法A，但这条信息本身是没有加密的，密钥有可能泄漏，因此还是不安全。于是引入<strong>非对称加密对协商过程信息加密</strong>。</p><p><strong>对称加密算法(加解密密钥相同)</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>密钥长度</strong></th><th><strong>运算速度</strong></th><th><strong>安全性</strong></th><th><strong>资源消耗</strong></th></tr></thead><tbody><tr><td>DES</td><td>56位</td><td>较快</td><td>低</td><td>中</td></tr><tr><td>3DES</td><td>112位或168位</td><td>慢</td><td>中</td><td>高</td></tr><tr><td><strong>AES</strong></td><td><strong>128、192、256位</strong></td><td><strong>快</strong></td><td><strong>高</strong></td><td><strong>低</strong></td></tr></tbody></table><h3 id="3-2-非对称加密"><a href="#3-2-非对称加密" class="headerlink" title="3.2 非对称加密"></a>3.2 非对称加密</h3><p>在密码学跟对称加密一起出现的，应用最广的加密机制“非对称加密”，如图，特点是私钥加密后的密文，只要是公钥，都可以解密，但是反过来公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200508175145.png"  alt=""></p><p>基于上述的特点，我们可以得出如下结论：</p><p>（1）公钥是开放给所有人的，但私钥是需要保密的，存在于服务端</p><p>（2）服务器端server向client端（A、B…..）的信息传输是不安全的：因为所有人都可以获取公钥</p><p>（3）但client端（A、B…..）向server端的信息传输确实安全的：因为私钥只有server端存在</p><p>因此，如何协商加密算法的问题，我们解决了，非对称加密算法进行对称加密算法协商过程。<strong>客户端用公钥对采用何种对称加密算法以及密钥进行加密，服务器接收到之后用私钥进行解密，只有服务器才知道和该客户端之间用什么加密算法以及密钥是什么。</strong></p><p><strong>非对称算法(加密密钥和解密密钥不同)</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>成熟度</strong></th><th><strong>安全性(取决于密钥长度)</strong></th><th><strong>运算速度</strong></th><th><strong>资源消耗</strong></th></tr></thead><tbody><tr><td>RSA</td><td>高</td><td>高</td><td>慢</td><td>高</td></tr><tr><td><strong>DSA</strong></td><td><strong>高</strong></td><td><strong>高</strong></td><td><strong>慢</strong></td><td><strong>只能用于数字签名</strong></td></tr><tr><td><strong>ECC</strong></td><td><strong>低</strong></td><td><strong>高</strong></td><td><strong>快</strong></td><td><strong>低(计算量小,存储空间占用小,带宽要求低)</strong></td></tr></tbody></table><h2 id="四、HTTPS通信过程"><a href="#四、HTTPS通信过程" class="headerlink" title="四、HTTPS通信过程"></a>四、HTTPS通信过程</h2><p><strong>回顾一下Http通信过程</strong></p><ol><li><p>客户端连接到Web服务器。与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。</p></li><li><p>发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送请求报文由<strong>请求行、请求头部、空行和请求数据</strong>4部分组成。</p></li><li><p>服务器接受请求并返回HTTP响应由<strong>状态行、响应头部、空行和响应数据</strong>4部分组成。</p></li><li><p>释放连接TCP连接</p></li><li><p>客户端浏览器解析HTML内容</p></li></ol><p><strong>Https通信过程</strong></p><ol><li>客户端浏览器发起连接（Http通信的第一步），端口是443。</li><li>WEB服务器将公钥发给客户端。</li><li>客户端生成一个session key，并且将session key用公钥加密后发送给服务器。</li><li>服务器用私钥将session key解密出来。</li><li>客户端和服务器用session key做对称加密通信。（Http通信的第二步）</li></ol><p>实际上session key的生成是需要多次协商的结果。整个流程会有一个问题，第2步中WEB服务器发给客户端的公钥，万一被中间人修改了呢，换句话说，<strong>客户端怎么验证公钥的正确性呢？那就需要数字证书签发机构（CA）颁发的证书（SSL）</strong></p><h2 id="五、证书、数字签名"><a href="#五、证书、数字签名" class="headerlink" title="五、证书、数字签名"></a>五、证书、数字签名</h2><p>在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有证书的<strong>颁发机构、有效期、公钥、证书持有者、签名</strong>，通过第三方的校验保证了身份的合法，解决了公钥获取的安全性。</p><p>（数字签名、摘要签名、摘要信息意义一样；摘要算法、哈希算法意义一样）</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20181222145815625"  alt=""></p><p>以浏览器为例说明如下整个的校验过程：</p><p>（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验</p><p>（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发 </p><p>（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</p><p>（4）如果找到，那么浏览器就会从<strong>操作系统中取出</strong>  颁发者CA  的公钥，然后对服务器发来的证书里面的数字签名进行解密得到摘要签名和摘要算法</p><p>（5）浏览器使用得到的摘要算法计算出服务器发来的证书的公钥，将这个计算的值与证书中摘要签名做对比</p><p>（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充</p><p>（7）此时浏览器就可以<strong>读取证书中的公钥</strong>(这才是非对称加密的公钥)，用于后续加密了</p><p>总结：</p><p>申请者通过<strong>非对称加密算法（RSA）</strong> 生成一对<strong>公钥</strong>和<strong>密钥</strong>，然后把需要的申请信息（国家，域名等）连同<strong>公钥</strong>发送给 <strong>证书认证机构（CA）</strong></p><p>CA机构确认无误后通过<strong>消息摘要算法</strong>（MD5，SHA) 生成整个申请信息的摘要签名M， 然后 把 <strong>签名M和使用的摘要算法</strong> 用 <strong>CA自己的私钥</strong> 进行加密(数字签名)</p><p>浏览器<strong>从操作系统中获取CA的公钥</strong>对数字签名进行解密，得到签名和摘要算法，用摘要算法对证书包含的公钥信息进行计算。如果计算得到的值和摘要签名m一样，说明证书中包含的公钥是正确的。</p><p><strong>散列算法比较</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>安全性</strong></th><th><strong>速度</strong></th></tr></thead><tbody><tr><td>SHA-1</td><td>高</td><td>慢</td></tr><tr><td><strong>MD5</strong></td><td><strong>中</strong></td><td><strong>快</strong></td></tr></tbody></table><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> HTTPS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归题目合集</title>
      <link href="/2020/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/"/>
      <url>/2020/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>剑指offer中所有关于树的题目，一般靠递归解决</p><p>可访问<a href="https://juejin.im/post/5c8276216fb9a049d51a4cd6" target="_blank" rel="noopener">个人网站</a>进行阅读最新版本</p></blockquote><p>呼，在做了很多很多树的题目之后，我似乎掌握了递归的精髓了，不容易不容易。</p><h3 id="二叉树的构建"><a href="#二叉树的构建" class="headerlink" title="二叉树的构建"></a>二叉树的构建</h3><p><strong>题目</strong><br>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>前序的特点是从左到右都是每颗子树的父节点，通过父节点，在中序中找到等于父节点的位置，在这个位置左边的就是左子树，在右边就是右子树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6?f=discussion</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> plen = pre.length;</span><br><span class="line">        <span class="keyword">int</span> inlen = in.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(plen == <span class="number">0</span> || inlen == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inlen; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == in[i])&#123;</span><br><span class="line">                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i+<span class="number">1</span>), </span><br><span class="line">                                                  <span class="comment">//这里1~i+1的原因是0的位置是当前树的父节点，所以不用传入子树，下一颗子树的父节点从1开始；i+1是因为在前序数组中从1到i+1的位置都是子树包含的节点，i+1取不到</span></span><br><span class="line">                             Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                <span class="comment">// 中序数组中0~i都是子树的节点</span></span><br><span class="line">                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i+<span class="number">1</span>,plen), </span><br><span class="line">                             Arrays.copyOfRange(in, i+<span class="number">1</span>, inlen));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><p><strong>题目描述</strong><br>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/6e196c44c7004d15b1610b9afca8bd88?f=discussion</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当Tree1和Tree2都不为零的时候，才进行比较。否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (root2 != <span class="keyword">null</span> &amp;&amp; root1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果找到了对应Tree2的根节点的点</span></span><br><span class="line">            <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">                <span class="comment">//以这个根节点为为起点判断是否包含Tree2</span></span><br><span class="line">                result = doesTree1HaveTree2(root1,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                result = HasSubtree(root1.left,root2);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                result = HasSubtree(root1.right,root2);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doesTree1HaveTree2</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果其中有一个点没有对应上，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (node1.val != node2.val) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//如果根节点对应的上，那么就分别去子节点里面匹配</span></span><br><span class="line">        <span class="keyword">return</span> doesTree1HaveTree2(node1.left,node2.left) &amp;&amp; doesTree1HaveTree2(node1.right,node2.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><p><strong>题目描述</strong><br>操作给定的二叉树，将其变换为源二叉树的镜像。<br><strong>输入描述:</strong><br>二叉树的镜像定义：源二叉树<br>            8<br>           /  \<br>          6   10<br>         / \  / \<br>        5  7 9 11<br>        镜像二叉树<br>            8<br>           /  \<br>          10   6<br>         / \  / \<br>        11 9 7  5</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    swap(root);</span><br><span class="line">    Mirror(root.left);</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode t = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><p><strong>题目描述</strong><br>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/ff05d44dfdb04e1d83bdbdab320efbcb?f=discussion</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="comment">/*思路：首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同</span></span><br><span class="line"><span class="comment">* 左子树的右子树和右子树的左子树相同即可，采用递归</span></span><br><span class="line"><span class="comment">* 非递归也可，采用栈或队列存取各级子树根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymTree(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymTree</span><span class="params">(TreeNode LTree, TreeNode RTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LTree == <span class="keyword">null</span> &amp;&amp; RTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(LTree == <span class="keyword">null</span> || RTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(LTree.val != RTree.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymTree(LTree.left, RTree.right) &amp;&amp; isSymTree(LTree.right, RTree.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树打印"><a href="#二叉树打印" class="headerlink" title="二叉树打印"></a>二叉树打印</h3><p><strong>题目描述</strong><br>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/7fe2212963db4790b57431d9ed259701?f=discussion</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode treeNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(treeNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(treeNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(treeNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong><br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        </span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(pRoot);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.size() != <span class="number">0</span>)</span><br><span class="line">            ret.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树的后序遍历"><a href="#二叉搜索树的后序遍历" class="headerlink" title="二叉搜索树的后序遍历"></a>二叉搜索树的后序遍历</h3><p><strong>题目描述</strong><br>输入一个非空整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同</p><p>解法：由于后序遍历的最后一个结点是根，又满足左子树都&lt;根&lt;右子树这个条件，所以</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/a861533d45854474ac791d90e447bafd?f=discussion</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">思路：找住二叉查找树的特点：左子树&lt;根&lt;=右子树  使用分治思想</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 后序遍历特点：最后一个是根；从0开始到中间某一节点都小于根，右边都大于根</span></span><br><span class="line">    <span class="comment">// 每一段的最右边又是这一段的根</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = sequence.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//int root = sequence[len-1];</span></span><br><span class="line">        <span class="keyword">return</span> judge(sequence, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> sequence[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)&#123;    <span class="comment">// 这个必须有，不然会超出数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start;</span><br><span class="line">        <span class="keyword">while</span>(sequence[mid] &lt; sequence[end])&#123;</span><br><span class="line">            mid++;</span><br><span class="line">            <span class="comment">// start~i都是小于end的，i~end-1都是大于end的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于上面的就可以判断出左边都小于父了，所以下面判断右边是否都大于根</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i] &lt; sequence[end])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> judge(sequence, start, mid-<span class="number">1</span>) &amp;&amp; judge(sequence, mid, end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树结点路径和"><a href="#二叉树结点路径和" class="headerlink" title="二叉树结点路径和"></a>二叉树结点路径和</h3><p><strong>题目描述</strong><br>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/b736e784e3e34731af99065031301bca?f=discussion</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    backtracking(root, target, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(TreeNode node, <span class="keyword">int</span> target, ArrayList&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    path.add(node.val);</span><br><span class="line">    target -= node.val;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ret.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        backtracking(node.left, target, path);</span><br><span class="line">        backtracking(node.right, target, path);</span><br><span class="line">    &#125;</span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树转成链表"><a href="#二叉搜索树转成链表" class="headerlink" title="二叉搜索树转成链表"></a>二叉搜索树转成链表</h3><p><strong>题目描述</strong><br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">明确Convert函数的功能。</span><br><span class="line">输入：输入一个二叉搜索树的根节点。</span><br><span class="line">过程：将其转化为一个有序的双向链表。</span><br><span class="line">输出：返回该链表的头节点。</span><br><span class="line"></span><br><span class="line">明确成员变量pLast的功能。</span><br><span class="line">pLast用于记录当前链表的末尾节点。</span><br><span class="line"></span><br><span class="line">明确递归过程。</span><br><span class="line">递归的过程就相当于按照中序遍历，将整个树分解成了无数的小树，然后将他们分别转化成了一小段一小段的双向链表。再利用pLast记录总的链表的末尾，然后将这些小段链表一个接一个地加到末尾。</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode pLast = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果左子树为空，那么根节点root为双向链表的头节点</span></span><br><span class="line"> TreeNode head = Convert(root.left);</span><br><span class="line"> <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">     head = root;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 连接当前节点root和当前链表的尾节点pLast</span></span><br><span class="line"> root.left = pLast;</span><br><span class="line"> <span class="keyword">if</span> (pLast != <span class="keyword">null</span>)</span><br><span class="line">     pLast.right = root;</span><br><span class="line"> pLast = root;</span><br><span class="line"></span><br><span class="line"> Convert(root.right);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树的第k个结点"><a href="#二叉查找树的第k个结点" class="headerlink" title="二叉查找树的第k个结点"></a>二叉查找树的第k个结点</h3><p><strong>题目描述</strong><br>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode ret;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    inOrder(pRoot, k);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || cnt &gt;= k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left, k);</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span> (cnt == k)</span><br><span class="line">        ret = root;</span><br><span class="line">    inOrder(root.right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求树的深度"><a href="#求树的深度" class="headerlink" title="求树的深度"></a>求树的深度</h3><p><strong>题目描述</strong><br>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span> + Math.max(TreeDepth(root.left), TreeDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否平衡二叉树"><a href="#是否平衡二叉树" class="headerlink" title="是否平衡二叉树"></a>是否平衡二叉树</h3><p><strong>题目描述</strong><br>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从下往上遍历，如果子树是平衡二叉树，则返回子树的高度；</span></span><br><span class="line"><span class="comment">//如果发现子树不是平衡二叉树，则直接停止遍历，这样至多只对每个结点访问一次。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isBalanced = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    height(root);</span><br><span class="line">    <span class="keyword">return</span> isBalanced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || !isBalanced)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = height(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = height(root.right);</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>)</span><br><span class="line">        isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最低公共祖先"><a href="#最低公共祖先" class="headerlink" title="最低公共祖先"></a>最低公共祖先</h3><p><strong>解题思路</strong><br>在左右子树中查找是否存在 p 或者 q，如果 p 和 q 分别在两个子树中，那么就说明根节点就是最低公共祖先。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : right == <span class="keyword">null</span> ? left : root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议详解</title>
      <link href="/2020/04/28/%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/04/28/%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="hofe.work">欢迎来我的个人网站</a>，里面有最新的版本</p><p>这篇介绍了下HTTP面试题常考内容，并做了延伸，解释了原理。</p></blockquote><h2 id="一、常见面试题"><a href="#一、常见面试题" class="headerlink" title="一、常见面试题"></a>一、常见面试题</h2><p><strong>先来看看一些常见的面试题</strong></p><p>TCP/IP五层协议？</p><p>http协议以及一些延伸？</p><p>get和post区别？</p><p>状态码？</p><p>url回车之后发生什么？</p><p>Https的过程（详细地说了对称加密和非对称加密，CA，还有随机数生成秘钥的方式）；</p><p>http和tcp的关系</p><h2 id="二、HTTP简介"><a href="#二、HTTP简介" class="headerlink" title="二、HTTP简介"></a>二、HTTP简介</h2><blockquote><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）<strong>服务器传输超文本到本地浏览器</strong>的传送协议。</p><p>HTTP是一个<strong>基于TCP/IP通信协议</strong>来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><p>HTTP是一个<strong>属于应用层的面向对象的协议</strong></p><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200508174800.png"  alt=""></p></blockquote><h2 id="三、特点"><a href="#三、特点" class="headerlink" title="三、特点"></a>三、特点</h2><ul><li>1、简单快速：<strong>客户向服务器请求服务时，只需传送请求方法和路径</strong>。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>2、灵活：<strong>HTTP允许传输任意类型的数据对象</strong>。正在传输的类型<strong>由Content-Type加以标记</strong>。</li><li>3、无连接：无连接的含义是<strong>限制每次连接只处理一个请求</strong>。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>4、无状态：HTTP协议是无状态协议。<strong>无状态是指协议对于事务处理没有记忆能力</strong>。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>5、支持B/S及C/S模式。</li></ul><h2 id="四、工作原理"><a href="#四、工作原理" class="headerlink" title="四、工作原理"></a>四、工作原理</h2><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含<strong>请求的方法、URL、协议版本、请求头部和请求数据</strong>。服务器以一个状态行作为响应，响应的内容包括<strong>协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据</strong>。</p><p>以下是 HTTP 请求/响应的步骤：</p><ol><li><p>客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。</p></li><li><p>发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由<strong>请求行、请求头部、空行和请求数据</strong>4部分组成。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200508174819.png"  alt=""></p></li><li><p>服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由<strong>状态行、响应头部、空行和响应数据</strong>4部分组成。</p><p>​    <img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200508174834.png"  alt=""></p></li><li><p>释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;<strong>若connection 模式为keepalive，则该连接会保持一段时间</strong>，在该时间内可以继续接收请求;</p></li><li><p>客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p></li></ol><h3 id="4-1-在浏览器地址栏键入URL，按下回车之后会经历以下流程："><a href="#4-1-在浏览器地址栏键入URL，按下回车之后会经历以下流程：" class="headerlink" title="4.1 在浏览器地址栏键入URL，按下回车之后会经历以下流程："></a>4.1 在浏览器地址栏键入URL，按下回车之后会经历以下流程：</h3><ol><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</li><li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</li><li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li><li>释放 TCP连接;</li><li>浏览器将该 html 文本解析并显示内容; </li></ol><h2 id="五、HTTP请求方法"><a href="#五、HTTP请求方法" class="headerlink" title="五、HTTP请求方法"></a>五、HTTP请求方法</h2><p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>向指定的资源发出“显示”请求。使用GET方法应该只用在<strong>读取数据</strong>，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“<strong>关于该资源的信息</strong>”（元信息或称元数据）。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>向<strong>指定资源提交数据</strong>，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>向指定<strong>资源位置上传其最新内容</strong>。</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>请求服务器<strong>删除Request-URI所标识的资源</strong>。</p><h4 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h4><p><strong>回显服务器收到的请求，主要用于测试或诊断</strong>。</p><h4 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h4><p>这个方法可使服务器<strong>传回该资源所支持的所有HTTP请求方法</strong>。用’/<em>‘来代替资源名称，向Web服务器发送OPTIONS请求，可以*</em>测试服务器功能是否正常运作**。</p><h4 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h4><p><strong>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</strong>。通常用于<strong>SSL加密服务器的链接</strong>（经由非加密的HTTP代理服务器）。</p><p>注意事项：</p><ol><li>方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</li><li>HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如<strong>PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源</strong>。</li></ol><h3 id="5-1-状态码"><a href="#5-1-状态码" class="headerlink" title="5.1 状态码"></a>5.1 状态码</h3><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p><p>状态代码的第一个数字代表当前响应的类型：</p><ul><li>1xx消息——请求已被服务器接收，继续处理</li><li>2xx成功——请求已成功被服务器接收、理解、并接受</li><li>3xx重定向——需要后续操作才能完成这一请求</li><li>4xx请求错误——请求含有词法错误或者无法被执行</li><li>5xx服务器错误——服务器在处理某个正确请求时发生错误</li></ul><p>常见状态码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span> OK                        <span class="comment">//客户端请求成功</span></span><br><span class="line"><span class="number">202</span><span class="comment">//表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定</span></span><br><span class="line"><span class="number">204</span><span class="comment">//服务器成功处理了请求，但没有返回任何实体内容 ，可能会返回新的头部元信息</span></span><br><span class="line"><span class="number">301</span><span class="comment">//客户端请求的网页已经永久移动到新的位置，当链接发生变化时，返回301代码告诉客户端链接的变化，客户端保存新的链接，并向新的链接发出请求，已返回请求结果</span></span><br><span class="line"><span class="number">400</span> Bad Request               <span class="comment">//客户端请求有语法错误，不能被服务器所理解</span></span><br><span class="line"><span class="number">401</span> Unauthorized              <span class="comment">//请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span></span><br><span class="line"><span class="number">403</span> Forbidden                 <span class="comment">//服务器收到请求，但是拒绝提供服务</span></span><br><span class="line"><span class="number">404</span> Not Found                 <span class="comment">//请求资源不存在，eg：输入了错误的URL</span></span><br><span class="line"><span class="number">500</span> Internal Server Error     <span class="comment">//服务器发生不可预期的错误</span></span><br><span class="line"><span class="number">503</span> Server Unavailable        <span class="comment">//服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span></span><br></pre></td></tr></table></figure><h2 id="六、面试题"><a href="#六、面试题" class="headerlink" title="六、面试题"></a>六、面试题</h2><h3 id="从输入网址到获得页面的过程-越详细越好-？"><a href="#从输入网址到获得页面的过程-越详细越好-？" class="headerlink" title="从输入网址到获得页面的过程 (越详细越好)？"></a>从输入网址到获得页面的过程 (越详细越好)？</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200508182119.png"  alt=""></p><ol><li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li><li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li><li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li><li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li><li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li></ol><h3 id="HTTP和HTTPS有什么区别？"><a href="#HTTP和HTTPS有什么区别？" class="headerlink" title="HTTP和HTTPS有什么区别？"></a>HTTP和HTTPS有什么区别？</h3><ol><li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li><li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li><li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li><li>HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买</li></ol><h3 id="HTTP1-0-与-HTTP1-1-的区别"><a href="#HTTP1-0-与-HTTP1-1-的区别" class="headerlink" title="HTTP1.0 与 HTTP1.1 的区别"></a>HTTP1.0 与 HTTP1.1 的区别</h3><p><strong>HTTP/1.1支持持续连接和流水线方式</strong></p><p>持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这条持续的连接并不局限于传输同一个页面上链接的文档，而是只要文档在同一个服务器上就可以通过这条持续的连接传送。</p><p>流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</p><h3 id="GET与POST的区别？"><a href="#GET与POST的区别？" class="headerlink" title="GET与POST的区别？"></a>GET与POST的区别？</h3><ol><li>GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；</li><li>GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；</li><li>请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；</li><li>安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；</li><li>GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；</li><li>GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制</li><li>GET产生一个TCP数据包；POST产生两个TCP数据包（跨域，会先发header包探测是否会接收）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程学习笔记</title>
      <link href="/2020/04/27/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/04/27/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>复习多线程时候做的一些笔记，算是比较全的，考察重点比如Synchronized、RetreenLock、CAS都做了一些介绍，不过这些源码更重要，这篇没给出。<br>也尝试过只看面试题，但如果不会原理的话，其实还挺难记住的，需要面试题可以看我的另一篇《Java面试题锦集》那篇博客。<br>这篇博客借鉴了Java3y和JavaGuide的文章，特此感谢，欢迎大家关注他们的公众号，干货多多。</p><p><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">https://www.cnblogs.com/waterystone/p/4920797.html</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="原子操作实现原理"><a href="#原子操作实现原理" class="headerlink" title="原子操作实现原理"></a>原子操作实现原理</h3><p><strong>使用循环CAS实现原子操作</strong><br>JVM中的<strong>CAS操作正是利用了处理器提供的cmpxchg指令</strong>实现的，CPU指令是不会被打断的。自旋CAS实现的基本 思路就是循环进行CAS操作直到成功为止。</p><h3 id="Atomit实现原理"><a href="#Atomit实现原理" class="headerlink" title="Atomit实现原理"></a>Atomit实现原理</h3><p>Atomic包的类的实现绝大部分调用Unsafe类的本地方法，而<strong>Unsafe底层实际上是调用C代码</strong>，C代码调用汇编，最后生成出一条CPU指令cmpxchg，完成操作。</p><h3 id="原子操作三大问题及解决方案"><a href="#原子操作三大问题及解决方案" class="headerlink" title="原子操作三大问题及解决方案"></a>原子操作三大问题及解决方案</h3><p>1）ABA问题</p><p>因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化 则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它 的值没有发生变化，但是实际上却变化了。</p><p>ABA问题的解决思路就是<strong>使用版本号</strong>。在变量前面 追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。从 Java 1.5开始，JDK的Atomic包里提供了一个类<code>AtomicStampedReference</code>来解决ABA问题。这个 <strong>类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是等于预期标志</strong>，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p>2）循环时间长开销大</p><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><p>3）只能保证一个共享变量的原子操作</p><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候可以用锁。</p><p>从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之前的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p><h2 id="一、什么是多线程"><a href="#一、什么是多线程" class="headerlink" title="一、什么是多线程"></a>一、什么是多线程</h2><h3 id="1-1-进程与线程"><a href="#1-1-进程与线程" class="headerlink" title="1.1 进程与线程"></a>1.1 进程与线程</h3><h4 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1 定义"></a>1.1.1 定义</h4><p><strong>进程</strong><br><strong>进程是程序的一次执行过程，是系统运行程序的基本单位</strong>，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程</p><p><strong>线程</strong><br>线程与进程相似，但<strong>线程是一个比进程更小的执行单位</strong>。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><h4 id="1-1-2-区别"><a href="#1-1-2-区别" class="headerlink" title="1.1.2 区别"></a>1.1.2 区别</h4><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200427134403354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区DK18之后的元空间）资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p><p>总结：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反</p><h5 id="线程计数器为什么是私有的"><a href="#线程计数器为什么是私有的" class="headerlink" title="线程计数器为什么是私有的"></a>线程计数器为什么是私有的</h5><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了需要注意的是，如果执行的是 native方法，那么程序计数器记录的是 undefined地址，只有执行的是Java代码时程序计数器记录的才是下一条指令的地址。</li></ol><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h5 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的"></a>虚拟机栈和本地方法栈为什么是私有的</h5><p><strong>虚拟机栈</strong>：每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程</p><p><strong>本地方法栈</strong>：和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native方法服务。在 HotSpot虚拟机中和Java虚拟机栈合二为所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p><h5 id="共享堆和方法区"><a href="#共享堆和方法区" class="headerlink" title="共享堆和方法区"></a>共享堆和方法区</h5><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象（所有对象都在这里分配内存），方法区主要用于存放已被加载的类信息常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="1-2-并行与并发"><a href="#1-2-并行与并发" class="headerlink" title="1.2 并行与并发"></a>1.2 并行与并发</h3><p>并行：</p><ul><li>并行性是指同一时刻内发生两个或多个事件。</li><li>并行是在不同实体上的多个事件</li></ul><p>并发：</p><ul><li>并发性是指同一时间间隔内发生两个或多个事件。</li><li>并发是在同一实体上的多个事件</li></ul><p>由此可见：并行是针对进程的，并发是针对线程的。</p><h4 id="1-2-1-并发编程3大特性"><a href="#1-2-1-并发编程3大特性" class="headerlink" title="1.2.1 并发编程3大特性"></a>1.2.1 并发编程3大特性</h4><p><strong>原子性</strong></p><p>对于成员变量a来说，如果线程A执行以下操作：</p><p>a++;</p><p>此时需要分三步执行：</p><ol><li><p>读取a的值</p></li><li><p>将a的值加1</p></li><li><p>将加1后的值赋给a</p></li></ol><p>在执行以上三步过程中，如果另一个线程B对a进行了操作，那么就不能保证原子性了。</p><p>要保证原子性，可以加锁，如<code>synchronized</code></p><p><strong>可见性</strong></p><p>要理解可见性，需要先理解cpu的高速缓存。高速缓存是cpu的一块儿缓存区。如果线程修改了某个变量的值，那么是先将修改过的值先放入缓存区，然后满足一定条件后才会同步到内存区。同步到内存区后，其他线程才可以看见变量的改变。</p><p>可见性是指，当有一个线程修改某个成员变量的值时，其他变量可以立马看到修改过的值。</p><p>比如：</p><p>int i=0,j=10;</p><p>i=j;</p><p>如果线程A执行了以上代码，这时如果还未将i等于10的结果由高速缓存区同步到内存区，那么B线程读取到的i的值就是0。</p><p>用<code>volatile</code>修饰的变量进行写操作时，会多出一些汇编代码，是以 lock为前缀的汇编指令，这个指令会有以下两种效果：</p><ol><li>将当前处理器缓存行的数据写回到系统内存。</li><li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li></ol><p>于是就强制了其他线程重新从内存中读取数据。</p><p><strong>有序性</strong></p><p>处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><p>用<strong>volatile</strong>关键字，禁止被它修饰的变量发生指令重排操作。是通过内存屏障去完成的禁止指令重排序。</p><h3 id="1-3-为什么要使用多线程"><a href="#1-3-为什么要使用多线程" class="headerlink" title="1.3 为什么要使用多线程"></a>1.3 为什么要使用多线程</h3><p><strong>从计算机底层来说</strong>：线程可以比作是轻量级的进程，是程序执行的最小单位<strong>线程间的切换和调度的成本远远小于进程</strong>。另外，多核CPU时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。<br><strong>从当代互联网发展趋势来说</strong>：现在的系统动不动就要求百万级甚至千万级的并发量，而<strong>多线程并发编程正是开发高并发系统的基础</strong>，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p><h3 id="1-4-使用多线程带来的问题"><a href="#1-4-使用多线程带来的问题" class="headerlink" title="1.4 使用多线程带来的问题"></a>1.4 使用多线程带来的问题</h3><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、上下文切换、死锁</strong>还有受限于硬件和软件的资源闲置问题。</p><h3 id="1-5-线程生命周期和状态"><a href="#1-5-线程生命周期和状态" class="headerlink" title="1.5 线程生命周期和状态"></a>1.5 线程生命周期和状态</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200427140706741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200427140740209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>由上图可以看出：线程创建之后它将处于<strong>NEW</strong>（新建）状态，调用 <strong>start（）</strong>方法后开始运行，线程这时候处于 <strong>READY</strong>（可运行）状态。可运行状态的线程<strong>获得了CPU时间片</strong>（ timeslice）后就处于<strong>RUNNING</strong>（运行）状态。</p><p>当线程执行<strong>wait（）</strong>方法之后，线程进入 <strong>WAITING</strong>（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME WAITING</strong>（超时等待）状态相当于在等待状态的基础上增加了超时限制，比如通过 <strong>sleep</strong>（ Long millis）方法或<strong>wait</strong>（ Long millis）方法可以将Java线程置于 TIMED WAITING状态。当<strong>超时时间到达后java线程将会返回到 RUNNABLE状态</strong>。当线程调用同步方法时，在<strong>没有获取到锁的情况下，线程将会进入到 BLOCKED</strong>（阻塞）状态。线程在执行Runnable的run（）方法之后将会进入到 TERMINATED（终止）状态。</p><h3 id="1-6-上下文切换"><a href="#1-6-上下文切换" class="headerlink" title="1.6 上下文切换"></a>1.6 上下文切换</h3><p>概括来说就是：当前任务在执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p><h3 id="1-7-线程死锁以及避免"><a href="#1-7-线程死锁以及避免" class="headerlink" title="1.7 线程死锁以及避免"></a>1.7 线程死锁以及避免</h3><p>学过操作系统的朋友都知道产生死锁必须具备以下四个条件</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件: 线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li></ol><p><strong>避免死锁</strong></p><ol><li>破坏互斥条件：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li><li>破坏请求与保持条件：一次性申请所有的资源。</li><li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源）释放资源则反序释放。破坏循环等待条件。</li></ol><h3 id="1-8-sleep-方法和wait-方法区别和共同点？"><a href="#1-8-sleep-方法和wait-方法区别和共同点？" class="headerlink" title="1.8 sleep()方法和wait()方法区别和共同点？"></a>1.8 sleep()方法和wait()方法区别和共同点？</h3><p>两者最主要的区别在于：</p><ul><li><p><strong>sleep方法没有释放锁，而wait方法释放了锁</strong>。</p></li><li><p>两者都可以暂停线程的执行。</p></li><li><p>wait通常被用于线程间交互/通信， sleep通常被用于暂停执行。</p></li><li><p>sleep来自Thread类，wait来自Object类</p></li><li><p>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify或者notifyAll方法。sleep方法执行完成后，线程会自动苏醒。或者可以使用 wait（long timeout)超时后线程会自动苏醒。</p></li><li><p>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用</p></li></ul><h3 id="1-9-为什么我们调用-start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#1-9-为什么我们调用-start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="1.9 为什么我们调用 start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>1.9 为什么我们调用 start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h3><p>new一个 Thread，线程进入了新建状态；调用start()方法，会启动一个线程并使线程进入了就绪状态当分配到时间片后就可以开始运行了。 <strong>start()会执行线程的相应准备工作</strong>，然后自动执行run()方法的内容，这是真正的多线程工作。<br>而直接执行run()方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。<br><strong>总结</strong>：调用 start方法方可启动线程并使线程进入就绪状态，而run方法只是 thread的一个普通方法调用，还是在主线程里执行。</p><h3 id="1-10-多线程实现的三种方式"><a href="#1-10-多线程实现的三种方式" class="headerlink" title="1.10 多线程实现的三种方式"></a>1.10 多线程实现的三种方式</h3><h4 id="1-10-1-继承Thread，重写run方法"><a href="#1-10-1-继承Thread，重写run方法" class="headerlink" title="1.10.1 继承Thread，重写run方法"></a>1.10.1 继承Thread，重写run方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-10-2-实现Runnable接口，重写run方法"><a href="#1-10-2-实现Runnable接口，重写run方法" class="headerlink" title="1.10.2 实现Runnable接口，重写run方法"></a>1.10.2 实现Runnable接口，重写run方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-10-3-实现Callable接口，重写run方法"><a href="#1-10-3-实现Callable接口，重写run方法" class="headerlink" title="1.10.3 实现Callable接口，重写run方法"></a>1.10.3 实现Callable接口，重写run方法</h4><p>有返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。执行 Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务 返回的Object了，再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程 了</p><p>Callable 可以有返回值，返回值通过 FutureTask 进行封装</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-10-4-实现接口-与继承-Thread区别"><a href="#1-10-4-实现接口-与继承-Thread区别" class="headerlink" title="1.10.4 实现接口 与继承 Thread区别"></a>1.10.4 实现接口 与继承 Thread区别</h4><p>实现接口会更好一些，因为：</p><ul><li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul><h2 id="二、线程池"><a href="#二、线程池" class="headerlink" title="二、线程池"></a>二、线程池</h2><p>线程池可以看做是线程的集合。线程生命周期的开销非常高，创建和销毁线程所花费的时间和资源可能比处理客户端的任务花费的时间和资源更多，并且还会有某些空闲线程也会占用资源。引入线程池，当请求到来时，线程池给这个请求分配一个空闲的线程，任务完成后回到线程池中等待下次任务(而不是销毁)。这样就实现了线程的重用。</p><p>所以说：线程最好是交由线程池来管理，这样可以减少对线程生命周期的管理，一定程度上提高性能。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426193949958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p><img src="/" class="lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200525204829.png"  alt=""></p><h3 id="2-1-线程池分类"><a href="#2-1-线程池分类" class="headerlink" title="2.1 线程池分类"></a>2.1 线程池分类</h3><h4 id="2-1-1-通过构造方法实现"><a href="#2-1-1-通过构造方法实现" class="headerlink" title="2.1.1 通过构造方法实现"></a>2.1.1 通过构造方法实现</h4><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426200456516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h4 id="2-1-2-通过Excutor工具类"><a href="#2-1-2-通过Excutor工具类" class="headerlink" title="2.1.2 通过Excutor工具类"></a>2.1.2 通过Excutor工具类</h4><p>JDK给我们提供了Excutor框架来使用线程池，它是线程池的基础。但是严格意义上讲 Executor 并不是一个线程池，而 只是一个执行线程的工具。真正的线程池接口是ExecutorService<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426190755264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426200432237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>该方法返回一个固定线程数量的线程池。该<strong>线程池中的线程数量始终不变</strong>。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><p>该方法返回一个<strong>可根据实际情况调整线程数量</strong>的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">             <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">             <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><p>方法返回一个只有一个线程的线程池。若<strong>多余一个任务被提交到该线程池，任务会被保存在一个任务队列中</strong>，待线程空闲，按先入先出的顺序执行队列中的任务。 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">             <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h5><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426195158760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="2-2-ThreadPoolExecutor详解"><a href="#2-2-ThreadPoolExecutor详解" class="headerlink" title="2.2 ThreadPoolExecutor详解"></a>2.2 ThreadPoolExecutor详解</h3><p>Executor调用创建的三种线程池内部也是通过传递ThreadPoolExecutor不同参数实现的。</p><h4 id="2-2-1-构造参数"><a href="#2-2-1-构造参数" class="headerlink" title="2.2.1 构造参数"></a>2.2.1 构造参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>核心线程数量</strong>：定义了最小可以同时运行的线程数量</li><li><strong>最大线程数量</strong>：当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li>允许线程空闲时间：当线程池中的线程<strong>数量大于 corePoo lsize的时候</strong>，如果这时没有新的任务提交，<strong>核心线程外的线程</strong>不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁</li><li>时间对象：keepAliveTime参数的时间单位</li><li><strong>阻塞队列</strong>：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</li><li>线程工厂：创建新线程的时候会用到</li><li>任务拒绝策略：</li></ul><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020042621072592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h4 id="2-2-2-参数要点"><a href="#2-2-2-参数要点" class="headerlink" title="2.2.2 参数要点"></a>2.2.2 参数要点</h4><p><strong>线程数量要点：</strong></p><ul><li>如果运行线程的数量<strong>少于</strong>核心线程数量，则创建新的线程处理请求</li><li>如果运行线程的数量<strong>大于</strong>核心线程数量，小于最大线程数量，则当队列满的时候才创建新的线程</li><li>如果核心线程数量<strong>等于</strong>最大线程数量，那么将创建固定大小的连接池</li><li>如果设置了最大线程数量为无穷，那么允许线程池适合任意的并发数量</li></ul><p><strong>线程空闲时间要点：</strong></p><p>当前线程数大于核心线程数，如果空闲时间已经超过了，那该线程会销毁。</p><p><strong>排队策略要点：</strong></p><ul><li>同步移交：不会放到队列中，而是等待线程执行它。如果当前线程没有执行，很可能会新开一个线程执行。</li><li>无界限策略：如果核心线程都在工作，该线程会放到队列中。所以线程数不会超过核心线程数</li><li>有界限策略：可以避免资源耗尽，但是一定程度上减低了吞吐量</li></ul><p>当线程关闭或者线程数量满了和队列饱和了，就有拒绝任务的情况了：</p><p><strong>拒绝任务策略：</strong></p><ul><li>直接抛出异常</li><li>使用调用者的线程来处理</li><li>直接丢掉这个任务</li><li>丢掉最老的任务</li></ul><h4 id="2-2-3-拒绝策略"><a href="#2-2-3-拒绝策略" class="headerlink" title="2.2.3 拒绝策略"></a>2.2.3 拒绝策略</h4><h5 id="AbortPolicy（中止策略）"><a href="#AbortPolicy（中止策略）" class="headerlink" title="AbortPolicy（中止策略）"></a>AbortPolicy（中止策略）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicstaticclass AbortPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="function">thrownew <span class="title">RejectedExecutionException</span><span class="params">(<span class="string">"Task "</span> + r.toString()</span> +</span></span><br><span class="line"><span class="function">                                                 " rejected from " +</span></span><br><span class="line"><span class="function">                                                 e.<span class="title">toString</span><span class="params">()</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>功能：当触发拒绝策略时，<strong>直接抛出拒绝执行的异常</strong>，中止策略的意思也就是打断当前执行流程</p><p>使用场景：这个就没有特殊的场景了，但是一点要正确处理抛出的异常。ThreadPoolExecutor中<strong>默认的策略</strong>就是AbortPolicy，<strong>ExecutorService接口的系列ThreadPoolExecutor因为都没有显示的设置拒绝策略，所以默认的都是这个</strong>。但是请注意，ExecutorService中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。</p><h5 id="CallerRunsPolicy（调用者运行策略）"><a href="#CallerRunsPolicy（调用者运行策略）" class="headerlink" title="CallerRunsPolicy（调用者运行策略）"></a>CallerRunsPolicy（调用者运行策略）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicstaticclass CallerRunsPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>功能：当触发拒绝策略时，<strong>只要线程池没有关闭，就由提交任务的当前线程处理</strong>。</p><p>使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是<strong>提交的任务一定会被运行</strong>，但是由于是调用者线程自己执行的，当多次提交任务时，就会<strong>阻塞后续任务执行</strong>，性能和效率自然就慢了。</p><h5 id="DiscardOldestPolicy（丢弃策略）"><a href="#DiscardOldestPolicy（丢弃策略）" class="headerlink" title="DiscardOldestPolicy（丢弃策略）"></a>DiscardOldestPolicy（丢弃策略）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicstaticclass DiscardPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>功能：如果线程池未关闭，就弹出队列头部的元素，然后尝试执行</p><p>使用场景：这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是<strong>丢弃的是老的未执行的任务</strong>，而且是待执行优先级较高的任务。基于这个特性，我能想到的场景就是，<strong>发布消息，和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了</strong>。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较</p><h4 id="2-2-4-阻塞队列"><a href="#2-2-4-阻塞队列" class="headerlink" title="2.2.4 阻塞队列"></a>2.2.4 阻塞队列</h4><p><strong>无界队列</strong>（newFixedThreadPool、newSingleThreadExecutor）</p><p><strong>队列大小无限制，常用的为无界的LinkedBlockingQueue</strong>，使用该队列做为阻塞队列时要尤其当心，<strong>当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM</strong>。阅读代码发现，Executors.newFixedThreadPool 采用就是 LinkedBlockingQueue，当QPS很高，发送数据很大，大量的任务被添加到这个无界LinkedBlockingQueue 中，导致cpu和内存飙升服务器挂掉。</p><p><strong>有界队列</strong></p><p>常用的有两类，一类是遵循<strong>FIFO原则的队列如ArrayBlockingQueue</strong>，另一类是<strong>优先级队列如PriorityBlockingQueue</strong>。PriorityBlockingQueue中的优先级由任务的Comparator决定。<br>使用有界队列时<strong>队列大小需和线程池大小互相配合</strong>，线程池较小有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。</p><p><strong>同步移交队列</strong>（newCachedThreadPool）</p><p>如果<strong>不希望任务在队列中等待而是希望将任务直接移交给工作线程</strong>，可使用SynchronousQueue作为等待队列。<strong>SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制</strong>。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列</p><h3 id="2-3-execute执行方法"><a href="#2-3-execute执行方法" class="headerlink" title="2.3 execute执行方法"></a>2.3 execute执行方法</h3><p>先了解下Executor与Callable</p><h4 id="2-3-1-实现-Runnable接口和-Callable接口的区别"><a href="#2-3-1-实现-Runnable接口和-Callable接口的区别" class="headerlink" title="2.3.1 实现 Runnable接口和 Callable接口的区别"></a>2.3.1 实现 Runnable接口和 Callable接口的区别</h4><p>Runnable自Java1.0以来一直存在，但 Callable仅在Java1.5中引入目的就是为了来处理 Runnable不支持的用例。<br><strong>Runnable接口不会返回结果或抛出检查异常，但是 Callable接口可以。</strong><br>所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable接口，这样代码看起来会更加简洁。</p><p>工具类 Executors可以实现 Runnable对象和 Callable对象之间的相互转换。Executors callable（ Runnable task ） 或 Executors, callable（Runnable task, object resule））</p><h4 id="2-3-2-execute-和submit方法区别"><a href="#2-3-2-execute-和submit方法区别" class="headerlink" title="2.3.2 execute()和submit方法区别"></a>2.3.2 execute()和submit方法区别</h4><p><strong>submit方法</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426212805147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><strong>execute()方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//如果线程池中运行的线程数量&lt;corePoolSize，则创建新线程来处理请求，即使其他辅助线程是空闲的。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果线程池中运行的线程数量&gt;=corePoolSize，且线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列中，就再次检查线程池的状态，</span></span><br><span class="line">      <span class="comment">// 1.如果线程池不是RUNNING状态，且成功从阻塞队列中删除任务，则该任务由当前 RejectedExecutionHandler 处理。</span></span><br><span class="line">      <span class="comment">// 2.否则如果线程池中运行的线程数量为0，则通过addWorker(null, false)尝试新建一个线程，新建线程对应的任务为null。</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果以上两种case不成立，即没能将任务成功放入阻塞队列中，且addWoker新建线程失败，则该任务由当前 RejectedExecutionHandler 处理。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="三、Java锁"><a href="#三、Java锁" class="headerlink" title="三、Java锁"></a>三、Java锁</h2><h3 id="3-1-锁的分类"><a href="#3-1-锁的分类" class="headerlink" title="3.1 锁的分类"></a>3.1 锁的分类</h3><h4 id="3-1-1-同步锁与死锁"><a href="#3-1-1-同步锁与死锁" class="headerlink" title="3.1.1 同步锁与死锁"></a>3.1.1 同步锁与死锁</h4><p><strong>同步锁</strong><br>当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程 同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可 以使用synchronized关键字来取得一个对象的同步锁。<br><strong>死锁</strong><br>何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放</p><h4 id="3-1-2-乐观锁"><a href="#3-1-2-乐观锁" class="headerlink" title="3.1.2 乐观锁"></a>3.1.2 乐观锁</h4><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为 别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数 据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新）， 如果失败则要重复读-比较-写的操作。<br>java 中的乐观锁基本都是通过 <strong>CAS 操作实现</strong>的，CAS 是一种更新的原子操作，比较当前值跟传入 值是否一样，一样则更新，否则失败。 </p><h4 id="3-1-3-悲观锁"><a href="#3-1-3-悲观锁" class="headerlink" title="3.1.3 悲观锁"></a>3.1.3 悲观锁</h4><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人 会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block（阻塞）直到拿到锁。 java中的悲观锁就是<code>Synchronized</code>,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到， 才会转换为悲观锁，如<code>RetreenLock</code>。 </p><hr><p>Java并发包提供的加锁模式分为独占锁和共享锁。 </p><h4 id="3-1-4-独占锁"><a href="#3-1-4-独占锁" class="headerlink" title="3.1.4 独占锁"></a>3.1.4 独占锁</h4><p>独占锁模式下，每次只能有一个线程能持有锁，<code>ReentrantLock</code> 就是以独占方式实现的互斥锁。 独占锁是一种<strong>悲观</strong>保守的加锁策略，它避免了读/读冲突，如果<strong>某个只读线程获取锁，则其他读线 程都只能等待</strong>，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。 </p><h4 id="3-1-5-共享锁"><a href="#3-1-5-共享锁" class="headerlink" title="3.1.5 共享锁"></a>3.1.5 共享锁</h4><p> 共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：<code>ReadWriteLock</code>。共享锁则是一种 <strong>乐观</strong>锁，它放宽了加锁策略，<strong>允许多个执行读操作的线程同时访问共享资源</strong>。 </p><ol><li>AQS的内部类Node定义了两个常量SHARED和EXCLUSIVE，他们分别标识 AQS队列中等 待线程的锁获取模式。 <ol start="2"><li>java的并发包中提供了<code>ReadWriteLock</code>，读-写锁。它允许一个资源可以被多个读操作访问， 或者被一个 写操作访问，但两者不能同时进行。 </li></ol></li></ol><hr><h4 id="3-1-6-公平锁与非公平锁"><a href="#3-1-6-公平锁与非公平锁" class="headerlink" title="3.1.6 公平锁与非公平锁"></a>3.1.6 公平锁与非公平锁</h4><p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁， ReentrantLock在构造函数中提供了是否公平锁的初始化方式来定义公平锁。 </p><p>JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了 是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非 程序有特殊需要，否则常用非公平锁的分配机制。</p><hr><h4 id="3-1-7-可重入锁"><a href="#3-1-7-可重入锁" class="headerlink" title="3.1.7 可重入锁"></a>3.1.7 可重入锁</h4><p>本文里面讲的是广义上的可重入锁，而不是单指JAVA下的ReentrantLock。可重入锁，也叫 做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受 影响。在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁。 </p><h4 id="3-1-8-分段锁"><a href="#3-1-8-分段锁" class="headerlink" title="3.1.8 分段锁"></a>3.1.8 分段锁</h4><p>分段锁也并非一种实际的锁，而是一种思想ConcurrentHashMap是学习分段锁的好实践 </p><h3 id="3-2-锁的实现"><a href="#3-2-锁的实现" class="headerlink" title="3.2 锁的实现"></a>3.2 锁的实现</h3><h4 id="3-2-1-Volatile关键字"><a href="#3-2-1-Volatile关键字" class="headerlink" title="3.2.1 Volatile关键字"></a>3.2.1 Volatile关键字</h4><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来<strong>确保将变量的更新操作通知到其他 线程</strong>。volatile 变量具备两种特性，volatile变量不会被缓存在寄存器或者对其他处理器不可见的 地方，因此在读取volatile类型的变量时总会返回新写入的值。 </p><p><strong>可见性</strong><br>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的 值对于其他线程是可以立即获取的。 </p><p><strong>禁止重排序</strong><br>volatile 禁止了指令重排。 </p><p><strong>比sychronized关键字更轻量级的同步机制</strong><br>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一 种比sychronized关键字更轻量级的同步机制。volatile适<strong>合这种场景：一个变量被多个线程共 享，线程直接给这个变量赋值</strong>。 </p><p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有 多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。 </p><p><strong>适用场景</strong><br>值得说明的是对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量， 但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。在某些场景下可以 代替Synchronized。但是,volatile的不能完全取代Synchronized的位置，只有在一些特殊的场景下，才能适用volatile。<br>总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安 全：   </p><ol><li>对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）。 </li><li>该变量没有包含在具有其他变量的不变式中，也就是说，不同的volatile变量之间，不 能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile</li></ol><p> <strong>与Synchronized区别</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200427133137535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h4 id="3-2-2-Synchronized"><a href="#3-2-2-Synchronized" class="headerlink" title="3.2.2 Synchronized"></a>3.2.2 Synchronized</h4><p>Synchronized属于<strong>独占式的悲观锁，同时属于可重 入锁</strong>。<br><strong>作用范围</strong></p><ol><li>作用于方法时，锁住的是对象的实例(this)； </li><li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen （jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁， 会锁所有调用该方法的线程； </li><li>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列， 当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。 </li></ol><p><strong>核心组件</strong></p><ol><li>Wait Set：调用wait方法被阻塞的线程被放置在这里； </li><li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中； </li><li>Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中； </li><li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck； </li><li>Owner：当前已经获取到所有资源的线程被称为Owner；  </li><li>!Owner：当前释放锁的线程。 </li></ol><p><strong>实现</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200427112041199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><ol><li><p>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下， <strong>ContentionList会被大量的并发线程进行CAS访问</strong>，为了降低对尾部元素的竞争，JVM会将 一部分线程移动到EntryList中作为候选竞争线程。 </p></li><li><p>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并<strong>指定 EntryList中的某个线程为OnDeck线程</strong>（一般是先进去的那个线程）。 </p></li><li><p>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把<strong>锁竞争的权利交给 OnDeck</strong>， OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在 JVM中，也把这种选择行为称之为“竞争切换”。 </p></li><li><p>OnDeck线程获取到锁资源后会变为Owner线程，而没有得到锁资源的仍然停留在EntryList 中。如果<strong>Owner线程被wait方法阻塞，则转移到WaitSet队列中</strong>，直到某个时刻通过notify 或者notifyAll唤醒，会重新进去EntryList中。 </p></li><li><p>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统 来完成的（Linux内核下采用pthread_mutex_lock内核函数实现的）。 </p></li><li><p>Synchronized是非公平锁。 Synchronized在线程进入ContentionList时，等待的线程会先 尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是 不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁 资源。 参考：<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">https://blog.csdn.net/zqz_zqz/article/details/70233767</a> </p></li><li><p>每个<strong>对象都有个 monitor 对象</strong>，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加 上monitorenter和monitorexit指令来实现的，方法加锁是通过一个标记位来判断的 </p></li><li><p>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线 程加锁消耗的时间比有用操作消耗的时间更多。 </p></li><li><p>Java1.6，synchronized进行了很多的优化，有<strong>适应自旋、锁消除、锁粗化、轻量级锁及偏向 锁</strong>等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做 了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。 </p></li><li><p>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀； </p><p><strong>双重检验所锁实现单例模式</strong><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200427132358957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p></li></ol><h4 id="3-2-3-RetreenLock"><a href="#3-2-3-RetreenLock" class="headerlink" title="3.2.3 RetreenLock"></a>3.2.3 RetreenLock</h4><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种<strong>可重入锁</strong>，除了能完 成 synchronized 所能完成的所有工作外，还提供了诸如<strong>可响应中断锁、可轮询锁请求、定时锁</strong>等 <strong>避免多线程死锁</strong>的方法。 </p><p><strong>Lock主要方法</strong></p><ol><li>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经 被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁. </li><li>boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和 lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一 直等待, 在未获得锁之前,当前线程并不继续向下执行.  </li><li>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程 并不持有锁, 却执行该方法, 可能导致异常的发生. </li><li>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定， 当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。 </li><li>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行lock方法的次 数。 </li><li>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个 线程获得锁，此时返回的是9 </li><li>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线 程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了 condition对象的 await方法，那么此时执行此方法返回10 </li><li>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件 (condition)，对于指定contidion对象，有多少线程执行了condition.await方法 </li><li>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁 </li><li>hasQueuedThreads()：是否有线程等待此锁 </li><li>isFair()：该锁是否公平锁 </li><li>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分 别是false和true </li><li>isLock()：此锁是否有任意线程占用 </li><li>lockInterruptibly（）：如果当前线程未被中断，获取锁 </li><li>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁 </li><li>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持， 则获取该锁</li></ol><p><strong>ReentrantLock实现</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123; </span><br><span class="line">            <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line"> <span class="comment">//Lock lock=new ReentrantLock(true);//公平锁 </span></span><br><span class="line">            <span class="comment">//Lock lock=new ReentrantLock(false);//非公平锁 </span></span><br><span class="line">           <span class="keyword">private</span> Condition condition=lock.newCondition();<span class="comment">//创建Condition </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123; </span><br><span class="line">             <span class="keyword">try</span> &#123; </span><br><span class="line">               lock.lock();<span class="comment">//lock加锁 </span></span><br><span class="line">  <span class="comment">//1：wait 方法等待： </span></span><br><span class="line">            <span class="comment">//System.out.println("开始wait"); </span></span><br><span class="line">            condition.await(); </span><br><span class="line"><span class="comment">//通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁 </span></span><br><span class="line"> <span class="comment">//:2：signal方法唤醒 </span></span><br><span class="line"> condition.signal();<span class="comment">//condition对象的signal方法可以唤醒wait 线程 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line"> System.out.println(<span class="string">"ThreadName="</span> + Thread.currentThread().getName()+ (<span class="string">" "</span> + (i + <span class="number">1</span>))); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">             e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123; </span><br><span class="line">            lock.unlock(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Condition类与Object类区别</strong></p><ol><li>Condition类的awiat方法和Object类的wait方法等效 <ol start="2"><li>Condition类的signal方法和Object类的notify方法等效 </li><li>Condition类的signalAll方法和Object类的notifyAll方法等效 </li><li>ReentrantLock类可以唤醒指定条件的线程，而object的唤醒是随机的 </li></ol></li></ol><p><strong>tryLock与 lock 和 lockInterruptibly区别</strong></p><ol><li>tryLock能获得锁就返回true，不能就立即返回false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回false <ol start="2"><li>lock能获得锁就返回true，不能的话一直等待获得锁 </li><li>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程， lock不会抛出异常，而lockInterruptibly会抛出异常</li></ol></li></ol><h4 id="3-2-4-ReentrantLock与synchronized区别"><a href="#3-2-4-ReentrantLock与synchronized区别" class="headerlink" title="3.2.4 ReentrantLock与synchronized区别"></a>3.2.4 ReentrantLock与synchronized区别</h4><ol><li>ReentrantLock 通过方法lock()与unlock()来进行加锁与解锁操作，与synchronized会 被 JVM 自动解锁机制不同，<strong>ReentrantLock 加锁后需要手动进行解锁</strong>。为了避免程序出 现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操 作。 </li><li>ReentrantLock相比synchronized的优势是<strong>可中断、公平锁、多个锁</strong>。这种情况下需要 使用ReentrantLock。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020042711585666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><h4 id="3-2-5-ReentrantReadWriteLock"><a href="#3-2-5-ReentrantReadWriteLock" class="headerlink" title="3.2.5 ReentrantReadWriteLock"></a>3.2.5 ReentrantReadWriteLock</h4>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如 果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写 锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。 </li></ol><p><strong>读锁</strong><br>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 </p><p> <strong>写锁</strong><br>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。</p><p>总之，读的时候上 读锁，写的时候上写锁！<br>Java 中读写锁有个接口 java.util.concurrent.locks.ReadWriteLock ，也有具体的实现 <code>ReentrantReadWriteLock</code></p><h3 id="3-3-锁优化"><a href="#3-3-锁优化" class="headerlink" title="3.3 锁优化"></a>3.3 锁优化</h3><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h4 id="3-3-1-减少锁持有时间"><a href="#3-3-1-减少锁持有时间" class="headerlink" title="3.3.1 减少锁持有时间"></a>3.3.1 减少锁持有时间</h4><p> 只用在有线程安全要求的程序上加锁 </p><h4 id="3-3-2-减小锁粒度"><a href="#3-3-2-减小锁粒度" class="headerlink" title="3.3.2 减小锁粒度"></a>3.3.2 减小锁粒度</h4><p> 将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。 降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。典型的减小锁粒度的案例就是 ConcurrentHashMap。 </p><h4 id="3-3-3-锁分离"><a href="#3-3-3-锁分离" class="headerlink" title="3.3.3 锁分离"></a>3.3.3 锁分离</h4><p> 常见的锁分离就是读写锁ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互 斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发Java 五] JDK并发包1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如 LinkedBlockingQueue 从头部取出，从尾部放数据 </p><h4 id="3-3-4-自旋锁"><a href="#3-3-4-自旋锁" class="headerlink" title="3.3.4 自旋锁"></a>3.3.4 自旋锁</h4><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h4 id="3-3-5-锁消除"><a href="#3-3-5-锁消除" class="headerlink" title="3.3.5 锁消除"></a>3.3.5 锁消除</h4><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><h4 id="3-3-6-锁粗化"><a href="#3-3-6-锁粗化" class="headerlink" title="3.3.6 锁粗化"></a>3.3.6 锁粗化</h4><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><h3 id="3-4-四种锁状态"><a href="#3-4-四种锁状态" class="headerlink" title="3.4 四种锁状态"></a>3.4 四种锁状态</h3><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。 </p><h4 id="3-4-1-重量级锁"><a href="#3-4-1-重量级锁" class="headerlink" title="3.4.1 重量级锁"></a>3.4.1 重量级锁</h4><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又 是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要<strong>从用 户态转换到核心态，这个成本非常高</strong>，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为 “重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。 JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和 “偏向锁”。</p><h4 id="3-4-2-轻量级锁"><a href="#3-4-2-轻量级锁" class="headerlink" title="3.4.2 轻量级锁"></a>3.4.2 轻量级锁</h4><p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，它使用 CAS 操作来避免重量级锁使用互斥量的开销。但是，首先需要强调一点的是， 轻量级锁并不是用来代替重量级锁的，它的本意是在<strong>没有多线程竞争的前提下，减少传统的重量 级锁使用产生的性能消耗</strong>。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所<strong>适应的场 景是线程交替执行同步块</strong>的情况（整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步），<strong>如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀 为重量级锁</strong>（ CAS 失败了再改用互斥量进行同步）。 </p><h4 id="3-4-3-偏向锁"><a href="#3-4-3-偏向锁" class="headerlink" title="3.4.3 偏向锁"></a>3.4.3 偏向锁</h4><p>偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起 来让这个线程得到了偏护。这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。轻 量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进 一步提高性能。 </p><h4 id="3-4-4-无锁"><a href="#3-4-4-无锁" class="headerlink" title="3.4.4 无锁"></a>3.4.4 无锁</h4><h2 id="四、CAS（比较并交换）"><a href="#四、CAS（比较并交换）" class="headerlink" title="四、CAS（比较并交换）"></a>四、CAS（比较并交换）</h2><blockquote><p>比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p></blockquote><p>它包含 3 个参数 CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N；如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当 前线程什么都不做。最后，CAS返回当前V的真实值。 </p><p>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时 使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。<strong>失败的线程不会被挂起</strong>，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理， <strong>CAS操作即使没有锁</strong>，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。 </p><h3 id="4-1-CAS失败的两种情况"><a href="#4-1-CAS失败的两种情况" class="headerlink" title="4.1 CAS失败的两种情况"></a>4.1 CAS失败的两种情况</h3><p><strong>失败放弃</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426180037775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p><strong>失败自旋（循环再试）</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426180122522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426180149190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="4-2-原子包Atomic"><a href="#4-2-原子包Atomic" class="headerlink" title="4.2 原子包Atomic"></a>4.2 原子包Atomic</h3><p>原子变量类在<code>java.util.concurrent.atomic</code>包下<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426180344581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>我们可以对其进行分类：</p><ul><li>基本类型：<ul><li>AtomicBoolean：布尔型</li><li>AtomicInteger：整型</li><li>AtomicLong：长整型</li></ul></li><li>数组：<ul><li>AtomicIntegerArray：数组里的整型</li><li>AtomicLongArray：数组里的长整型</li><li>AtomicReferenceArray：数组里的引用类型</li></ul></li><li>引用类型：<ul><li>AtomicReference：引用类型</li><li>AtomicStampedReference：带有版本号的引用类型</li><li>AtomicMarkableReference：带有标记位的引用类型</li></ul></li><li>对象的属性：<ul><li>AtomicIntegerFieldUpdater：对象的属性是整型</li><li>AtomicLongFieldUpdater：对象的属性是长整型</li><li>AtomicReferenceFieldUpdater：对象的属性是引用类型</li></ul></li></ul><p>JDK8新增DoubleAccumulator、LongAccumulator、DoubleAdder、LongAdder是对AtomicLong等类的改进。比如LongAccumulator与LongAdder在高并发环境下比AtomicLong更高效。</p><p><strong>AtomicInteger实例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享变量(使用AtomicInteger来替代Synchronized锁)</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Atomic包里的类基本都是使用Unsafe实现的包装类。<br>Unsafe里边有几个我们喜欢的方法(CAS)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一和第二个参数代表对象的实例以及地址，第三个参数代表期望值，第四个参数代表更新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p>从原理上概述就是：Atomic包的类的实现绝大部分调用Unsafe的方法，而<strong>Unsafe底层实际上是调用C代码</strong>，C代码调用汇编，最后生成出一条CPU指令cmpxchg，完成操作。这也就为啥CAS是原子性的，因为它是一条<strong>CPU指令，不会被打断</strong>。</p><p><strong>compareAndSwapInt实例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">           <span class="keyword">return</span> value;   </span><br><span class="line">     &#125;   </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  <span class="comment">//CAS自旋，一直尝试，直达成功 </span></span><br><span class="line">           <span class="keyword">int</span> current = get();   </span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;   </span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))   </span><br><span class="line">                <span class="keyword">return</span> current;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-ABA问题"><a href="#4-3-ABA问题" class="headerlink" title="4.3 ABA问题"></a>4.3 ABA问题</h3><p>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时 刻比较并替换，那么在这个时间差类会导致数据的变化。 </p><p><strong>描述</strong><br>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操 作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过 程就是没有问题的。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426181530314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p> <strong>解决</strong><br>部分乐观锁的实现是通过版本号（version）的方式来解决ABA问题，乐观锁每次在执行数据的修 改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本 号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问 题，因为版本号只会增加不会减少。 </p><h2 id="五、AQS（抽象队列同步器）"><a href="#五、AQS（抽象队列同步器）" class="headerlink" title="五、AQS（抽象队列同步器）"></a>五、AQS（抽象队列同步器）</h2><p>AbstractQueuedSynchronizer类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问 共享资源的同步器框架，许多同步类实现都依赖于它，Lock的子类实现都是基于AQS的。如常用的 ReentrantLock/Semaphore/CountDownLatch。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426181834494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="5-1-原理"><a href="#5-1-原理" class="headerlink" title="5.1 原理"></a>5.1 原理</h3><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC80LzI1LzE2MmZjZDM0ZGQ2MjFlMzI?x-oss-process=image/format,png"  alt="https://user-gold-cdn.xitu.io/2018/4/25/162fcd34dd621e32?w=1864&amp;h=4179&amp;f=png&amp;s=799799"><br>通读了一遍，可以总结出以下比较关键的信息：</p><ul><li>AQS其实就是一个可以给我们实现锁的框架</li><li>内部实现的关键是：先进先出的队列、state状态</li><li>定义了内部类ConditionObject</li><li>拥有两种线程模式<ul><li>独占模式</li><li>共享模式</li></ul></li><li>在LOCK包中的相关锁(常用的有ReentrantLock、ReadWriteLock)都是基于AQS来构建</li><li>一般我们叫AQS为同步器</li></ul><h2 id="六、同步工具类"><a href="#六、同步工具类" class="headerlink" title="六、同步工具类"></a>六、同步工具类</h2><p>Java为我们提供了三个同步工具类：</p><ul><li>CountDownLatch(闭锁、线程计数器)</li><li>CyclicBarrier(栅栏)</li><li>Semaphore(信号量)<br>这几个工具类是为了能够更好控制线程之间的通讯问题</li></ul><h3 id="6-1-CountDownLatch"><a href="#6-1-CountDownLatch" class="headerlink" title="6.1 CountDownLatch"></a>6.1 CountDownLatch</h3><p>CountDownLatch是一个同步的辅助类，允许一个或多个线程一直等待，直到其它线程完成它们的操作。（任务A需要等待其它4个任务完成才能执行）<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426173850288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>它常用的API其实就两个:await()和countDown()<br><strong>用法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3y线程启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里调用的是await()不是wait()</span></span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"等待其它线程执行完毕才开始"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他线程启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"其它线程执行完毕"</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-CyclicBarrier"><a href="#6-2-CyclicBarrier" class="headerlink" title="6.2 CyclicBarrier"></a>6.2 CyclicBarrier</h3><p>CyclicBarrier允许一组线程互相等待，直到到达某个<strong>公共屏障点</strong>。叫做cyclic是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用(对比于CountDownLatch是不能重用的)</p><p><strong>用法</strong><br>CountDownLatch注重的是等待其他线程完成，CyclicBarrier注重的是：当线程到达某个状态后，暂停下来等待其他线程，所有线程均到达以后，继续执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CyclicBarrier CyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                <span class="keyword">if</span> (name.equals(<span class="string">"Thread-0"</span>)) &#123;</span><br><span class="line">                    name = <span class="string">"线程0"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    name = <span class="string">"线程1"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(name + <span class="string">"等待执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    CyclicBarrier.await();</span><br><span class="line">                    System.out.println(name+<span class="string">"可以开始执行"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-Semaphore"><a href="#6-3-Semaphore" class="headerlink" title="6.3 Semaphore"></a>6.3 Semaphore</h3><p>Semaphore(信号量)实际上就是可以控制同时访问的线程个数，它维护了一组”许可证”。</p><ul><li>当调用acquire()方法时，会消费一个许可证。如果没有许可证了，会阻塞起来</li><li>当调用release()方法时，会添加一个许可证。</li></ul><p>这些”许可证”的个数其实就是一个count变量</p><p><strong>用法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设有50个同时来到酸奶店门口</span></span><br><span class="line">        <span class="keyword">int</span> nums = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 酸奶店只能容纳10个人同时挑选酸奶</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 有"号"的才能进酸奶店挑选购买</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"顾客"</span> + finalI + <span class="string">"在挑选商品，购买..."</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 假设挑选了xx长时间，购买了</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 归还一个许可，后边的就可以进来购买了</span></span><br><span class="line">                    System.out.println(<span class="string">"顾客"</span> + finalI + <span class="string">"购买完毕了..."</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>Java为我们提供了三个同步工具类：</p><ul><li>CountDownLatch(闭锁)某个线程等待其他线程执行完毕后，它才执行(其他线程等待某个线程执行完毕后，它才执行)</li><li>CyclicBarrier(栅栏)一组线程互相等待至某个状态，这组线程再同时执行。</li><li>Semaphore(信号量)控制一组线程同时执行。<h2 id="七、ThreadLocal"><a href="#七、ThreadLocal" class="headerlink" title="七、ThreadLocal"></a>七、ThreadLocal</h2>ThreadLocal 提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离。</li></ul><p>ThreadLocal设计的目的是为了能够在当前线程中有属于自己的变量，并<strong>不是为了解决并发或者共享变量的问题</strong></p><h3 id="7-1-实现原理"><a href="#7-1-实现原理" class="headerlink" title="7.1 实现原理"></a>7.1 实现原理</h3><p>Set和Get方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 得到当前线程对象</span></span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 这里获取ThreadLocalMap</span></span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果map存在，则将当前线程对象t作为key，要存储的对象作为value存到map里面去</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过currentThread()方法可以获得Thread对象t，通过getMap(t)就可以获得当前的ThreadLocalMap对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//....很长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap是ThreadLocal的一个内部类。用Entry类来进行存储。我们的值都是存储到这个Map上的，key是当前ThreadLocal对象，而value为要存储的对象！<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426172336356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="7-2-内存泄漏问题"><a href="#7-2-内存泄漏问题" class="headerlink" title="7.2 内存泄漏问题"></a>7.2 内存泄漏问题</h3><p>ThreadLocal的对象关系引用图：<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426172607723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><blockquote><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426172808499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="这里是引用"></p></blockquote><p><strong>另一种说法：</strong><br>ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><p>想要避免内存泄露就要手动remove()</p><h3 id="7-3-总结"><a href="#7-3-总结" class="headerlink" title="7.3 总结"></a>7.3 总结</h3><ol><li>每个Thread维护着一个ThreadLocalMap的引用</li><li>ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储</li><li>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象</li><li>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</li><li>ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。</li></ol><p>正因为这个原理，所以ThreadLocal能够实现“数据隔离”，获取当前线程的局部变量值，不受其他线程影响。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发记录</title>
      <link href="/2020/04/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/Dubbo%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/04/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/Dubbo%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>应该说这个项目完成的不是特别理想，有一些模块还没完成，但单点登录、redis缓存、购物车的设计部分值得参考，以及项目如何分包，结构的描述都挺详细的，对于微服务分布式入门来说，还是挺有价值的。<br>可以访问我个人网站<a href="http://hofe.work">hofe 的个人网站</a>，阅读体验更佳，需要源代码，有疑问的也可在评论区留言</p></blockquote><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>用到的技术</p><p>微服务架构：Dubbo+zookeeper </p><p>中间件：SpringBoot+SpringMVC+Sprint+MyBatis</p><p>数据库：MySQL</p><p>分布式文件系统：FastDFS</p><p>搜索引擎：Solr</p><p>分布式缓存：Redis</p><p>消息中间件：RabbitMQ</p><h2 id="一、项目骨架搭建"><a href="#一、项目骨架搭建" class="headerlink" title="一、项目骨架搭建"></a>一、项目骨架搭建</h2><h3 id="1-1-新建一个maven项目以及多个maven模块"><a href="#1-1-新建一个maven项目以及多个maven模块" class="headerlink" title="1.1 新建一个maven项目以及多个maven模块"></a>1.1 新建一个maven项目以及多个maven模块</h3><p>只作为一个目录使用，不需要配置pom，可以删除src文件。</p><p>如在dubbo-shop项目下新建shop-service模块，将Parent设为none。同样步骤创建shop-basic、shop-api、shop-web模块。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200415163806195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200415163822406.png"  alt="在这里插入图片描述"></p><h4 id="1-1-1-在maven模块下新建maven模块"><a href="#1-1-1-在maven模块下新建maven模块" class="headerlink" title="1.1.1 在maven模块下新建maven模块"></a>1.1.1 在maven模块下新建maven模块</h4><p>在shop-basic模块中新建entity，需要注意的是entity模块目录在shop-basic至下。同理创建common、mapper模块<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200415162428245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h4 id="1-1-2-在maven模块下新建springboot模块"><a href="#1-1-2-在maven模块下新建springboot模块" class="headerlink" title="1.1.2 在maven模块下新建springboot模块"></a>1.1.2 在maven模块下新建springboot模块</h4><p>在shop-service下新建springboot模块。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200415164631301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200415164741278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200415165016740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200415165035144.png"  alt="在这里插入图片描述"></p><h3 id="1-2-初始项目结构"><a href="#1-2-初始项目结构" class="headerlink" title="1.2 初始项目结构"></a>1.2 初始项目结构</h3><p>dubbo-shop</p><ul><li>shop-api</li><li>shop-service<ul><li>profuct-service（SpringBoot）</li></ul></li><li>shop-web<ul><li>backend（SpringBoot）</li></ul></li><li>shop-basic<ul><li>entity</li><li>common    存放公共组件如dao的泛型接口</li><li>dao<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200415170223387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></li></ul></li></ul><h3 id="1-3-basic中的公用组件"><a href="#1-3-basic中的公用组件" class="headerlink" title="1.3 basic中的公用组件"></a>1.3 basic中的公用组件</h3><h4 id="1-3-1-common组件"><a href="#1-3-1-common组件" class="headerlink" title="1.3.1 common组件"></a>1.3.1 common组件</h4><h5 id="IBaseDao和IBaseService"><a href="#IBaseDao和IBaseService" class="headerlink" title="IBaseDao和IBaseService"></a>IBaseDao和IBaseService</h5><p>由于增删查改等操作比较频繁且可重用性大，故在common模块中新建com.hofe.common.base目录，新建dao与service接口；在com.hofe.common.impl中实现service接口的抽象类。<br>dao与service接口代码相同</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">queryById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">queryAllByLimit</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> limit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">queryAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(T record)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(T record)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="serviceImpl"><a href="#serviceImpl" class="headerlink" title="serviceImpl"></a>serviceImpl</h5><p>由于使用泛型，无法返回准确类型，故将其abstract抽象，由继承的子类返回类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hofe.common.base.IBaseDao;</span><br><span class="line"><span class="keyword">import</span> com.hofe.common.base.IBaseService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServiceImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IBaseService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IBaseDao&lt;T&gt; <span class="title">getBaseDao</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">queryById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseDao().queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">queryAllByLimit</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseDao().queryAllByLimit(offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">queryAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseDao().queryAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(T record)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseDao().insert(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(T record)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseDao().update(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseDao().deleteById(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-记录下用到的端口号"><a href="#1-4-记录下用到的端口号" class="headerlink" title="1.4 记录下用到的端口号"></a>1.4 记录下用到的端口号</h3><p>dubbo管理中心端口：2180<br>zookeeper端口：2181<br>fdfs文件服务器：<br>tracker server port: 22122<br>storage_server: 23000<br>RabbitMQ: 15672(admin:admin)</p><h2 id="二、商品类别接口服务"><a href="#二、商品类别接口服务" class="headerlink" title="二、商品类别接口服务"></a>二、商品类别接口服务</h2><h3 id="2-1-basic模块配置"><a href="#2-1-basic模块配置" class="headerlink" title="2.1 basic模块配置"></a>2.1 basic模块配置</h3><p>这一模块我后来回头来看，其实不是特别需要，虽然重用了很多代码，但对小规模的项目来说，可以不需要，不利于项目的维护。</p><h4 id="2-4-1-entity配置"><a href="#2-4-1-entity配置" class="headerlink" title="2.4.1 entity配置"></a>2.4.1 entity配置</h4><p>可以用easycode插件根据数据库生成实体类。注意类需要实现Serializable接口</p><h4 id="2-4-2-dao配置"><a href="#2-4-2-dao配置" class="headerlink" title="2.4.2 dao配置"></a>2.4.2 dao配置</h4><p><strong>dao类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TProductTypeDao</span> <span class="keyword">extends</span> <span class="title">IBaseDao</span>&lt;<span class="title">TProductType</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于IBaseService有具体实现故这里可以省略。</p><p><strong>dao.xml</strong><br>这里需要注意的是xml配置的路径是否正确、是否在bean扫描路径下、表字段名name、desc会冲突等问题<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200416215337164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><strong>pom配置</strong><br>由于用到entity、common中的基本类，故需引入模块；</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--集成mybatis--&gt;</span><br><span class="line">        &lt;!--集成事务--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.hofe&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;entity&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.hofe&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-api接口模块配置"><a href="#2-2-api接口模块配置" class="headerlink" title="2.2 api接口模块配置"></a>2.2 api接口模块配置</h3><p> <strong>api服务接口</strong><br> 集成common中的基本业务接口，后续该接口由Service实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hofe.common.base.IBaseService;</span><br><span class="line"><span class="keyword">import</span> com.hofe.entity.TProductType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 商品类别接口, 集成common中的Service，通过泛型确定类，再由service模块实现api模块的这个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProductTypeService</span> <span class="keyword">extends</span> <span class="title">IBaseService</span>&lt;<span class="title">TProductType</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>pom配置</strong><br>由于需要TProductType、IBaseService故引入entity、common依赖。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.hofe&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;common&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.hofe&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;entity&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-服务提供者配置"><a href="#2-3-服务提供者配置" class="headerlink" title="2.3 服务提供者配置"></a>2.3 服务提供者配置</h3><p><strong>启动类</strong><br>加入@EnableDubbo注解以及需要加入@MapperScan(“com.hofe.dao”)注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.hofe.dao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ProductServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口Service实现类</strong><br>依赖Dao层，调用相应dao执行具体业务。这里的getBaseDao()方法用于dao被调用时返回具体dao类型（抽象类、接口用的泛型）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Service</span>    <span class="comment">// dubbo的service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductTypeService</span> <span class="keyword">extends</span> <span class="title">BaseServiceImpl</span>&lt;<span class="title">TProductType</span>&gt; <span class="keyword">implements</span> <span class="title">IProductTypeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TProductTypeDao productTypeDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBaseDao&lt;TProductType&gt; <span class="title">getBaseDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productTypeDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>application.yml</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: product-service</span><br><span class="line">  registry:</span><br><span class="line">    protocol: zookeeper</span><br><span class="line">    address: ip:<span class="number">2181</span></span><br><span class="line">  protocol: <span class="number">28801</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource: # 数据库配置</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//ip:3306/dubbo_shop?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10</span></span><br><span class="line">    username: root</span><br><span class="line">    password: ***</span><br><span class="line">    hikari:</span><br><span class="line">      maximum-pool-size: 10 # 最大连接池数</span><br><span class="line">      max-lifetime: <span class="number">1770000</span></span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  # 指定别名设置的包为所有entity</span><br><span class="line">  type-aliases-<span class="keyword">package</span>: cn.hofe.entity</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: true # 驼峰命名规范</span><br><span class="line">  mapper-locations: # mapper映射文件位置</span><br><span class="line">    - classpath:mapper<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure><p><strong>pom配置</strong><br>加入api、dao依赖包也会加入它们各自的依赖包；所以即使用到mybatis也可以不用引入依赖。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">&lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Dubbo依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.hofe&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;product-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.hofe&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dao&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-服务消费者配置"><a href="#2-3-服务消费者配置" class="headerlink" title="2.3 服务消费者配置"></a>2.3 服务消费者配置</h3><p><strong>启动类</strong><br>在启动类中添加@EnableDubbo注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackendApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(BackendApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>controller</strong><br>在Controller中依赖处添加@Reference应用。将由服务提供者的Service执行具体业务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.hofe.api.product.IProductTypeService;</span><br><span class="line"><span class="keyword">import</span> com.hofe.entity.TProductType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"productType"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductTypeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> IProductTypeService productTypeService;     <span class="comment">// 引用 Servic模块的服务</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TProductType&gt; <span class="title">productTypeList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productTypeService.queryAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>application.yml</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">9090</span></span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: backend</span><br><span class="line">  registry:</span><br><span class="line">    protocol: zookeeper</span><br><span class="line">    address: ip:<span class="number">2181</span></span><br></pre></td></tr></table></figure><p><strong>pom配置</strong><br>由于需要用到服务消费者故需引入api模块</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">&lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Dubbo依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.hofe&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;product-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="三、RabbitMQ消息队列（未完成）"><a href="#三、RabbitMQ消息队列（未完成）" class="headerlink" title="三、RabbitMQ消息队列（未完成）"></a>三、RabbitMQ消息队列（未完成）</h2><h3 id="3-1-消息队列的应用场景"><a href="#3-1-消息队列的应用场景" class="headerlink" title="3.1 消息队列的应用场景"></a>3.1 消息队列的应用场景</h3><p><strong>异步、削峰、解耦</strong>。详情<a href="https://blog.csdn.net/qq_35190492/article/details/103153444?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2" target="_blank" rel="noopener">点击</a><br><strong>(1) 通过异步处理提高系统性能（削峰、减少响应所需时间）</strong><br>比如秒杀背景下的商品下单，在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步的对数据库进行操作。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</p><p>消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 </p><p>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p><p><strong>(2) 降低系统耦合性</strong></p><p>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</p><p>通过将系统同步交互改为异步交互提高系统的处理的吞吐量<br>发送者：<br>1、声明交换机<br>2、发送消息到交换机</p><p>接受者者：<br>1、声明队列<br>2、建立队列与交换机的绑定关系<br>3、创建一个类的方法来监听队列，接收消息</p><h2 id="四、单点登陆"><a href="#四、单点登陆" class="headerlink" title="四、单点登陆"></a>四、单点登陆</h2><h3 id="4-1-登录方案设计"><a href="#4-1-登录方案设计" class="headerlink" title="4.1 登录方案设计"></a>4.1 登录方案设计</h3><h4 id="4-1-1-前后端未分离下的登陆系统的设计"><a href="#4-1-1-前后端未分离下的登陆系统的设计" class="headerlink" title="4.1.1 前后端未分离下的登陆系统的设计"></a>4.1.1 前后端未分离下的登陆系统的设计</h4><blockquote><p>Session<br>服务端提供了一种叫 Session 的机制，对于每个用户的请求，会生成一个唯一的标识。当程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端的请求是否包含了一个 session 标识（session id）。如果已包含一个 session id 则说明以前已经为客户端创建过 session，服务器就按照 session id 把这个 session 检索出来使用。<br>如果客户端请求不包含 session id，则为此客户端创建一个session 并且生成一个与此 session 相关联的 session id，session id 的值是一个既不会重复，又不容易被找到规律的字符串。<br>Cookie<br>浏览器提供了一种叫 cookie 的机制，保存当前会话的唯一标识。每次 HTTP 请求，客户端都会发送相应的 cookie 信息到服务端。客户端第一次请求，由于 cookie 中并没有携带 session id，服务端会创建一个session id，并写入到客户端的 cookie 中。以后每次请求，客户端都会携带这个 id 发给服务器端。这样一来，便解决了无状态的问题。</p></blockquote><p>通过设置浏览器的cookie（sessionid），映射服务器的用户session来判断用户登录状况：每次点击登录按钮时后台的response将sessionid的cookie添加到浏览器，后面所有访问请求都带着该cookie，shiro的相关方法就会获取cookie匹配session确定用户登录信息。</p><h4 id="4-1-2前后端分离下的登陆系统设计"><a href="#4-1-2前后端分离下的登陆系统设计" class="headerlink" title="4.1.2前后端分离下的登陆系统设计"></a>4.1.2前后端分离下的登陆系统设计</h4><blockquote><p>前后端分离的核心概念是后端仅返回前端所需的数据，不再渲染HTML页面，前端HTML页面通过AJAX调用后端的RESTFUL API接口并使用JSON数据进行交互</p></blockquote><p>目前大多数都采用请求头携带 Token 的形式。</p><p>1、首次登录时，后端服务器判断用户账号密码正确之后，根据用户id、用户名、定义好的秘钥、过期时间 生成 token ，返回给前端<br>2、前端拿到后端返回的 token ,存储在 localStroage 里<br>3、前端每次路由跳转， 判断 localStroage 有无 token ，没有则跳转到登录页，有则请求获取用户信息，改变登录状态<br>4、每次请求接口，在 请求头里携带 token<br>5、后端接口 判断 请求头有无 token，没有或者 token 过期，返回401<br>6、前端得到 401 状态码，重定向 到登录页面</p><h4 id="4-1-3-微服务分布式下的登陆系统设计"><a href="#4-1-3-微服务分布式下的登陆系统设计" class="headerlink" title="4.1.3 微服务分布式下的登陆系统设计"></a>4.1.3 微服务分布式下的登陆系统设计</h4><p>单点登录就是在A系统登录以后，跳转到B系统，此时可以直接访问B系统的资源，即只需要登录一次，就可以访问其他相互信任的应用系统，免除多次登录的烦恼。实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，因此要点也就以下两个：存储信任、验证信任。</p><h3 id="4-2-服务消费者配置"><a href="#4-2-服务消费者配置" class="headerlink" title="4.2 服务消费者配置"></a>4.2 服务消费者配置</h3><p><strong>SSOController.java</strong><br><strong>用户登录</strong><br>通过前端传递的user信息，与数据库交互判断是否合法，若合法生成uuid，创建名为”user_token”，内容为uuid的cookie，设置cookie的域名为父域名，这样所有子域名系统都可以访问该cookie，解决cookie的跨域问题等等，并将其通过HttpServletResponse添加cookie到浏览器中。同时，通过redisTemplate设置key为user:token:uuid，值为该用户信息的redis数据，并设置过期时间，这样redis服务器就会保存本次登陆的信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"checkLogin"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkLogin</span><span class="params">(TUser user, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        TUser currentUser = userService.checkLogin(user);</span><br><span class="line">        <span class="keyword">if</span>(currentUser == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 在浏览器中可以看到user_token对应的uuid</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"user_token"</span>, uuid);</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// redis中的key位user:token:uuid</span></span><br><span class="line">        StringBuilder redisKey = <span class="keyword">new</span> StringBuilder(<span class="string">"user:token:"</span>).append(uuid);</span><br><span class="line"></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        <span class="comment">// 客户端得到uuid，就可以用user:token:uuid从redis中取得currentUser信息</span></span><br><span class="line">        redisTemplate.opsForValue().set(redisKey, currentUser);</span><br><span class="line">        <span class="comment">//设置有效期</span></span><br><span class="line">        redisTemplate.expire(redisKey.toString(), <span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>判断是否登录</strong><br>通过HttpServletRequest获取请求报文带来的cookies信息，判断是否包含user_token，若包含则获取该cookie对应的uuid，通过键user:token:uuid获取redis保存的用户信息，并刷新其有效期。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"checkIsLogin"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkIsLogin</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span>(cookies == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"用户未登陆"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"user_token"</span>.equals(cookie.getName()))&#123;</span><br><span class="line">                String uuid = cookie.getValue();</span><br><span class="line">                StringBuilder redisKey = <span class="keyword">new</span> StringBuilder(<span class="string">"user:token:"</span>).append(uuid);</span><br><span class="line"></span><br><span class="line">                TUser currentUser = (TUser) redisTemplate.opsForValue().get(redisKey.toString());</span><br><span class="line">                <span class="keyword">if</span>(currentUser != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//刷新有效期</span></span><br><span class="line">                    redisTemplate.expire(redisKey.toString(), <span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">                    <span class="keyword">return</span> currentUser.getUsername();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"用户为登陆"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注销</strong><br>通过uuid新建cookie，并设置其失效，重新添加回浏览器的客户端，同时也要删除其对应的redis数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"logout"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(@CookieValue(name = <span class="string">"user_token"</span>, required = <span class="keyword">false</span>)</span> String uuid,</span></span><br><span class="line"><span class="function">                         HttpServletResponse response)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uuid == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"注销失败"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"user_token"</span>, uuid);</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 使cookie失效</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除redis</span></span><br><span class="line">        StringBuilder redisKey = <span class="keyword">new</span> StringBuilder(<span class="string">"user:token:"</span>).append(uuid);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.delete(redisKey.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"注销成功"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>pom配置</strong><br>与普通的消费者配置差不多，只是多了redis引入。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>application.yml配置</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">9099</span></span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: sso</span><br><span class="line">  registry:</span><br><span class="line">    protocol: zookeeper</span><br><span class="line">    address: ip:<span class="number">2181</span></span><br><span class="line">  consumer:</span><br><span class="line">    timeout: <span class="number">30000</span></span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: ip</span><br><span class="line">    port: <span class="number">6379</span></span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="4-3-服务提供者配置"><a href="#4-3-服务提供者配置" class="headerlink" title="4.3 服务提供者配置"></a>4.3 服务提供者配置</h3><p><strong>UserService.java</strong><br>和普通的提供者一样，数据库的增删查改操作。</p><p><strong>application.yml配置</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: user-service</span><br><span class="line">  registry:</span><br><span class="line">    protocol: zookeeper</span><br><span class="line">    address: ip:<span class="number">2181</span></span><br><span class="line">  protocol: <span class="number">28808</span></span><br><span class="line">  provider:</span><br><span class="line">    timeout: <span class="number">30000</span></span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//ip:3306/dubbo_shop?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10</span></span><br><span class="line">    username: root</span><br><span class="line">    password: <span class="number">123456</span></span><br><span class="line">    hikari:</span><br><span class="line">      maximum-pool-size: <span class="number">10</span> </span><br><span class="line">      max-lifetime: <span class="number">1770000</span></span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  # entity路径</span><br><span class="line">  type-aliases-<span class="keyword">package</span>: com.hofe</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-<span class="keyword">case</span>: <span class="keyword">true</span></span><br><span class="line">  mapper-locations: # mapper资源路径</span><br><span class="line">    - classpath:mapper<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure><h2 id="五、购物车"><a href="#五、购物车" class="headerlink" title="五、购物车"></a>五、购物车</h2><h3 id="5-1-购物车方案设计"><a href="#5-1-购物车方案设计" class="headerlink" title="5.1 购物车方案设计"></a>5.1 购物车方案设计</h3><p>需要实现以下功能：<br>1、未登录时可操作购物车且退出浏览器之后依然存在信息<br>2、未登录时购物车支持增删查改、排序商品<br>3、登陆时自动合并未登录与登陆时的商品，且未登录时购物车商品将清空。<br>4、商品信息变更，购物车也需变更<br>5、已登录购物车在任何地方信息都一样</p><p>未登录购物车实现方案一：cookie<br>用list保存购物车中的商品信息和对应数量的对象，再将其转化为json，最后用cookie保存购物车和list的键值对。但如果商品信息变更，cookie保存的是商品的信息，则无法修改，故最好改成商品id与数量的对应关系。<br>不足：<br>1、展示购物车需要查看数据库，可以把20%的商品放到缓存中（缓存预热）<br>2、cookie的物理上限4k<br>3、更新删除操作需要遍历</p><p>未登录购物车实现方案二：cookie+redis<br>购物车保存信息：每一项（id+数量+操作时间），购物车包含多项。后端使用redis存储购物车信息，并做热门商品的缓存。前端cookie保存信息简化，只作保存凭证（user_cart—-uuid）。这样后端也省略了json转换。cookie不是会话级cookie，否则退出浏览器即消失。<br>不足：更新需要遍历</p><p>已登录购物车方案一：数据库<br>每个用户一辆购物车，字段需要有id\user_id\product_id\count\update，每行是一条购物车记录，user_id和product_id是唯一约束。</p><p>已登录购物车方案二：redis<br>每个用户一辆购物车，user:cart:uuid改为user:cart:userid<br>控制层通过判断用户是否登录决定用user:cart:uuid还是user:cart:userid，从客户端到controller之间可以加个拦截器，任何时候都放行，只记录状态，放入request中。<br>好处：性能<br>坏处：虽然是持久化机制，但可能有数据间歇性丢失</p><p>合并购物车方案：<br>通过user:cart:uuid/userId的方式判断有无登陆状态下的购物车，通过遍历两种购物车，用map存商品id对应的表项，最后合并成一个list，同时还需清除原先的cookie，因为未登录状态下的购物车信息是由cookie保存的。</p><h3 id="5-2-服务提供者配置"><a href="#5-2-服务提供者配置" class="headerlink" title="5.2 服务提供者配置"></a>5.2 服务提供者配置</h3><p>未登录时购物车的Service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hofe.cartservice.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> com.hofe.api.cart.ICartService;</span><br><span class="line"><span class="keyword">import</span> com.hofe.api.cart.pojo.CartItem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartServiceImpl</span> <span class="keyword">implements</span> <span class="title">ICartService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TProductDao productDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(String key, Long productId, Integer count)</span> </span>&#123;</span><br><span class="line">        List&lt;CartItem&gt; cart = (List&lt;CartItem&gt;) redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 购物车不存在</span></span><br><span class="line">        <span class="keyword">if</span>(cart == <span class="keyword">null</span>)&#123;</span><br><span class="line">            cart = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            cart.add(<span class="keyword">new</span> CartItem(productId, count, <span class="keyword">new</span> Date()));</span><br><span class="line">            redisTemplate.opsForValue().set(key, cart);</span><br><span class="line">            redisTemplate.expire(key, <span class="number">30</span>, TimeUnit.DAYS);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"添加成功: "</span>+productId+<span class="string">"目前数量: "</span>+count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 购物车存在</span></span><br><span class="line">        <span class="keyword">for</span> (CartItem cartItem : cart)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cartItem.getProductId().longValue() == productId.longValue())&#123;</span><br><span class="line">                cartItem.setCount(cartItem.getCount()+count);</span><br><span class="line">                cartItem.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line">                redisTemplate.opsForValue().set(key, cart);</span><br><span class="line">                redisTemplate.expire(key, <span class="number">30</span>, TimeUnit.DAYS);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"添加成功: "</span>+productId+<span class="string">"目前数量: "</span>+count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 购物车不存在该商品</span></span><br><span class="line">        cart.add(<span class="keyword">new</span> CartItem(productId, count, <span class="keyword">new</span> Date()));</span><br><span class="line">        redisTemplate.opsForValue().set(key, cart);</span><br><span class="line">        redisTemplate.expire(key, <span class="number">30</span>, TimeUnit.DAYS);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"添加成功: "</span>+productId+<span class="string">"目前数量: "</span>+count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateCount</span><span class="params">(String key, Long productId, Integer count)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;CartItem&gt; carts = (List&lt;CartItem&gt;) redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(carts != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (CartItem item :carts)&#123;</span><br><span class="line">                <span class="keyword">if</span>(productId.longValue() == item.getProductId().longValue())&#123;</span><br><span class="line">                    item.setCount(item.getCount()+count);</span><br><span class="line">                    item.setUpdateTime(<span class="keyword">new</span> Date());</span><br><span class="line">                    redisTemplate.opsForValue().set(key, item);</span><br><span class="line">                    redisTemplate.expire(key, <span class="number">30</span>, TimeUnit.DAYS);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"更新成功: "</span>+productId+<span class="string">"目前数量: "</span>+count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"更新失败"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">del</span><span class="params">(String key, Long productId)</span> </span>&#123;</span><br><span class="line">        List&lt;CartItem&gt; carts = (List&lt;CartItem&gt;) redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(carts != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(CartItem item : carts)&#123;</span><br><span class="line">                <span class="keyword">if</span>(item.getProductId().longValue() == productId.longValue())&#123;</span><br><span class="line">                    carts.remove(item);</span><br><span class="line">                    redisTemplate.opsForValue().set(key, carts);</span><br><span class="line">                    redisTemplate.expire(key, <span class="number">30</span>, TimeUnit.DAYS);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"删除成功"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"删除失败"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CartItemVo&gt; <span class="title">list</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        List&lt;CartItem&gt; cartItems = (List&lt;CartItem&gt;) redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(cartItems == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;CartItemVo&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;CartItemVo&gt; cartItemVos = <span class="keyword">new</span> ArrayList&lt;&gt;(cartItems.size());</span><br><span class="line">        <span class="keyword">for</span>(CartItem cartItem : cartItems)&#123;</span><br><span class="line">            <span class="comment">// 将redis存储的List&lt;CartItem&gt;加入到List&lt;CartItemVo&gt;中</span></span><br><span class="line">            CartItemVo cartItemVo = <span class="keyword">new</span> CartItemVo();</span><br><span class="line">            cartItemVo.setCount(cartItem.getCount());</span><br><span class="line">            cartItemVo.setUpdateTime(cartItem.getUpdateTime());</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"productId:"</span>).append(cartItem.getProductId());</span><br><span class="line">            TProduct product = (TProduct) redisTemplate.opsForValue().get(stringBuilder.toString());</span><br><span class="line">            <span class="keyword">if</span>(product == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// redis中没有，则查询数据库</span></span><br><span class="line">                product = productDao.queryById(cartItem.getProductId());</span><br><span class="line">                redisTemplate.opsForValue().set(stringBuilder.toString(), product);</span><br><span class="line">                <span class="comment">// 不是热门商品，不用设置太久</span></span><br><span class="line">                redisTemplate.expire(stringBuilder.toString(), <span class="number">60</span>, TimeUnit.MINUTES);</span><br><span class="line">            &#125;</span><br><span class="line">            cartItemVo.setProduct(product);</span><br><span class="line">            cartItemVos.add(cartItemVo);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(cartItemVos, <span class="keyword">new</span> Comparator&lt;CartItemVo&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(CartItemVo o1, CartItemVo o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>) (o2.getUpdateTime().getTime()-o1.getUpdateTime().getTime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cartItemVos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并购物车</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">merge</span><span class="params">(String nologinKey, String loginKey)</span> </span>&#123;</span><br><span class="line">        List&lt;CartItem&gt; noLoginCart = (List&lt;CartItem&gt;) redisTemplate.opsForValue().get(nologinKey);</span><br><span class="line">        <span class="keyword">if</span>(noLoginCart == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 不存在未登陆购物车</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;CartItem&gt; loginCart = (List&lt;CartItem&gt;) redisTemplate.opsForValue().get(loginKey);</span><br><span class="line">        <span class="keyword">if</span>(loginCart == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 不存在登陆购物车，则将未登录时购物车加入已登录时购物车</span></span><br><span class="line">            redisTemplate.opsForValue().set(loginKey, noLoginCart);</span><br><span class="line">            redisTemplate.expire(loginKey, <span class="number">30</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两者都存在</span></span><br><span class="line">        HashMap&lt;Long, CartItem&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(CartItem cartItem :noLoginCart)&#123;</span><br><span class="line">            map.put(cartItem.getProductId(), cartItem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(CartItem cartItem :loginCart)&#123;</span><br><span class="line">            CartItem item = map.get(cartItem.getProductId());</span><br><span class="line">            <span class="keyword">if</span>(item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                map.put(cartItem.getProductId(), cartItem);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                item.setCount(cartItem.getCount()+item.getCount());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hashmap----&gt;list</span></span><br><span class="line">        Collection&lt;CartItem&gt; values = map.values();</span><br><span class="line">        List&lt;CartItem&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// list写入已登录购物车，删除未登录购物车</span></span><br><span class="line">        redisTemplate.delete(noLoginCart);</span><br><span class="line">        <span class="comment">// 已登录购物车加入redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(loginKey, loginCart);</span><br><span class="line">        redisTemplate.expire(loginKey, <span class="number">30</span>, TimeUnit.DAYS);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-服务消费者配置"><a href="#5-3-服务消费者配置" class="headerlink" title="5.3 服务消费者配置"></a>5.3 服务消费者配置</h3><p><strong>未登录时购物车的Controller</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hofe.cart.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"cart"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> ICartService cartService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"add/&#123;productId&#125;/&#123;count&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(@PathVariable(<span class="string">"productId"</span>)</span> Long productId,</span></span><br><span class="line"><span class="function">                          @<span class="title">PathVariable</span><span class="params">(<span class="string">"count"</span>)</span> Integer count,</span></span><br><span class="line"><span class="function">                          @<span class="title">CookieValue</span><span class="params">(name = <span class="string">"user_cart"</span>,required = <span class="keyword">false</span>)</span> String uuid,</span></span><br><span class="line"><span class="function">                          HttpServletResponse response)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uuid == <span class="keyword">null</span>)&#123;</span><br><span class="line">            uuid = UUID.randomUUID().toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder key = <span class="keyword">new</span> StringBuilder(<span class="string">"user:cart:"</span>).append(uuid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写cookie到客户端,更新有效期</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"user_cart"</span>, uuid);</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">30</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cartService.add(key.toString(),productId,count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"update/&#123;productId&#125;/&#123;count&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(@PathVariable(<span class="string">"productId"</span>)</span> Long productId,</span></span><br><span class="line"><span class="function">                      @<span class="title">PathVariable</span><span class="params">(<span class="string">"count"</span>)</span> Integer count,</span></span><br><span class="line"><span class="function">                      @<span class="title">CookieValue</span><span class="params">(name = <span class="string">"user_cart"</span>,required = <span class="keyword">false</span>)</span> String uuid,</span></span><br><span class="line"><span class="function">                      HttpServletResponse response)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uuid == <span class="keyword">null</span> &amp;&amp; <span class="string">""</span>.equals(uuid))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"更新失败"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder key = <span class="keyword">new</span> StringBuilder(<span class="string">"user:cart:"</span>).append(uuid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写cookie到客户端,更新有效期</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"user_cart"</span>, uuid);</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">30</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cartService.updateCount(key.toString(),productId,count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"delete/&#123;productId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(@PathVariable(<span class="string">"productId"</span>)</span> Long productId,</span></span><br><span class="line"><span class="function">                             @<span class="title">CookieValue</span><span class="params">(name = <span class="string">"user_cart"</span>,required = <span class="keyword">false</span>)</span> String uuid,</span></span><br><span class="line"><span class="function">                             HttpServletResponse response)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uuid == <span class="keyword">null</span> &amp;&amp; <span class="string">""</span>.equals(uuid))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"删除失败"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder key = <span class="keyword">new</span> StringBuilder(<span class="string">"user:cart:"</span>).append(uuid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写cookie到客户端,更新有效期</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"user_cart"</span>, uuid);</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">30</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cartService.del(key.toString(), productId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">list</span><span class="params">(@CookieValue(name = <span class="string">"user_cart"</span>,required = <span class="keyword">false</span>)</span> String uuid,</span></span><br><span class="line"><span class="function">                     HttpServletResponse response)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uuid == <span class="keyword">null</span>)&#123;</span><br><span class="line">            uuid = UUID.randomUUID().toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder key = <span class="keyword">new</span> StringBuilder(<span class="string">"user:cart:"</span>).append(uuid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写cookie到客户端,更新有效期</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"user_cart"</span>, uuid);</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">30</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cartService.list(key.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>已登录时购物车的Controller</strong><br>在客户端发起请求到controller之间加入拦截器，用于获取用户登录状态，并将结果封装在HttpServletRequest request中</p><p>配置（加入拦截器）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthInterceptor authInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span></span>&#123;</span><br><span class="line">        registry.addInterceptor(authInterceptor).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户登录状态</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span>(cookies == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie :cookies)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"user_token"</span>.equals(cookie.getName()))&#123;</span><br><span class="line">                String uuid = cookie.getValue();</span><br><span class="line">                TUser user = userService.checkIsLogin(uuid);</span><br><span class="line">                <span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    request.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// controller级别用httpclient接口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无论是否登录，都放行到购物车</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller<br>如果已登录，则RedisKey为user:cart:userId；否则为user:cart:uuid</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"add/&#123;productId&#125;/&#123;count&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(@PathVariable(<span class="string">"productId"</span>)</span> Long productId,</span></span><br><span class="line"><span class="function">                          @<span class="title">PathVariable</span><span class="params">(<span class="string">"count"</span>)</span> Integer count,</span></span><br><span class="line"><span class="function">                          @<span class="title">CookieValue</span><span class="params">(name = <span class="string">"user_cart"</span>,required = <span class="keyword">false</span>)</span> String uuid,</span></span><br><span class="line"><span class="function">                          HttpServletResponse response,</span></span><br><span class="line"><span class="function">                          HttpServletRequest request)</span>&#123;</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 通过拦截器获取的登陆状态</span></span><br><span class="line">        TUser user = (TUser) request.getAttribute(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</span><br><span class="line">            key = <span class="keyword">new</span> StringBuilder(<span class="string">"user:cart:"</span>).append(user.getId()).toString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(uuid == <span class="keyword">null</span>)&#123;</span><br><span class="line">                uuid = UUID.randomUUID().toString();</span><br><span class="line">            &#125;</span><br><span class="line">            key = <span class="keyword">new</span> StringBuilder(<span class="string">"user:cart:"</span>).append(uuid).toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//写cookie到客户端,更新有效期</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"user_cart"</span>, uuid);</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">30</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cartService.add(key.toString(),productId,count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>合并购物车，修改已登录购物车的商品记录，同时清除未登录时购物车的记录</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"merge"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">merge</span><span class="params">(@CookieValue(name = <span class="string">"user_cart"</span>,required = <span class="keyword">false</span>)</span> String uuid,</span></span><br><span class="line"><span class="function">                      HttpServletResponse response, HttpServletRequest request) </span>&#123;</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 通过拦截器获取的登陆状态</span></span><br><span class="line">        TUser user = (TUser) request.getAttribute(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uuid == <span class="keyword">null</span> || <span class="string">""</span>.equals(uuid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String loginKey = <span class="keyword">new</span> StringBuilder(<span class="string">"user:cart:"</span>).append(user.getId()).toString();</span><br><span class="line">        String noLoginKey = <span class="keyword">new</span> StringBuilder(<span class="string">"user:cart:"</span>).append(uuid).toString();</span><br><span class="line"></span><br><span class="line">        List merge = cartService.merge(noLoginKey, loginKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写cookie到客户端,清除未登录时购物车的id</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"user_cart"</span>, uuid);</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="六、购物车优化"><a href="#六、购物车优化" class="headerlink" title="六、购物车优化"></a>六、购物车优化</h2><h3 id="6-1-回顾下之前购物车方案设计"><a href="#6-1-回顾下之前购物车方案设计" class="headerlink" title="6.1 回顾下之前购物车方案设计"></a>6.1 回顾下之前购物车方案设计</h3><p>首先在客户端向服务器发起请求后，通过拦截器获取当前是否登录，如果登陆的话就可以获得cookie: user_token对应的value（用户信息），无论登陆与否都放行。控制层接收请求，并将cookie: user_cart对应的value（购物车信息）注入到uuid中。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200423165635836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>获取拦截器封装在request中的用户信息，如果不为null，说明用户已登录，那这时候需要在用户的购物车中添加记录，故传递redis: user:cart:userid更改在redis中保存的用户购物车信息；如果用户未登录，则在客户端中的购物车中添加记录，先传递redis: user:cart:uuid用于变更redis中保存的客户端购物车信息，同时需要修改客户端保存的cookie，因为未登录时的购物车是通过客户端保存的cookie的uuid区别不同客户端的。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200423165800811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>当controller调用service时传入key(userid或uuid)及记录，service首先判断客户端或者用户是否已有购物车，如果没有则新建一个list作为购物车；如果存在购物车，就判断购物车中是否有该条记录，有的话则修改记录的商品数，没有的话则新增该商品记录，并存入到redis；存入到未登录的购物车还是已登录的购物车由传递来的key(userid或uuid)决定。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200423171442499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>用户未登陆时加入购物车的商品需要合并到登陆后的购物车中，首先获取uuid代表客户端的购物车和userid代表用户的购物车，调用合并函数将两辆购物车合并，同时需要清除客户端的购物车信息，通过将cookie存活时间设置为0即可。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200423172004634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>merge函数通过传递进来的uuid和userid获取redis中保存的数据，如果客户端购物车为空，则不用进行合并；如果如果用户购物车为空，则将未登录的购物车加入到已登录购物车的redis记录中，并删除未登录购物车的记录。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200423173213106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>如果两者都不为空，则先遍历未登录购物车获取productId即记录，将其加入map；再遍历登陆购物车，判断map中是否存在相同的productId，存在则修改其对应的数量，如果不存在则加入map。最后通过collection将map的value即商品记录转成list返回，同时删除未登录购物车对应的redis记录。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200423173303847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="6-2-优化的购物车设计方案"><a href="#6-2-优化的购物车设计方案" class="headerlink" title="6.2 优化的购物车设计方案"></a>6.2 优化的购物车设计方案</h3><p>之前的设计方案存在着更新删除需要遍历List的缺点，故改用Hash存储，可直接通过Key获得Value，而不需要再遍历列表。</p><h2 id="七、订单模块（未完成）"><a href="#七、订单模块（未完成）" class="headerlink" title="七、订单模块（未完成）"></a>七、订单模块（未完成）</h2><h3 id="7-1-方案设计"><a href="#7-1-方案设计" class="headerlink" title="7.1 方案设计"></a>7.1 方案设计</h3><p>这一模块有几个过程：购物车结算-&gt;订单确认-&gt;生成订单-&gt;确认并支付。<br><strong>购物车结算-&gt;确认页面</strong><br>点击购物车结算后，跳转至确认页面，订单确认页面需要有用户地址信息、货物详情。故需要用户先登录，当用户访问确认也时，加入拦截器将页面从定向到登陆页面，记录referer，当用户登录成功后跳转回referer页面；货物详情通过uuid或者userid获得。</p><p><strong>订单确认-&gt;生成订单</strong><br>订单基本表和订单明细表：订单基本表需要有id/orderId/userId/transfer_no/name/phone/address（历史快照）/status/total_money/pay_type；订单明细表需要有id/order_id/product_id/count/name/price（历史快照）。</p><p>订单编号：唯一性、有序性（查询）、时间性。采用基于时间戳的方式+userID生成</p><p>库存的扣减：库存预扣减、超时未支付的检测。采用定时任务now-create_time。</p><p>选择购物车的部分商品下单：获取用户勾选id集合–等于批量删除，根据id集合选择购物车的部分商品信息，才将商品信息转换为订单。</p><p><strong>安全问题</strong><br>短信平台验证签名正确与否。发送签名：将用户id、token、时间戳通过MD5加密算法计算出sign发送给短信平台。短信平台验证签名：通过传递过来的sign获取用户id、token、时间戳，重新计算MD5判断是否与sign一致。缺陷：只保证了调用合法，明文传输无法保证内容合法。</p><p><strong>对接支付宝</strong><br>调用支付宝接口需要先生成RAS密钥，包含应用私钥与应用公钥。生存密钥后才可以获取支付宝公钥。</p><h2 id="八出现的问题"><a href="#八出现的问题" class="headerlink" title="八出现的问题"></a>八出现的问题</h2><h4 id="问题：在service中因为无法找到dao实现类导致的自动注入失败"><a href="#问题：在service中因为无法找到dao实现类导致的自动注入失败" class="headerlink" title="问题：在service中因为无法找到dao实现类导致的自动注入失败"></a>问题：在service中因为无法找到dao实现类导致的自动注入失败</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field productTypeDao in com.hofe.productservice.service.ProductTypeService required a bean of type <span class="string">'com.hofe.dao.TProductTypeDao'</span> that could not be found.</span><br><span class="line"></span><br><span class="line">The injection point has the following annotations:</span><br><span class="line">- <span class="meta">@org</span>.springframework.beans.factory.annotation.Autowired(required=<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>原因：考虑Spring未实例化对象<br>找不到bean的配置，以往是使用bean.xml文件进行配置，SpringBoot使用注解，就需要在入口程序中添加@MapperScan(“dao路径”)注解；同时也要考虑在注解方式下dao是否@mapper，xml方式下.xml文件存放路径是否正确；以及考虑application.yml中是否正确配置数据源。<br>可去掉Service上的@Component注解<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200416164704508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200416164716547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h4 id="问题：找不到dao中的方法"><a href="#问题：找不到dao中的方法" class="headerlink" title="问题：找不到dao中的方法"></a>问题：找不到dao中的方法</h4><p> Invalid bound statement (not found): com.hofe.dao.TProductTypeDao.queryAll<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/202004162006550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>解决办法：<br>在dao的pom中添加以下配置，标明xml配置存放路径</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;resources&lt;/directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**<span class="comment">/*.xml&lt;/include&gt;</span></span><br><span class="line"><span class="comment">                &lt;/includes&gt;</span></span><br><span class="line"><span class="comment">            &lt;/resource&gt;</span></span><br><span class="line"><span class="comment">        &lt;/resources&gt;</span></span><br><span class="line"><span class="comment">    &lt;/build&gt;</span></span><br></pre></td></tr></table></figure><p>或者在service的application.yml指明mybatis配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  # 指定别名设置的包为所有entity</span><br><span class="line">  type-aliases-<span class="keyword">package</span>: cn.hofe.entity</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: true # 驼峰命名规范</span><br><span class="line">  mapper-locations: # mapper映射文件位置</span><br><span class="line">    - classpath:mapper<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure><h4 id="问题：字段名为name、desc时查询出错"><a href="#问题：字段名为name、desc时查询出错" class="headerlink" title="问题：字段名为name、desc时查询出错"></a>问题：字段名为name、desc时查询出错</h4><p>原因：数据表字段名不要用name，desc会与msql自带语法冲突<br>解决方法：1、在要用到关键字的地方加反引号标识；2、修改表字段名</p><p>问题：@Reference、@Service注解错误<br>原因：错用了java的注解导致Service无法正常注入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line">import com.alibaba.dubbo.config.annotation.Reference;</span><br></pre></td></tr></table></figure><h4 id="问题：平级转树形结构问题"><a href="#问题：平级转树形结构问题" class="headerlink" title="问题：平级转树形结构问题"></a>问题：平级转树形结构问题</h4><p>遇到需要返回树形结构的json数据，如多级菜单、多级类别等，可以使用VO与resultMap搭配，mybatis递归查询。需要注意的是，resultMap中的collection字段的column=“字段名”，不需要加{}；如需传递多个参数可加如{id, code}。这一字段代表的意思是第一次执行queryAllByCategory之后递归查询用到的parentId是这个category_type字段。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200419192344559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>树形结构的数据，可以不用外键进行关联；外键关联之后，无法将顶级的parentId设置值，只能默认null。</p><p>以下链接可参考：<br><a href="https://www.hangge.com/blog/cache/detail_2715.html" target="_blank" rel="noopener">https://www.hangge.com/blog/cache/detail_2715.html</a><br><a href="https://blog.csdn.net/janet796/article/details/79500349" target="_blank" rel="noopener">https://blog.csdn.net/janet796/article/details/79500349</a><br><a href="https://blog.csdn.net/qq_38164123/article/details/94358131" target="_blank" rel="noopener">https://blog.csdn.net/qq_38164123/article/details/94358131</a></p><p>问题：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">This application has no explicit mapping <span class="keyword">for</span> /error, so you are seeing this as a fallback.</span><br><span class="line">There was an unexpected error (<span class="built_in">type</span>=Internal Server Error, status=500).</span><br><span class="line">org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.reflection.ReflectionException: There is no getter <span class="keyword">for</span> property named <span class="string">'parentId'</span> <span class="keyword">in</span> <span class="string">'class java.lang.Integer'</span> org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.reflection.ReflectionException</span><br></pre></td></tr></table></figure><p>在使用choose之类条件控制语句的时候，要注意它判断的是传进来的参数的拥有的字段，如果传进来是个user可以使用；如果只传进来username，则无法控制password条件<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200419233256361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h4 id="问题：dubbo超时"><a href="#问题：dubbo超时" class="headerlink" title="问题：dubbo超时"></a>问题：dubbo超时</h4><p>Invoke remote method timeout. method: queryCategorys, provider: dubbo:<br>默认超时时间是1000ms，120条数据加上递归就超时了，可以在消费者和提供者端设置timeout=30000</p><h4 id="问题：SSO单点登录模块跨域问题"><a href="#问题：SSO单点登录模块跨域问题" class="headerlink" title="问题：SSO单点登录模块跨域问题"></a>问题：SSO单点登录模块跨域问题</h4><p>认证模块通过了，可其他模块在发送ajax请求时还是无法携带cookie。<br>在SSO登录之后，浏览器返回cookie，其携带着uuid信息，其他系统在发送ajax请求时，携带这个cookie信息就可免登录。但需要在Controller的类或者方法上加上注解@CrossOrigin(origins = “*”, allowCredentials = “true”)，允许所有端口的访问，并允许携带cookie<br>前端ajax代码需要withCredentials:true</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&amp;ajax(&#123;</span><br><span class="line">url:<span class="string">"http://localhost:9098/sso/checkIsLogin"</span>,</span><br><span class="line">xhrFields:&#123;<span class="attr">withCredentials</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">crossDomain:<span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是，cart.hofe.com并不能保存shop.hofe.com的cookie，故设置的时候要设置父域名cookie.setDomain(“hofe.com”)</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Dubbo </category>
          
          <category> 入门实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud入门实战(三)--集成Ribbon</title>
      <link href="/2020/04/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/SpringCloud%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98(%E4%BA%8C)%E9%9B%86%E6%88%90Ribbon/"/>
      <url>/2020/04/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/SpringCloud%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98(%E4%BA%8C)%E9%9B%86%E6%88%90Ribbon/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>正在入门SpringCloud中，在学习的过程中也正好做个项目练手。这个项目是想做成一个模板，这样之后遇到同规模项目的时候可以拿来就用，版本也好控制。涉及到的中间件会有Eureka、Ribbon、Feign、HyStrix、Zuul、ConfigServer。这一节项目将改写Ribbon。<br><strong>版本</strong><br>SpringBoot：2.2.1.RELEASE<br>Spring Cloud：Finchley.RS1<br>spring-cloud-starter-netflix-eureka-client：2.2.1.RELEASE</p><ul><li>Eureka：2.2.1.RELEASE</li><li>Ribbon：2.2.1.RELEASE</li></ul><p><strong>目录结构</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040918092038.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p></blockquote><p>如果为同一个的提供者在Eureka中注册了多个服务，那么客户端该如何选择服务呢？<br>这时，就需要在客户端实现服务的负载均衡。</p><p>Ribbon是Netflixⅸx发布的负载均衡器，它有助于控制HTTP和TCP客户端的行为。为Ribbon配置服务提供者地址列表后， Ribbon就可基于某种负载均衡算法，自动地帮助服务消费者去请求。 Ribbon默认为我们提供了很多的负载均衡算法，例如轮询、随机等。当然，我们也可为 Ribbon实现自定义的负载均衡算法。</p><h2 id="一、简单的负载均衡程序"><a href="#一、简单的负载均衡程序" class="headerlink" title="一、简单的负载均衡程序"></a>一、简单的负载均衡程序</h2><p>从consume-user复制粘贴出一个新的consume-user-ribbon，也可以不重新创建，直接修改consume-user，需要修改的是Controller和启动程序。</p><h3 id="修改入口函数"><a href="#修改入口函数" class="headerlink" title="修改入口函数"></a>修改入口函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(<span class="string">"PROVIDER-USER"</span>)  <span class="comment">// 启用Ribbon并对PROVIDER-USER负载均衡</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeUserRibbonApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumeUserRibbonApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改消费者Controller"><a href="#修改消费者Controller" class="headerlink" title="修改消费者Controller"></a>修改消费者Controller</h3><p>修改获取url的方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> EurekaClient eurekaClient;</span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line">   <span class="keyword">private</span> RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping</span>(<span class="string">"getUserByEureka/&#123;id&#125;"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">       User user = restTemplate.getForObject(<span class="string">"http://PROVIDER-USER/user/"</span>+id, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>开启两个生产者，注意端口不同<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409154809295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409154916464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>但我通过消费者7901获取用户时，出现错误</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I/O error on GET request <span class="keyword">for</span> <span class="string">"http://PROVIDER-USER/user/1"</span>: PROVIDER-USER; nested exception is java.net.UnknownHostException: PROVIDER-USER</span><br></pre></td></tr></table></figure><p>这是因为获取RestTemplat对象时要加上@LoadBalanced注解 ，否则restTemplate.getForObject方法会报java.net.UnknownHostException。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409161838696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>要解决这个问题还有一点要改，就是Controller中的restTemplete要交由Spring容器来管理。我原先是直接new RestTtemplete()，在负载均衡的场景下不可用<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409162019687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409161928632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h2 id="二、修改负载均衡策略"><a href="#二、修改负载均衡策略" class="headerlink" title="二、修改负载均衡策略"></a>二、修改负载均衡策略</h2><p>修改消费者的application.yml<br><code>PROVIDER-USER</code>为生产者中配置的应用名，指定其策略为随机，这样就会随机使用两个生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PROVIDER-USER:</span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure><p>修改消费者Controller方便查看输出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用eureka动态获取url */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EurekaClient eurekaClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"getUserByEureka/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        ServiceInstance instance = loadBalancerClient.choose(<span class="string">"PROVIDER-USER"</span>);</span><br><span class="line">        System.out.println(instance.getHost()+<span class="string">":"</span>+instance.getPort());</span><br><span class="line">        User user = restTemplate.getForObject(<span class="string">"http://PROVIDER-USER/user/"</span>+id, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 硬编码url</span></span><br><span class="line"><span class="comment">    private RestTemplate restTemplate = new RestTemplate(); // spring提供的用于访问接rest口的模板对象</span></span><br><span class="line"><span class="comment">    @GetMapping("user/&#123;id&#125;")</span></span><br><span class="line"><span class="comment">    public User getUser(@PathVariable Long id)&#123;</span></span><br><span class="line"><span class="comment">        User user = restTemplate.getForObject("http://localhost:7900/user/"+id, User.class);</span></span><br><span class="line"><span class="comment">        return user;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    服务提供者中的控制器</span></span><br><span class="line"><span class="comment">    @GetMapping("user/&#123;id&#125;")</span></span><br><span class="line"><span class="comment">    public User getUser(@PathVariable Long id)&#123;</span></span><br><span class="line"><span class="comment">        return new User(id);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040917385347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>通过restTemplete获得服务生产者实例时，restTemplete需由Spring容器来生成并加上LoadBlance注解，不能直接new一个实例。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Spring Cloud </category>
          
          <category> 入门实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud入门实战(二)--集成Eureka</title>
      <link href="/2020/04/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/SpringCloud%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98(%E4%BA%8C)%E9%9B%86%E6%88%90Eureka/"/>
      <url>/2020/04/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/SpringCloud%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98(%E4%BA%8C)%E9%9B%86%E6%88%90Eureka/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>正在入门SpringCloud中，在学习的过程中也正好做个项目练手。这个项目是想做成一个模板，这样之后遇到同规模项目的时候可以拿来就用，版本也好控制。涉及到的中间件会有Eureka、Ribbon、Feign、HyStrix、Zuul、ConfigServer。这一节将项目改装成Spring Cloud并集成Eureka。<br><strong>版本</strong></p><p>SpringBoot：2.2.1.RELEASE<br>Spring Cloud：Finchley.RS1<br>Eureka：2.2.1.RELEASE</p><p><strong>目录结构</strong></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409143555346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p></blockquote><p>1、如果商品微服务的ip地址发生了变更，订单微服务中的配置文件也需要跟着修改<br>2、如果商品微服务有多个，那么在订单微服务中又该如何写地址？<br>因此引入注册中心用来管理接口配置</p><h2 id="一、Eureka服务注册中心配置"><a href="#一、Eureka服务注册中心配置" class="headerlink" title="一、Eureka服务注册中心配置"></a>一、Eureka服务注册中心配置</h2><h3 id="在项目pom文件中加入SpringCloud管理依赖"><a href="#在项目pom文件中加入SpringCloud管理依赖" class="headerlink" title="在项目pom文件中加入SpringCloud管理依赖"></a>在项目pom文件中加入SpringCloud管理依赖</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;!-- 导入Spring Cloud的依赖管理 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;Finchley.RS1&lt;/version&gt;</span><br><span class="line">      &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">      &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure><h3 id="在eureka模块pom中加入eureka依赖"><a href="#在eureka模块pom中加入eureka依赖" class="headerlink" title="在eureka模块pom中加入eureka依赖"></a>在eureka模块pom中加入eureka依赖</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--springboot 整合eureka服务端--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在这一块就卡了很久，会出现以下报错，这个错误到最后我也没解决，之后就换了版本，新建了个maven仓库。<br>（一）需要注意的是SpringBoot的版本和eureka的版本有关联，比如我原先用的2.2.1的SpringBoot和1.4.3的eureka会有如下报错<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409103243406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>（二）不管springcloud还是springboot版本我都换了很多次，都是出现这个问题，新建了个maven仓库就解决了，判断应该是eureka中jersey出现了版本冲突。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409130007296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">09</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">11.146</span>  INFO <span class="number">13864</span> --- [           main] com.hofe.EurekaApplication               : No active profile set, falling back to <span class="keyword">default</span> profiles: <span class="keyword">default</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">09</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">12.091</span>  WARN <span class="number">13864</span> --- [           main] o.s.boot.actuate.endpoint.EndpointId     : Endpoint ID <span class="string">'service-registry'</span> contains invalid characters, please migrate to a valid format.</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">09</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">12.263</span>  INFO <span class="number">13864</span> --- [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=e29d8b1a-b705-<span class="number">3</span>aaa-acfe-<span class="number">1f</span>f43115d358</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">09</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">12.422</span>  INFO <span class="number">13864</span> --- [           main] trationDelegate$BeanPostProcessorChecker : Bean <span class="string">'org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration'</span> of type [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$$<span class="number">4</span>b153431] <span class="function">is not eligible <span class="keyword">for</span> getting processed by all <span class="title">BeanPostProcessors</span> <span class="params">(<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span></span></span><br><span class="line"><span class="function">2020-04-09 11:05:12.720  INFO 13864 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with <span class="title">port</span><span class="params">(s)</span>: 7999 <span class="params">(http)</span></span></span><br><span class="line"><span class="function">2020-04-09 11:05:12.733  INFO 13864 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span></span><br><span class="line"><span class="function">2020-04-09 11:05:12.733  INFO 13864 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.27]</span></span><br><span class="line"><span class="function">2020-04-09 11:05:12.974  INFO 13864 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span></span><br><span class="line"><span class="function">2020-04-09 11:05:12.975  INFO 13864 --- [           main] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1811 ms</span></span><br><span class="line"><span class="function">2020-04-09 11:05:13.069  WARN 13864 --- [           main] c.n.c.sources.URLConfigurationSource     : No URLs will be polled as dynamic configuration sources.</span></span><br><span class="line"><span class="function">2020-04-09 11:05:13.069  INFO 13864 --- [           main] c.n.c.sources.URLConfigurationSource     : To enable URLs as dynamic configuration sources, define System property archaius.configurationSource.additionalUrls or make config.properties available on classpath.</span></span><br><span class="line"><span class="function">2020-04-09 11:05:13.076  INFO 13864 --- [           main] c.netflix.config.DynamicPropertyFactory  : DynamicPropertyFactory is initialized with configuration sources: com.netflix.config.ConcurrentCompositeConfiguration@12d1f1d4</span></span><br><span class="line"><span class="function">2020-04-09 11:05:13.390 ERROR 13864 --- [           main] o.s.b.web.embedded.tomcat.TomcatStarter  : Error starting Tomcat context. Exception: org.springframework.beans.factory.BeanCreationException. Message: Error creating bean with name 'jerseyFilterRegistration' defined in class path resource [org/springframework/cloud/netflix/eureka/server/EurekaServerAutoConfiguration.class]: Bean instantiation via factory method failed</span>; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.web.servlet.FilterRegistrationBean]: Factory method <span class="string">'jerseyFilterRegistration'</span> threw exception; nested exception is java.lang.NoClassDefFoundError: com/sun/jersey/spi/container/servlet/ServletContainer</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">09</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">13.420</span>  INFO <span class="number">13864</span> --- [           main] o.apache.catalina.core.StandardService   : Stopping service [Tomcat]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">09</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">13.427</span>  WARN <span class="number">13864</span> --- [           main] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">09</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">13.443</span>  INFO <span class="number">13864</span> --- [           main] ConditionEvaluationReportLoggingListener : </span><br><span class="line"></span><br><span class="line">Error starting ApplicationContext. To display the conditions report re-run your application with <span class="string">'debug'</span> enabled.</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">09</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">13.457</span> ERROR <span class="number">13864</span> --- [           main] o.s.boot.SpringApplication               : Application run failed</span><br><span class="line"></span><br><span class="line">org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:<span class="number">156</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="number">544</span>) ~[spring-context-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:<span class="number">141</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:<span class="number">747</span>) [spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:<span class="number">397</span>) [spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="number">315</span>) [spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="number">1226</span>) [spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="number">1215</span>) [spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at com.hofe.EurekaApplication.main(EurekaApplication.java:<span class="number">15</span>) [classes/:na]</span><br><span class="line">Caused by: org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat</span><br><span class="line">at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:<span class="number">126</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.&lt;init&gt;(TomcatWebServer.java:<span class="number">88</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getTomcatWebServer(TomcatServletWebServerFactory.java:<span class="number">438</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer(TomcatServletWebServerFactory.java:<span class="number">191</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.createWebServer(ServletWebServerApplicationContext.java:<span class="number">180</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.onRefresh(ServletWebServerApplicationContext.java:<span class="number">153</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">... <span class="number">8</span> common frames omitted</span><br><span class="line">Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'jerseyFilterRegistration' defined in class path resource [org/springframework/cloud/netflix/eureka/server/EurekaServerAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.web.servlet.FilterRegistrationBean]: Factory method 'jerseyFilterRegistration' threw exception; nested exception is java.lang.NoClassDefFoundError: com/sun/jersey/spi/container/servlet/ServletContainer</span><br><span class="line">at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:<span class="number">645</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:<span class="number">625</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:<span class="number">1338</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:<span class="number">1177</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:<span class="number">557</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:<span class="number">517</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$<span class="number">0</span>(AbstractBeanFactory.java:<span class="number">323</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">222</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">321</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">207</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:<span class="number">211</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.ServletContextInitializerBeans.getOrderedBeansOfType(ServletContextInitializerBeans.java:<span class="number">202</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.ServletContextInitializerBeans.addServletContextInitializerBeans(ServletContextInitializerBeans.java:<span class="number">96</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.ServletContextInitializerBeans.&lt;init&gt;(ServletContextInitializerBeans.java:<span class="number">85</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.getServletContextInitializerBeans(ServletWebServerApplicationContext.java:<span class="number">253</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.selfInitialize(ServletWebServerApplicationContext.java:<span class="number">227</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.boot.web.embedded.tomcat.TomcatStarter.onStartup(TomcatStarter.java:<span class="number">53</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:<span class="number">5135</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:<span class="number">183</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:<span class="number">1384</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:<span class="number">1374</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>) ~[na:<span class="number">1.8</span><span class="number">.0_144</span>]</span><br><span class="line">at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:<span class="number">75</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:<span class="number">134</span>) ~[na:<span class="number">1.8</span><span class="number">.0_144</span>]</span><br><span class="line">at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:<span class="number">909</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.core.StandardHost.startInternal(StandardHost.java:<span class="number">841</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:<span class="number">183</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:<span class="number">1384</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:<span class="number">1374</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>) ~[na:<span class="number">1.8</span><span class="number">.0_144</span>]</span><br><span class="line">at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:<span class="number">75</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:<span class="number">134</span>) ~[na:<span class="number">1.8</span><span class="number">.0_144</span>]</span><br><span class="line">at org.apache.catalina.core.ContainerBase.startInternal(ContainerBase.java:<span class="number">909</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.core.StandardEngine.startInternal(StandardEngine.java:<span class="number">262</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:<span class="number">183</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.core.StandardService.startInternal(StandardService.java:<span class="number">421</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:<span class="number">183</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.core.StandardServer.startInternal(StandardServer.java:<span class="number">930</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:<span class="number">183</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.apache.catalina.startup.Tomcat.start(Tomcat.java:<span class="number">459</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.27</span>.jar:<span class="number">9.0</span><span class="number">.27</span>]</span><br><span class="line">at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.initialize(TomcatWebServer.java:<span class="number">107</span>) ~[spring-boot-<span class="number">2.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">2.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">... <span class="number">13</span> common frames omitted</span><br><span class="line">Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.web.servlet.FilterRegistrationBean]: Factory method <span class="string">'jerseyFilterRegistration'</span> threw exception; nested exception is java.lang.NoClassDefFoundError: com/sun/jersey/spi/container/servlet/ServletContainer</span><br><span class="line">at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:<span class="number">185</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.ConstructorResolver.instantiate(ConstructorResolver.java:<span class="number">640</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">... <span class="number">53</span> common frames omitted</span><br><span class="line">Caused by: java.lang.NoClassDefFoundError: com/sun/jersey/spi/container/servlet/ServletContainer</span><br><span class="line">at org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration.jerseyFilterRegistration(EurekaServerAutoConfiguration.java:<span class="number">184</span>) ~[spring-cloud-netflix-eureka-server-<span class="number">2.1</span><span class="number">.2</span>.RELEASE.jar:<span class="number">2.1</span><span class="number">.2</span>.RELEASE]</span><br><span class="line">at org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration$$EnhancerBySpringCGLIB$$e48e3812.CGLIB$jerseyFilterRegistration$<span class="number">0</span>(&lt;generated&gt;) ~[spring-cloud-netflix-eureka-server-<span class="number">2.1</span><span class="number">.2</span>.RELEASE.jar:<span class="number">2.1</span><span class="number">.2</span>.RELEASE]</span><br><span class="line">at org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration$$EnhancerBySpringCGLIB$$e48e3812$$FastClassBySpringCGLIB$$b02b22.invoke(&lt;generated&gt;) ~[spring-cloud-netflix-eureka-server-<span class="number">2.1</span><span class="number">.2</span>.RELEASE.jar:<span class="number">2.1</span><span class="number">.2</span>.RELEASE]</span><br><span class="line">at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:<span class="number">244</span>) ~[spring-core-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:<span class="number">363</span>) ~[spring-context-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">at org.springframework.cloud.netflix.eureka.server.EurekaServerAutoConfiguration$$EnhancerBySpringCGLIB$$e48e3812.jerseyFilterRegistration(&lt;generated&gt;) ~[spring-cloud-netflix-eureka-server-<span class="number">2.1</span><span class="number">.2</span>.RELEASE.jar:<span class="number">2.1</span><span class="number">.2</span>.RELEASE]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:<span class="number">1.8</span><span class="number">.0_144</span>]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>) ~[na:<span class="number">1.8</span><span class="number">.0_144</span>]</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>) ~[na:<span class="number">1.8</span><span class="number">.0_144</span>]</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>) ~[na:<span class="number">1.8</span><span class="number">.0_144</span>]</span><br><span class="line">at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:<span class="number">154</span>) ~[spring-beans-<span class="number">5.2</span><span class="number">.1</span>.RELEASE.jar:<span class="number">5.2</span><span class="number">.1</span>.RELEASE]</span><br><span class="line">... <span class="number">54</span> common frames omitted</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.sun.jersey.spi.container.servlet.ServletContainer</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">381</span>) ~[na:<span class="number">1.8</span><span class="number">.0_144</span>]</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>) ~[na:<span class="number">1.8</span><span class="number">.0_144</span>]</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">335</span>) ~[na:<span class="number">1.8</span><span class="number">.0_144</span>]</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>) ~[na:<span class="number">1.8</span><span class="number">.0_144</span>]</span><br><span class="line">... <span class="number">65</span> common frames omitted</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程完成，退出码 <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="创建服务器的application-yml"><a href="#创建服务器的application-yml" class="headerlink" title="创建服务器的application.yml"></a>创建服务器的application.yml</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7999</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server</span><br><span class="line">eureka:</span><br><span class="line">###客户端调用地址</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7999/eureka/</span></span><br><span class="line">###是否将自己注册到Eureka服务中,因为该应用本身就是注册中心，不需要再注册自己（集群的时候为true）</span><br><span class="line">    register-with-eureka: <span class="keyword">false</span></span><br><span class="line">###是否从Eureka中获取注册信息,因为自己为注册中心,不会在该应用中的检索服务信息</span><br><span class="line">    fetch-registry: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h3 id="配置启动类"><a href="#配置启动类" class="headerlink" title="配置启动类"></a>配置启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Eureka注册中心</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动之后，访问端口，即可登录控制中心<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409130239545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h2 id="二、Eureka客户端服务发现配置"><a href="#二、Eureka客户端服务发现配置" class="headerlink" title="二、Eureka客户端服务发现配置"></a>二、Eureka客户端服务发现配置</h2><h3 id="生产者配置"><a href="#生产者配置" class="headerlink" title="生产者配置"></a>生产者配置</h3><h4 id="在模块pom下加入依赖"><a href="#在模块pom下加入依赖" class="headerlink" title="在模块pom下加入依赖"></a>在模块pom下加入依赖</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="在生产者中的application-yml配置以下信息"><a href="#在生产者中的application-yml配置以下信息" class="headerlink" title="在生产者中的application.yml配置以下信息"></a>在生产者中的application.yml配置以下信息</h4><p>生产者中配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7900</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: provider-user</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7999/eureka/</span></span><br></pre></td></tr></table></figure><h4 id="在启动类中增加注解-EnableEurekaClient"><a href="#在启动类中增加注解-EnableEurekaClient" class="headerlink" title="在启动类中增加注解@EnableEurekaClient"></a>在启动类中增加注解@EnableEurekaClient</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderUserApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ProviderUserApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者配置"><a href="#消费者配置" class="headerlink" title="消费者配置"></a>消费者配置</h3><h4 id="在模块pom下加入依赖-1"><a href="#在模块pom下加入依赖-1" class="headerlink" title="在模块pom下加入依赖"></a>在模块pom下加入依赖</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="在消费者的application中添加client"><a href="#在消费者的application中添加client" class="headerlink" title="在消费者的application中添加client"></a>在消费者的application中添加client</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7901</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consume-user</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:7999/eureka/</span></span><br></pre></td></tr></table></figure><h4 id="修改消费者的UserController"><a href="#修改消费者的UserController" class="headerlink" title="修改消费者的UserController"></a>修改消费者的UserController</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EurekaClient eurekaClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"getUserByEureka/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">        InstanceInfo info = eurekaClient.getNextServerFromEureka(<span class="string">"PROVIDER-USER"</span>, <span class="keyword">false</span>);</span><br><span class="line">        String homePageUrl = info.getHomePageUrl();</span><br><span class="line">        User user = restTemplate.getForObject(homePageUrl+<span class="string">"/user/"</span>+id, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="在启动类中添加注解-EnableEurekaClient"><a href="#在启动类中添加注解-EnableEurekaClient" class="headerlink" title="在启动类中添加注解@EnableEurekaClient"></a>在启动类中添加注解@EnableEurekaClient</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeUserApplicaton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumeUserApplicaton<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、开启eureka服务器和客户端"><a href="#三、开启eureka服务器和客户端" class="headerlink" title="三、开启eureka服务器和客户端"></a>三、开启eureka服务器和客户端</h2><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040914112266.png"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409141216524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>消费者访问自己的端口7901的getUserByEureka/1得到用户信息。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409141413675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>版本对应很重要，可以通过<a href="https://spring.io/projects/spring-cloud来查看spring-cloud和SpringBoot的对应关系，以及Eureka的依赖包是否会发生冲突。消费者通过EurekaClient的getNextServerFromEureka方法动态获取生产者的url，访问`消费者的url/getUserByEureka/1`时，会从`生产者的url/user/1`中获取。" target="_blank" rel="noopener">https://spring.io/projects/spring-cloud来查看spring-cloud和SpringBoot的对应关系，以及Eureka的依赖包是否会发生冲突。消费者通过EurekaClient的getNextServerFromEureka方法动态获取生产者的url，访问`消费者的url/getUserByEureka/1`时，会从`生产者的url/user/1`中获取。</a><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200409142940872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Spring Cloud </category>
          
          <category> 入门实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud入门实战(一)</title>
      <link href="/2020/04/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/SpringCloud%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98(%E4%B8%80)/"/>
      <url>/2020/04/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/SpringCloud%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>正在入门SpringCloud中，在学习的过程中也正好做个项目练手。这个项目是想做成一个模板，这样之后遇到同规模项目的时候可以拿来就用，版本也好控制。涉及到的中间件会有Eureka、Ribbon、Feign、HyStrix、Zuul、ConfigServer。这一节使用生产者消费者模型体现微服务思想。</p><h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><p>SpringBoot：2.2.1.RELEASE</p><p>项目目录结构如下<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408165640446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p></blockquote><h2 id="一、创建项目"><a href="#一、创建项目" class="headerlink" title="一、创建项目"></a>一、创建项目</h2><h3 id="先来建个工程"><a href="#先来建个工程" class="headerlink" title="先来建个工程"></a>先来建个工程</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408150829947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>ArtifactId为templete<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408150851255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408150910910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408150940532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="创建服务模块"><a href="#创建服务模块" class="headerlink" title="创建服务模块"></a>创建服务模块</h3><p>和建立项目一样的步骤建立一个module作为服务提供者<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408151840781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>同样方式创建服务消费者<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408152248811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h4 id="pom配置"><a href="#pom配置" class="headerlink" title="pom配置"></a>pom配置</h4><p>通过刚才那种方式建立的pom如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">  xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.hofe&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;templete&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;templete&lt;/name&gt;</span><br><span class="line">  &lt;!-- FIXME change it to the project<span class="string">'s website --&gt;</span></span><br><span class="line"><span class="string">  &lt;url&gt;http://www.example.com&lt;/url&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;properties&gt;</span></span><br><span class="line"><span class="string">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span></span><br><span class="line"><span class="string">    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span></span><br><span class="line"><span class="string">    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span></span><br><span class="line"><span class="string">  &lt;/properties&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;dependencies&gt;</span></span><br><span class="line"><span class="string">    &lt;dependency&gt;</span></span><br><span class="line"><span class="string">      &lt;groupId&gt;junit&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">      &lt;version&gt;4.11&lt;/version&gt;</span></span><br><span class="line"><span class="string">      &lt;scope&gt;test&lt;/scope&gt;</span></span><br><span class="line"><span class="string">    &lt;/dependency&gt;</span></span><br><span class="line"><span class="string">  &lt;/dependencies&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;build&gt;</span></span><br><span class="line"><span class="string">    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line"><span class="string">      &lt;plugins&gt;</span></span><br><span class="line"><span class="string">        &lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span></span><br><span class="line"><span class="string">        &lt;plugin&gt;</span></span><br><span class="line"><span class="string">          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">          &lt;version&gt;3.1.0&lt;/version&gt;</span></span><br><span class="line"><span class="string">        &lt;/plugin&gt;</span></span><br><span class="line"><span class="string">        &lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span></span><br><span class="line"><span class="string">        &lt;plugin&gt;</span></span><br><span class="line"><span class="string">          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">          &lt;version&gt;3.0.2&lt;/version&gt;</span></span><br><span class="line"><span class="string">        &lt;/plugin&gt;</span></span><br><span class="line"><span class="string">        &lt;plugin&gt;</span></span><br><span class="line"><span class="string">          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">          &lt;version&gt;3.8.0&lt;/version&gt;</span></span><br><span class="line"><span class="string">        &lt;/plugin&gt;</span></span><br><span class="line"><span class="string">        &lt;plugin&gt;</span></span><br><span class="line"><span class="string">          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">          &lt;version&gt;2.22.1&lt;/version&gt;</span></span><br><span class="line"><span class="string">        &lt;/plugin&gt;</span></span><br><span class="line"><span class="string">        &lt;plugin&gt;</span></span><br><span class="line"><span class="string">          &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">          &lt;version&gt;3.0.2&lt;/version&gt;</span></span><br><span class="line"><span class="string">        &lt;/plugin&gt;</span></span><br><span class="line"><span class="string">        &lt;plugin&gt;</span></span><br><span class="line"><span class="string">          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">          &lt;version&gt;2.5.2&lt;/version&gt;</span></span><br><span class="line"><span class="string">        &lt;/plugin&gt;</span></span><br><span class="line"><span class="string">        &lt;plugin&gt;</span></span><br><span class="line"><span class="string">          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">          &lt;version&gt;2.8.2&lt;/version&gt;</span></span><br><span class="line"><span class="string">        &lt;/plugin&gt;</span></span><br><span class="line"><span class="string">        &lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span></span><br><span class="line"><span class="string">        &lt;plugin&gt;</span></span><br><span class="line"><span class="string">          &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">          &lt;version&gt;3.7.1&lt;/version&gt;</span></span><br><span class="line"><span class="string">        &lt;/plugin&gt;</span></span><br><span class="line"><span class="string">        &lt;plugin&gt;</span></span><br><span class="line"><span class="string">          &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">          &lt;version&gt;3.0.0&lt;/version&gt;</span></span><br><span class="line"><span class="string">        &lt;/plugin&gt;</span></span><br><span class="line"><span class="string">      &lt;/plugins&gt;</span></span><br><span class="line"><span class="string">    &lt;/pluginManagement&gt;</span></span><br><span class="line"><span class="string">  &lt;/build&gt;</span></span><br><span class="line"><span class="string">&lt;/project&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改pom"><a href="#修改pom" class="headerlink" title="修改pom"></a>修改pom</h4><p>在项目pom中声明为SpringBoot项目，不用导入依赖包；并修改全部pom文件maven构建工具依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">  xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;!--将当前项目声明为SpringBoot--&gt;</span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.hofe&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;templete&lt;/artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;modules&gt;</span><br><span class="line">    &lt;module&gt;provider-user&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;consumer-order&lt;/module&gt;</span><br><span class="line">  &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;templete&lt;/name&gt;</span><br><span class="line">  &lt;!-- FIXME change it to the project<span class="string">'s website --&gt;</span></span><br><span class="line"><span class="string">  &lt;url&gt;http://www.example.com&lt;/url&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;properties&gt;</span></span><br><span class="line"><span class="string">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span></span><br><span class="line"><span class="string">    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span></span><br><span class="line"><span class="string">    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span></span><br><span class="line"><span class="string">  &lt;/properties&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;dependencies&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;dependency&gt;</span></span><br><span class="line"><span class="string">      &lt;groupId&gt;junit&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">      &lt;version&gt;4.11&lt;/version&gt;</span></span><br><span class="line"><span class="string">      &lt;scope&gt;test&lt;/scope&gt;</span></span><br><span class="line"><span class="string">    &lt;/dependency&gt;</span></span><br><span class="line"><span class="string">  &lt;/dependencies&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;build&gt;</span></span><br><span class="line"><span class="string">    &lt;!--可以用以下替换--&gt;</span></span><br><span class="line"><span class="string">      &lt;plugins&gt;</span></span><br><span class="line"><span class="string">         &lt;plugin&gt;</span></span><br><span class="line"><span class="string">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">         &lt;/plugin&gt;</span></span><br><span class="line"><span class="string">      &lt;/plugins&gt;</span></span><br><span class="line"><span class="string">  &lt;/build&gt;</span></span><br><span class="line"><span class="string">&lt;/project&gt;</span></span><br></pre></td></tr></table></figure><p>修改模块pom，并增加Spring-Boot-web依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;templete&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.hofe&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;provider-user&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;provider-user&lt;/name&gt;</span><br><span class="line">    &lt;!-- FIXME change it to the project<span class="string">'s website --&gt;</span></span><br><span class="line"><span class="string">    &lt;url&gt;http://www.example.com&lt;/url&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;properties&gt;</span></span><br><span class="line"><span class="string">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span></span><br><span class="line"><span class="string">        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span></span><br><span class="line"><span class="string">        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span></span><br><span class="line"><span class="string">    &lt;/properties&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;dependencies&gt;</span></span><br><span class="line"><span class="string">        &lt;dependency&gt;</span></span><br><span class="line"><span class="string">            &lt;groupId&gt;junit&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">            &lt;version&gt;4.11&lt;/version&gt;</span></span><br><span class="line"><span class="string">            &lt;scope&gt;test&lt;/scope&gt;</span></span><br><span class="line"><span class="string">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="string">        &lt;dependency&gt;</span></span><br><span class="line"><span class="string">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="string">    &lt;/dependencies&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;build&gt;</span></span><br><span class="line"><span class="string">        &lt;plugins&gt;</span></span><br><span class="line"><span class="string">            &lt;plugin&gt;</span></span><br><span class="line"><span class="string">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">            &lt;/plugin&gt;</span></span><br><span class="line"><span class="string">        &lt;/plugins&gt;</span></span><br><span class="line"><span class="string">    &lt;/build&gt;</span></span><br><span class="line"><span class="string">&lt;/project&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、配置服务"><a href="#二、配置服务" class="headerlink" title="二、配置服务"></a>二、配置服务</h2><h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p>创建实体类User<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040816103723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>创建UserController<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408161107144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>修改Application启动类<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408161219406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>添加resources资源文件夹，并创建application.yml配置文件<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408161318212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>启动服务<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408161501679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><p>pom配置、启动类、实体类User同服务提供者，不同点在于application.yml中端口设置和UserController的配置。</p><p>application.yml中端口<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408164236909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>UserController<br>消费者中的user是通过restTemplete访问提供者生产的user得到的<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020040816442476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>运行访问localhost:7901/user/id<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200408164132753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>这章节首先创建一个java项目，通过配置声明成springboot风格项目；创建的消费者和生产者模块模拟微服务，在两个模块中引入springboot-web依赖包，生产者提供资源，消费者通过restTemplete访问生产者接口url，从而获取资源。下一节，将会使用Eureka服务注册中心管理url。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Spring Cloud </category>
          
          <category> 入门实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生产者消费者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot学习笔记</title>
      <link href="/2020/04/06/Java/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/04/06/Java/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="跟武哥一起学习Spring-Boot"><a href="#跟武哥一起学习Spring-Boot" class="headerlink" title="跟武哥一起学习Spring Boot"></a>跟武哥一起学习Spring Boot</h1><h1 id="作者信息"><a href="#作者信息" class="headerlink" title="作者信息"></a>作者信息</h1><p>本课程首发于 CSDN GitChat 达人课《跟武哥一起学Spring Boot》，该文档为课程详细笔记。<br>作者：倪升武（武哥）<br>微信公众号：武哥聊编程<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/202002150421550.jpg"  alt="武哥聊编程"></p><blockquote><p>版权申明：本课程已经免费，但版权属于 CSDN 和作者，未经允许，不得将该笔记用于商业用途和其他不正当用途，否则追究法律责任。</p></blockquote><h1 id="导读：课程概览"><a href="#导读：课程概览" class="headerlink" title="导读：课程概览"></a>导读：课程概览</h1><h2 id="1-Spring-Boot是什么"><a href="#1-Spring-Boot是什么" class="headerlink" title="1. Spring Boot是什么"></a>1. Spring Boot是什么</h2><p>我们知道，从 2002 年开始，Spring 一直在飞速的发展，如今已经成为了在Java EE（Java Enterprise Edition）开发中真正意义上的标准，但是随着技术的发展，Java EE使用 Spring 逐渐变得笨重起来，大量的 XML 文件存在于项目之中。<strong>繁琐的配置，整合第三方框架的配置问题，导致了开发和部署效率的降低</strong>。  </p><p>2012 年 10 月，Mike Youngstrom 在 Spring jira 中创建了一个功能请求，要求<strong>在 Spring 框架中支持无容器 Web 应用程序体系结构</strong>。他谈到了在主容器引导 spring 容器内配置 Web 容器服务。这是 jira 请求的摘录：</p><blockquote><p>我认为 Spring 的 Web 应用体系结构可以大大简化，如果它提供了从上到下利用 Spring 组件和配置模型的工具和参考体系结构。在简单的 <code>main()</code>方法引导的 Spring 容器内嵌入和统一这些常用Web 容器服务的配置。 </p></blockquote><p>这一要求促使了 2013 年初开始的 Spring Boot 项目的研发，到今天，Spring Boot 的版本已经到了 2.0.3 RELEASE。Spring Boot 并不是用来替代 Spring 的解决方案，而<strong>是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具</strong>。</p><p>它集成了大量常用的第三方库配置，Spring Boot应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。   </p><h2 id="2-为什么学习Spring-Boot"><a href="#2-为什么学习Spring-Boot" class="headerlink" title="2. 为什么学习Spring Boot"></a>2. 为什么学习Spring Boot</h2><h3 id="2-1-从Spring官方来看"><a href="#2-1-从Spring官方来看" class="headerlink" title="2.1 从Spring官方来看"></a>2.1 从Spring官方来看</h3><p>我们打开 Spring 的<a href="http://spring.io/" target="_blank" rel="noopener">官方网站</a>，可以看到下图：  </p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/98fda7f0-8656-11e8-8675-5537a701ae7d"  alt="Spring官网首图"></p><p>我们可以看到图中官方对 Spring Boot 的定位：<em>Build Anything</em>， Build任何东西。Spring Boot旨在尽可能快地启动和运行，并且只需最少的 Spring 前期配置。  同时我们也来看一下官方对后面两个的定位：  </p><p>SpringCloud：<em>Coordinate Anything</em>，协调任何事情；<br>SpringCloud Data Flow：<em>Connect everything</em>，连接任何东西。</p><p>仔细品味一下，Spring 官网对 Spring Boot、SpringCloud 和 SpringCloud Data Flow三者定位的措辞非常有味道，同时也可以看出，Spring 官方对这三个技术非常重视，是现在以及今后学习的重点（SpringCloud 相关达人课课程届时也会上线）。</p><h3 id="2-2-从Spring-Boot的优点来看"><a href="#2-2-从Spring-Boot的优点来看" class="headerlink" title="2.2 从Spring Boot的优点来看"></a>2.2 从Spring Boot的优点来看</h3><p>Spring Boot 有哪些优点？主要给我们解决了哪些问题呢？我们以下图来说明：</p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/e17b8c40-8656-11e8-8a91-d70bc2d847c5"  alt="Spring Boot的优点"></p><h4 id="2-2-1-良好的基因"><a href="#2-2-1-良好的基因" class="headerlink" title="2.2.1 良好的基因"></a>2.2.1 良好的基因</h4><p>Spring Boot 是伴随着 Spring 4.0 诞生的，从字面理解，Boot是引导的意思，因此 Spring Boot 旨在帮助开发者快速搭建 Spring 框架。Spring Boot 继承了原有 Spring 框架的优秀基因，使 Spring 在使用中更加方便快捷。</p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/00078650-8657-11e8-87de-d910a3ee087e"  alt="Spring Boot与Spring"></p><h4 id="2-2-2-简化编码"><a href="#2-2-2-简化编码" class="headerlink" title="2.2.2 简化编码"></a>2.2.2 简化编码</h4><p>举个例子，比如我们要创建一个 web 项目，使用 Spring 的朋友都知道，在使用 Spring 的时候，需要在 pom 文件中添加多个依赖，而 Spring Boot 则会帮助开发着快速启动一个 web 容器，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们点击进入该依赖后可以看到，Spring Boot 这个 starter-web 已经包含了多个依赖，包括之前在 Spring 工程中需要导入的依赖，我们看一下其中的一部分，如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- .....省略其他依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由此可以看出，Spring Boot 大大简化了我们的编码，我们不用一个个导入依赖，直接一个依赖即可。</p><h4 id="2-2-3-简化配置"><a href="#2-2-3-简化配置" class="headerlink" title="2.2.3 简化配置"></a>2.2.3 简化配置</h4><p>Spring 虽然使Java EE轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种XML、Annotation配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。举个例子：</p><p>我新建一个类，但是我不用 <code>@Service</code>注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要<code>@Configuration</code> 和<code>@Bean</code>两个注解即可，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Spring Boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestService <span class="title">getTestService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Configuration</code>表示该类是个配置类，<code>@Bean</code>表示该方法返回一个 Bean。这样就把<code>TestService</code>作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用<code>@Resource</code>注解注入进来即可使用，非常方便。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> TestService testService;</span><br></pre></td></tr></table></figure><p>另外，部署配置方面，原来 Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可。</p><h4 id="2-2-4-简化部署"><a href="#2-2-4-简化部署" class="headerlink" title="2.2.4 简化部署"></a>2.2.4 简化部署</h4><p>在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里，在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 <code>java -jar xxx.jar</code>一键式启动项目。</p><p>另外，也降低对运行环境的基本要求，环境变量中有JDK即可。</p><h4 id="2-2-5-简化监控"><a href="#2-2-5-简化监控" class="headerlink" title="2.2.5 简化监控"></a>2.2.5 简化监控</h4><p>我们可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，比较方便。但是 Spring Boot 只是个微框架，没有提供相应的服务发现与注册的配套功能，没有外围监控集成方案，没有外围安全管理方案，所以在微服务架构中，还需要 Spring Cloud 来配合一起使用。</p><h3 id="2-3-从未来发展的趋势来看"><a href="#2-3-从未来发展的趋势来看" class="headerlink" title="2.3 从未来发展的趋势来看"></a>2.3 从未来发展的趋势来看</h3><p>微服务是未来发展的趋势，项目会从传统架构慢慢转向微服务架构，因为微服务可以使不同的团队专注于更小范围的工作职责、使用独立的技术、更安全更频繁地部署。而 继承了 Spring 的优良特性，与 Spring 一脉相承，而且 支持各种REST API 的实现方式。Spring Boot 也是官方大力推荐的技术，可以看出，Spring Boot 是未来发展的一个大趋势。</p><h2 id="3-本课程能学到什么"><a href="#3-本课程能学到什么" class="headerlink" title="3. 本课程能学到什么"></a>3. 本课程能学到什么</h2><p>本课程使用目前 Spring Boot 最新版本2.0.3 RELEASE，课程文章均为作者在实际项目中剥离出来的场景和demo，目标是带领学习者快速上手 Spring Boot，将 Spring Boot 相关技术点快速运用在微服务项目中。全篇分为两部分：基础篇和进阶篇。  </p><p>基础篇（01—10课）主要介绍 Spring Boot 在项目中最常使用的一些功能点，旨在带领学习者快速掌握 Spring Boot 在开发时需要的知识点，能够把 Spring Boot 相关技术运用到实际项目架构中去。该部分以 Spring Boot 框架为主线，内容包括Json数据封装、日志记录、属性配置、MVC支持、在线文档、模板引擎、异常处理、AOP 处理、持久层集成等等。  </p><p>进阶篇（11—17课）主要是介绍 Spring Boot 在项目中拔高一些的技术点，包括集成的一些组件，旨在带领学习者在项目中遇到具体的场景时能够快速集成，完成对应的功能。该部分以 Spring Boot 框架为主线，内容包括拦截器、监听器、缓存、安全认证、分词插件、消息队列等等。  </p><p>认真读完该系列文章之后，学习者会快速了解并掌握 Spring Boot 在项目中最常用的技术点，作者课程的最后，会基于课程内容搭建一个 Spring Boot 项目的空架构，该架构也是从实际项目中剥离出来，学习者可以运用该架构于实际项目中，具备使用 Spring Boot 进行实际项目开发的能力。  </p><p>课程所有源码提供免费下载：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">下载地址</a>。</p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h2 id="4-适合阅读的人群"><a href="#4-适合阅读的人群" class="headerlink" title="4. 适合阅读的人群"></a>4. 适合阅读的人群</h2><p>本课程适合以下人群阅读：</p><ul><li>有一定的Java语言基础，了解Spring、Maven的在校学生或自学者</li><li>有传统项目经验，想往微服务方向发展的工作人员</li><li>热衷于新技术并对 Spring Boot 感兴趣的人员</li><li>希望了解 Spring Boot 2.0.3 的研究人员<h2 id="5-本课程开发环境和插件"><a href="#5-本课程开发环境和插件" class="headerlink" title="5. 本课程开发环境和插件"></a>5. 本课程开发环境和插件</h2></li></ul><p>本课程的开发环境：</p><ul><li>开发工具：IDEA 2017</li><li>JDK版本： JDK 1.8</li><li>Spring Boot版本：2.0.3 RELEASE</li><li>Maven版本：3.5.2</li></ul><p>涉及到的插件：</p><ul><li>FastJson</li><li>Swagger2</li><li>Thymeleaf</li><li>MyBatis</li><li>Redis</li><li>ActiveMQ</li><li>Shiro</li><li>Lucence</li></ul><h2 id="6-课程目录"><a href="#6-课程目录" class="headerlink" title="6. 课程目录"></a>6. 课程目录</h2><ul><li>导读：课程概览</li><li>第01课：Spring Boot开发环境搭建和项目启动</li><li>第02课：Spring Boot返回Json数据及数据封装</li><li>第03课：Spring Boot使用slf4j进行日志记录</li><li>第04课：Spring Boot中的项目属性配置</li><li>第05课：Spring Boot中的MVC支持</li><li>第06课：Spring Boot集成Swagger2展现在线接口文档</li><li>第07课：Spring Boot集成Thymeleaf模板引擎</li><li>第08课：Spring Boot中的全局异常处理</li><li>第09课：Spring Boot中的切面AOP处理</li><li>第10课：Spring Boot中集成MyBatis</li><li>第11课：Spring Boot事务配置管理</li><li>第12课：Spring Boot中使用监听器</li><li>第13课：Spring Boot中使用拦截器</li><li>第14课：Spring Boot中集成Redis</li><li>第15课：Spring Boot中集成ActiveMQ</li><li>第16课：Spring Boot中集成Shiro</li><li>第17课：Spring Boot中结成Lucence</li><li>第18课：Spring Boot搭建实际项目开发中的架构</li></ul><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第01课：Spring-Boot开发环境搭建和项目启动"><a href="#第01课：Spring-Boot开发环境搭建和项目启动" class="headerlink" title="第01课：Spring Boot开发环境搭建和项目启动"></a>第01课：Spring Boot开发环境搭建和项目启动</h1><p>上一节对 SpringBoot 的特性做了一个介绍，本节主要对 <strong>jdk 的配置、Spring Boot工程的构建和项目的启动、Spring Boot 项目工程的结构做一下讲解和分析</strong>。</p><h2 id="1-jdk-的配置"><a href="#1-jdk-的配置" class="headerlink" title="1. jdk 的配置"></a>1. jdk 的配置</h2><p>本课程是使用 IDEA 进行开发，在IDEA 中配置 jdk 的方式很简单，打开<code>File-&gt;Project Structure</code>，如下图所：</p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/9befde80-8659-11e8-9b0d-95de449dc107"  alt="IDEA中配置jdk"></p><ol><li>选择 SDKs</li><li>在 JDK home path 中选择本地 jdk 的安装目录</li><li>在 Name 中为 jdk 自定义名字</li></ol><p>通过以上三步骤，即可导入本地安装的 jdk。如果是使用 STS 或者 eclipse 的朋友，可以通过两步骤添加：</p><ul><li><code>window-&gt;preference-&gt;java-&gt;Instralled JRES</code>来添加本地 jdk。</li><li><code>window--&gt;preference--&gt;java--&gt;Compiler</code>选择 jre，和 jdk 保持一致。</li></ul><h2 id="2-Spring-Boot-工程的构建"><a href="#2-Spring-Boot-工程的构建" class="headerlink" title="2. Spring Boot 工程的构建"></a>2. Spring Boot 工程的构建</h2><h3 id="2-1-IDEA-快速构建"><a href="#2-1-IDEA-快速构建" class="headerlink" title="2.1 IDEA 快速构建"></a>2.1 IDEA 快速构建</h3><p>IDEA 中可以通过<code>File-&gt;New-&gt;Project</code>来快速构建 Spring Boot 工程。如下，选择 Spring Initializr，在 Project SDK 中选择刚刚我们导入的 jdk，点击 Next，到了项目的配置信息。</p><ul><li>Group：填企业域名，本课程使用com.itcodai</li><li>Artifact：填项目名称，本课程中每一课的工程名以<code>course+课号</code>命令，这里使用 course01</li><li>Dependencies：可以添加我们项目中所需要的依赖信息，根据实际情况来添加，本课程只需要选择 Web 即可。</li></ul><h3 id="2-2-官方构建"><a href="#2-2-官方构建" class="headerlink" title="2.2 官方构建"></a>2.2 官方构建</h3><p>第二种方式可以通过官方构建，步骤如下：</p><ul><li>访问 <a href="http://start.spring.io/。" target="_blank" rel="noopener">http://start.spring.io/。</a></li><li>在页面上输入相应的 Spring Boot 版本、Group 和 Artifact 信息以及项目依赖，然后创建项目。</li><li><img src="/" class="lazyload" data-src="https://images.gitbook.cn/014a1ba0-865b-11e8-956e-f528114b28bd"  alt="创建Spring Boot工程"></li><li>解压后，使用 IDEA 导入该 maven 工程：<code>File-&gt;New-&gt;Model from Existing Source</code>，然后选择解压后的项目文件夹即可。如果是使用 eclipse 的朋友，可以通过<code>Import-&gt;Existing Maven Projects-&gt;Next</code>，然后选择解压后的项目文件夹即可。</li></ul><h3 id="2-3-maven配置"><a href="#2-3-maven配置" class="headerlink" title="2.3 maven配置"></a>2.3 maven配置</h3><p>创建了 Spring Boot 项目之后，需要进行 maven 配置。打开<code>File-&gt;settings</code>，搜索 maven，配置一下本地的 maven 信息。如下：</p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/2ff7b930-865b-11e8-8675-5537a701ae7d"  alt="maven配置"></p><p>在 Maven home directory 中选择本地 Maven 的安装路径；在 User settings file 中选择本地 Maven 的配置文件所在路径。在配置文件中，我们配置一下国内阿里的镜像，这样在下载 maven 依赖时，速度很快。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是使用 eclipse 的朋友，可以通过<code>window--&gt;preference--&gt;Maven--&gt;User Settings</code>来配置，配置方式和上面一致。</p><h3 id="2-4-编码配置"><a href="#2-4-编码配置" class="headerlink" title="2.4 编码配置"></a>2.4 编码配置</h3><p>同样地，新建项目后，我们一般都需要配置编码，这点非常重要，很多初学者都会忘记这一步，所以要养成良好的习惯。</p><p>IDEA 中，仍然是打开<code>File-&gt;settings</code>，搜索 encoding，配置一下本地的编码信息。如下：</p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/57564e60-865b-11e8-8a91-d70bc2d847c5"  alt="编码配置"></p><p>如果是使用 eclipse 的朋友，有两个地方需要设置一下编码：</p><ul><li>window–&gt; perferences–&gt;General–&gt;Workspace，将Text file encoding改成utf-8</li><li>window–&gt;perferences–&gt;General–&gt;content types，选中Text，将Default encoding填入utf-8</li></ul><p>OK，编码设置完成即可启动项目工程了。</p><h2 id="3-Spring-Boot-项目工程结构"><a href="#3-Spring-Boot-项目工程结构" class="headerlink" title="3. Spring Boot 项目工程结构"></a>3. Spring Boot 项目工程结构</h2><p>Spring Boot 项目总共有三个模块，如下图所示：</p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/8b32fa80-865b-11e8-9d13-03ea4b4d8504"  alt="Spring Boot项目工程结构"></p><ul><li>src/main/java路径：主要编写业务程序</li><li>src/main/resources路径：存放静态文件和配置文件</li><li>src/test/java路径：主要编写测试程序</li></ul><p>默认情况下，如上图所示会创建一个启动类 Course01Application，该类上面有个<code>@SpringBootApplication</code>注解，该启动类中有个 main 方法，没错，Spring Boot 启动只要运行该 main 方法即可，非常方便。另外，Spring Boot 内部集成了 tomcat，不需要我们人为手动去配置 tomcat，开发者只需要关注具体的业务逻辑即可。</p><p>到此为止，Spring Boot 就启动成功了，为了比较清楚的看到效果，我们写一个 Controller 来测试一下，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itcodai.course01.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/start"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/springboot"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">startSpringBoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Welcome to the world of Spring Boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行 main 方法启动项目，在浏览器中输入 <code>localhost:8080/start/springboot</code>，如果看到 <code>“Welcome to the world of Spring Boot!”</code>，那么恭喜你项目启动成功！Spring Boot 就是这么简单方便！端口号默认是8080，如果想要修改，可以在 application.yml 文件中使用 <code>server.port</code> 来人为指定端口，如8001端口：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本节我们快速学习了如何在 IDEA 中导入 jdk，以及使用 IDEA 如何配置 maven 和编码，如何快速的创建和启动 Spring Boot 工程。IDEA 对 Spring Boot 的支持非常友好，建议大家使用 IDEA 进行 Spring Boot 的开发，从下一课开始，我们真正进入 Spring Boot 的学习中。<br>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第02课：Spring-Boot返回Json数据及数据封装"><a href="#第02课：Spring-Boot返回Json数据及数据封装" class="headerlink" title="第02课：Spring Boot返回Json数据及数据封装"></a>第02课：Spring Boot返回Json数据及数据封装</h1><p>在项目开发中，接口与接口之间，前后端之间数据的传输都使用 Json 格式，在 Spring Boot 中，接口返回 Json 格式的数据很简单，在 Controller 中使用<code>@RestController</code>注解即可返回 Json 格式的数据，<code>@RestController</code>也是 Spring Boot 新增的一个注解，我们点进去看一下该注解都包含了哪些东西。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出， <code>@RestController</code> 注解包含了原来的 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解，使用过 Spring 的朋友对 <code>@Controller</code> 注解已经非常了解了，这里不再赘述， <code>@ResponseBody</code> 注解是将返回的数据结构转换为 Json 格式。所以在默认情况下，使用了 <code>@RestController</code> 注解即可将返回的数据结构转换成 Json 格式，Spring Boot 中默认使用的 Json 解析技术框架是 jackson。我们点开 pom.xml 中的 <code>spring-boot-starter-web</code> 依赖，可以看到一个 <code>spring-boot-starter-json</code> 依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring Boot 中对依赖都做了很好的封装，可以看到很多 <code>spring-boot-starter-xxx</code> 系列的依赖，这是 Spring Boot 的特点之一，不需要人为去引入很多相关的依赖了，starter-xxx 系列直接都包含了所必要的依赖，所以我们再次点进去上面这个 <code>spring-boot-starter-json</code> 依赖，可以看到：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.module<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-module-parameter-names<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>到此为止，我们知道了 Spring Boot 中默认使用的 json 解析框架是 jackson。下面我们看一下默认的 jackson 框架对常用数据类型的转 Json 处理。</p><h2 id="1-Spring-Boot-默认对Json的处理"><a href="#1-Spring-Boot-默认对Json的处理" class="headerlink" title="1. Spring Boot 默认对Json的处理"></a>1. Spring Boot 默认对Json的处理</h2><p>在实际项目中，常用的数据结构无非有类对象、List对象、Map对象，我们看一下默认的 jackson 框架对这三个常用的数据结构转成 json 后的格式如何。</p><h3 id="1-1-创建-User-实体类"><a href="#1-1-创建-User-实体类" class="headerlink" title="1.1 创建 User 实体类"></a>1.1 创建 User 实体类</h3><p>为了测试，我们需要创建一个实体类，这里我们就用 User 来演示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"><span class="comment">/* 省略get、set和带参构造方法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-创建Controller类"><a href="#1-2-创建Controller类" class="headerlink" title="1.2 创建Controller类"></a>1.2 创建Controller类</h3><p>然后我们创建一个 Controller，分别返回 <code>User</code>对象、<code>List&lt;User&gt;</code> 和 <code>Map&lt;String, Object&gt;</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itcodai.course02.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/json"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"达人课"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/map"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        map.put(<span class="string">"作者信息"</span>, user);</span><br><span class="line">        map.put(<span class="string">"博客地址"</span>, <span class="string">"http://blog.itcodai.com"</span>);</span><br><span class="line">        map.put(<span class="string">"CSDN地址"</span>, <span class="string">"http://blog.csdn.net/eson_15"</span>);</span><br><span class="line">        map.put(<span class="string">"粉丝数量"</span>, <span class="number">4153</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-测试不同数据类型返回的json"><a href="#1-3-测试不同数据类型返回的json" class="headerlink" title="1.3 测试不同数据类型返回的json"></a>1.3 测试不同数据类型返回的json</h3><p>OK，写好了接口，分别返回了一个 User 对象、一个 List 集合和一个 Map 集合，其中 Map 集合中的 value 存的是不同的数据类型。接下来我们依次来测试一下效果。</p><p>在浏览器中输入：<code>localhost:8080/json/user</code> 返回 json 如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>&#125;</span><br></pre></td></tr></table></figure><p>在浏览器中输入：<code>localhost:8080/json/list</code> 返回 json 如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>&#125;,&#123;<span class="attr">"id"</span>:<span class="number">2</span>,<span class="attr">"username"</span>:<span class="string">"达人课"</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>&#125;]</span><br></pre></td></tr></table></figure><p>在浏览器中输入：<code>localhost:8080/json/map</code> 返回 json 如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"作者信息"</span>:&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>&#125;,<span class="attr">"CSDN地址"</span>:<span class="string">"http://blog.csdn.net/eson_15"</span>,<span class="attr">"粉丝数量"</span>:<span class="number">4153</span>,<span class="attr">"博客地址"</span>:<span class="string">"http://blog.itcodai.com"</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看出，map 中不管是什么数据类型，都可以转成相应的 json 格式，这样就非常方便。</p><h3 id="1-4-jackson-中对null的处理"><a href="#1-4-jackson-中对null的处理" class="headerlink" title="1.4 jackson 中对null的处理"></a>1.4 jackson 中对null的处理</h3><p>在实际项目中，我们难免会遇到一些 null 值出现，我们转 json 时，是不希望有这些 null 出现的，比如我们期望所有的 null 在转 json 时都变成 “” 这种空字符串，那怎么做呢？在 Spring Boot 中，我们做一下配置即可，新建一个 jackson 的配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonGenerator;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonSerializer;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializerProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(ObjectMapper<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ObjectMapper</span> <span class="title">jacksonObjectMapper</span>(<span class="title">Jackson2ObjectMapperBuilder</span> <span class="title">builder</span>) </span>&#123;</span><br><span class="line">        ObjectMapper objectMapper = builder.createXmlMapper(<span class="keyword">false</span>).build();</span><br><span class="line">        objectMapper.getSerializerProvider().setNullValueSerializer(<span class="keyword">new</span> JsonSerializer&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                jsonGenerator.writeString(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们修改一下上面返回 map 的接口，将几个值改成 null 测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/map"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="keyword">null</span>);</span><br><span class="line">    map.put(<span class="string">"作者信息"</span>, user);</span><br><span class="line">    map.put(<span class="string">"博客地址"</span>, <span class="string">"http://blog.itcodai.com"</span>);</span><br><span class="line">    map.put(<span class="string">"CSDN地址"</span>, <span class="keyword">null</span>);</span><br><span class="line">    map.put(<span class="string">"粉丝数量"</span>, <span class="number">4153</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启项目，再次输入：<code>localhost:8080/json/map</code>，可以看到 jackson 已经将所有 null 字段转成了空字符串了。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"作者信息"</span>:&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>,<span class="attr">"password"</span>:<span class="string">""</span>&#125;,<span class="attr">"CSDN地址"</span>:<span class="string">""</span>,<span class="attr">"粉丝数量"</span>:<span class="number">4153</span>,<span class="attr">"博客地址"</span>:<span class="string">"http://blog.itcodai.com"</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="2-使用阿里巴巴FastJson的设置"><a href="#2-使用阿里巴巴FastJson的设置" class="headerlink" title="2. 使用阿里巴巴FastJson的设置"></a>2. 使用阿里巴巴FastJson的设置</h2><h3 id="2-1-jackson-和-fastJson-的对比"><a href="#2-1-jackson-和-fastJson-的对比" class="headerlink" title="2.1 jackson 和 fastJson 的对比"></a>2.1 jackson 和 fastJson 的对比</h3><p>有很多朋友习惯于使用阿里巴巴的 fastJson 来做项目中 json 转换的相关工作，目前我们项目中使用的就是阿里的 fastJson，那么 jackson 和 fastJson 有哪些区别呢？根据网上公开的资料比较得到下表。<br>| 选项 | fastJson | jackson |<br>| :-: | :-: | :-: |<br>| 上手难易程度 | 容易 | 中等 |<br>| 高级特性支持 | 中等 | 丰富 |<br>| 官方文档、Example支持 | 中文 | 英文 |<br>| 处理json速度 | 略快 | 快 |</p><p>关于 fastJson 和 jackson 的对比，网上有很多资料可以查看，主要是根据自己实际项目情况来选择合适的框架。从扩展上来看，fastJson 没有 jackson 灵活，从速度或者上手难度来看，fastJson 可以考虑，我们项目中目前使用的是阿里的 fastJson，挺方便的。</p><h3 id="2-2-fastJson依赖导入"><a href="#2-2-fastJson依赖导入" class="headerlink" title="2.2 fastJson依赖导入"></a>2.2 fastJson依赖导入</h3><p>使用 fastJson 需要导入依赖，本课程使用 1.2.35 版本，依赖如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-使用-fastJson-处理-null"><a href="#2-2-使用-fastJson-处理-null" class="headerlink" title="2.2 使用 fastJson 处理 null"></a>2.2 使用 fastJson 处理 null</h3><p>使用 fastJson 时，对 null 的处理和 jackson 有些不同，需要继承  <code>WebMvcConfigurationSupport</code> 类，然后覆盖 <code>configureMessageConverters</code> 方法，在方法中，我们可以选择对要实现 null 转换的场景，配置好即可。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.support.config.FastJsonConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fastJsonConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用阿里 FastJson 作为JSON MessageConverter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        FastJsonHttpMessageConverter converter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">        FastJsonConfig config = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">        config.setSerializerFeatures(</span><br><span class="line">                <span class="comment">// 保留map空的字段</span></span><br><span class="line">                SerializerFeature.WriteMapNullValue,</span><br><span class="line">                <span class="comment">// 将String类型的null转成""</span></span><br><span class="line">                SerializerFeature.WriteNullStringAsEmpty,</span><br><span class="line">                <span class="comment">// 将Number类型的null转成0</span></span><br><span class="line">                SerializerFeature.WriteNullNumberAsZero,</span><br><span class="line">                <span class="comment">// 将List类型的null转成[]</span></span><br><span class="line">                SerializerFeature.WriteNullListAsEmpty,</span><br><span class="line">                <span class="comment">// 将Boolean类型的null转成false</span></span><br><span class="line">                SerializerFeature.WriteNullBooleanAsFalse,</span><br><span class="line">                <span class="comment">// 避免循环引用</span></span><br><span class="line">                SerializerFeature.DisableCircularReferenceDetect);</span><br><span class="line"></span><br><span class="line">        converter.setFastJsonConfig(config);</span><br><span class="line">        converter.setDefaultCharset(Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">        List&lt;MediaType&gt; mediaTypeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 解决中文乱码问题，相当于在Controller上的@RequestMapping中加了个属性produces = "application/json"</span></span><br><span class="line">        mediaTypeList.add(MediaType.APPLICATION_JSON);</span><br><span class="line">        converter.setSupportedMediaTypes(mediaTypeList);</span><br><span class="line">        converters.add(converter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-封装统一返回的数据结构"><a href="#3-封装统一返回的数据结构" class="headerlink" title="3. 封装统一返回的数据结构"></a>3. 封装统一返回的数据结构</h2><p>以上是 Spring Boot 返回 json 的几个代表的例子，但是在实际项目中，除了要封装数据之外，我们往往需要在返回的 json 中添加一些其他信息，比如返回一些状态码 code ，返回一些 msg 给调用者，这样调用者可以根据 code 或者 msg 做一些逻辑判断。所以在实际项目中，我们需要封装一个统一的 json 返回结构存储返回信息。 </p><h3 id="3-1-定义统一的-json-结构"><a href="#3-1-定义统一的-json-结构" class="headerlink" title="3.1 定义统一的 json 结构"></a>3.1 定义统一的 json 结构</h3><p>由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">"操作成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若没有数据返回，可以人为指定状态码和提示信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有数据返回时，状态码为0，默认提示信息为：操作成功！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">"操作成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有数据返回，状态码为0，人为指定提示信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(T data, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-修改-Controller-中的返回值类型及测试"><a href="#3-2-修改-Controller-中的返回值类型及测试" class="headerlink" title="3.2 修改 Controller 中的返回值类型及测试"></a>3.2 修改 Controller 中的返回值类型及测试</h3><p>由于 JsonResult 使用了泛型，所以所有的返回值类型都可以使用该统一结构，在具体的场景将泛型替换成具体的数据类型即可，非常方便，也便于维护。在实际项目中，还可以继续封装，比如状态码和提示信息可以定义一个枚举类型，以后我们只需要维护这个枚举类型中的数据即可（在本课程中就不展开了）。根据以上的 JsonResult，我们改写一下 Controller，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/jsonresult"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonResultController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;User&gt; <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult&lt;&gt;(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;List&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"达人课"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult&lt;&gt;(userList, <span class="string">"获取用户列表成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/map"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;Map&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"倪升武"</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="string">"作者信息"</span>, user);</span><br><span class="line">        map.put(<span class="string">"博客地址"</span>, <span class="string">"http://blog.itcodai.com"</span>);</span><br><span class="line">        map.put(<span class="string">"CSDN地址"</span>, <span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="string">"粉丝数量"</span>, <span class="number">4153</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult&lt;&gt;(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重新在浏览器中输入：<code>localhost:8080/jsonresult/user</code> 返回 json 如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="string">"0"</span>,<span class="attr">"data"</span>:&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>&#125;,<span class="attr">"msg"</span>:<span class="string">"操作成功！"</span>&#125;</span><br></pre></td></tr></table></figure><p>输入：<code>localhost:8080/jsonresult/list</code>，返回 json 如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="string">"0"</span>,<span class="attr">"data"</span>:[&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>&#125;,&#123;<span class="attr">"id"</span>:<span class="number">2</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>,<span class="attr">"username"</span>:<span class="string">"达人课"</span>&#125;],<span class="attr">"msg"</span>:<span class="string">"获取用户列表成功"</span>&#125;</span><br></pre></td></tr></table></figure><p>输入：<code>localhost:8080/jsonresult/map</code>，返回 json 如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="string">"0"</span>,<span class="attr">"data"</span>:&#123;<span class="attr">"作者信息"</span>:&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"password"</span>:<span class="string">""</span>,<span class="attr">"username"</span>:<span class="string">"倪升武"</span>&#125;,<span class="attr">"CSDN地址"</span>:<span class="literal">null</span>,<span class="attr">"粉丝数量"</span>:<span class="number">4153</span>,<span class="attr">"博客地址"</span>:<span class="string">"http://blog.itcodai.com"</span>&#125;,<span class="attr">"msg"</span>:<span class="string">"操作成功！"</span>&#125;</span><br></pre></td></tr></table></figure><p>通过封装，我们不但将数据通过 json 传给前端或者其他接口，还带上了状态码和提示信息，这在实际项目场景中应用非常广泛。</p><h2 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本节主要对 Spring Boot 中 json 数据的返回做了详细的分析，从 Spring Boot 默认的 jackson 框架到阿里巴巴的 fastJson 框架，分别对它们的配置做了相应的讲解。另外，结合实际项目情况，总结了实际项目中使用的 json 封装结构体，加入了状态码和提示信息，使得返回的 json 数据信息更加完整。<br>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第03课：Spring-Boot使用slf4j进行日志记录"><a href="#第03课：Spring-Boot使用slf4j进行日志记录" class="headerlink" title="第03课：Spring Boot使用slf4j进行日志记录"></a>第03课：Spring Boot使用slf4j进行日志记录</h1><p>在开发中，我们经常使用 <code>System.out.println()</code> 来打印一些信息，但是这样不好，因为大量的使用 <code>System.out</code> 会增加资源的消耗。我们实际项目中使用的是 slf4j 的 logback 来输出日志，效率挺高的，Spring Boot 提供了一套日志系统，logback 是最优的选择。</p><h2 id="1-slf4j-介绍"><a href="#1-slf4j-介绍" class="headerlink" title="1. slf4j 介绍"></a>1. slf4j 介绍</h2><p>引用百度百科里的一段话：</p><blockquote><p>SLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。</p></blockquote><p>这段的大概意思是：你只需要按统一的方式写记录日志的代码，而无需关心日志是通过哪个日志系统，以什么风格输出的。因为它们取决于部署项目时绑定的日志系统。例如，在项目中使用了 slf4j 记录日志，并且绑定了 log4j（即导入相应的依赖），则日志会以 log4j 的风格输出；后期需要改为以 logback 的风格输出日志，只需要将 log4j 替换成 logback 即可，不用修改项目中的代码。这对于第三方组件的引入的不同日志系统来说几乎零学习成本，况且它的优点不仅仅这一个而已，还有简洁的占位符的使用和日志级别的判断。</p><p>正因为 sfl4j 有如此多的优点，阿里巴巴已经将 slf4j 作为他们的日志框架了。在《阿里巴巴Java开发手册(正式版)》中，日志规约一项第一条就强制要求使用 slf4j：</p><blockquote><p>1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p></blockquote><p>“强制”两个字体现出了 slf4j 的优势，所以建议在实际项目中，使用 slf4j 作为自己的日志框架。使用 slf4j 记录日志非常简单，直接使用  LoggerFactory 创建即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Test<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-application-yml-中对日志的配置"><a href="#2-application-yml-中对日志的配置" class="headerlink" title="2. application.yml 中对日志的配置"></a>2. application.yml 中对日志的配置</h2><p>Spring Boot 对 slf4j 支持的很好，内部已经集成了 slf4j，一般我们在使用的时候，会对slf4j 做一下配置。<code>application.yml</code> 文件是 Spring Boot 中唯一一个需要配置的文件，一开始创建工程的时候是 <code>application.properties</code> 文件，个人比较细化用 yml 文件，因为 yml 文件的层次感特别好，看起来更直观，但是 yml 文件对格式要求比较高，比如英文冒号后面必须要有个空格，否则项目估计无法启动，而且也不报错。用 properties 还是 yml 视个人习惯而定，都可以。本课程使用 yml。</p><p>我们看一下 application.yml 文件中对日志的配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  config: logback.xml</span><br><span class="line">  level:</span><br><span class="line">    com.itcodai.course03.dao: trace</span><br></pre></td></tr></table></figure><p><code>logging.config</code> 是用来指定项目启动的时候，读取哪个配置文件，这里指定的是日志配置文件是根路径下的 <code>logback.xml</code> 文件，关于日志的相关配置信息，都放在 <code>logback.xml</code> 文件中了。<code>logging.level</code> 是用来指定具体的 mapper 中日志的输出级别，上面的配置表示 <code>com.itcodai.course03.dao</code> 包下的所有 mapper 日志输出级别为 trace，会将操作数据库的 sql 打印出来，开发时设置成 trace 方便定位问题，在生产环境上，将这个日志级别再设置成 error 级别即可（本节课不讨论 mapper 层，在后面 Spring Boot 集成 MyBatis 时再详细讨论）。</p><p>常用的日志级别按照从高到低依次为：ERROR、WARN、INFO、DEBUG。</p><h2 id="3-logback-xml-配置文件解析"><a href="#3-logback-xml-配置文件解析" class="headerlink" title="3. logback.xml 配置文件解析"></a>3. logback.xml 配置文件解析</h2><p>在上面 <code>application.yml</code> 文件中，我们指定了日志配置文件 <code>logback.xml</code>，<code>logback.xml</code> 文件中主要用来做日志的相关配置。在 <code>logback.xml</code> 中，我们可以定义日志输出的格式、路径、控制台输出格式、文件大小、保存时长等等。下面来分析一下：</p><h3 id="3-1-定义日志输出格式和存储路径"><a href="#3-1-定义日志输出格式和存储路径" class="headerlink" title="3.1 定义日志输出格式和存储路径"></a>3.1 定义日志输出格式和存储路径</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_PATTERN"</span> <span class="attr">value</span>=<span class="string">"%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"FILE_PATH"</span> <span class="attr">value</span>=<span class="string">"D:/logs/course03/demo.%d&#123;yyyy-MM-dd&#125;.%i.log"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们来看一下这个定义的含义：首先定义一个格式，命名为 “LOG_PATTERN”，该格式中 <code>%date</code> 表示日期，<code>%thread</code> 表示线程名，<code>%-5level</code> 表示级别从左显示5个字符宽度，<code>%logger{36}</code>  表示 logger 名字最长36个字符，<code>%msg</code> 表示日志消息，<code>%n</code> 是换行符。</p><p>然后再定义一下名为 “FILE_PATH” 文件路径，日志都会存储在该路径下。<code>%i</code> 表示第 i 个文件，当日志文件达到指定大小时，会将日志生成到新的文件里，这里的 i 就是文件索引，日志文件允许的大小可以设置，下面会讲解。这里需要注意的是，不管是 windows 系统还是 Linux 系统，日志存储的路径必须要是绝对路径。</p><h3 id="3-2-定义控制台输出"><a href="#3-2-定义控制台输出" class="headerlink" title="3.2 定义控制台输出"></a>3.2 定义控制台输出</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>&lt;appender&gt;</code> 节点设置个控制台输出（<code>class=&quot;ch.qos.logback.core.ConsoleAppender&quot;</code>）的配置，定义为 “CONSOLE”。使用上面定义好的输出格式（LOG_PATTERN）来输出，使用 <code>${}</code> 引用进来即可。</p><h3 id="3-3-定义日志文件的相关参数"><a href="#3-3-定义日志文件的相关参数" class="headerlink" title="3.3 定义日志文件的相关参数"></a>3.3 定义日志文件的相关参数</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按照上面配置的FILE_PATH路径来保存日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;FILE_PATH&#125;<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志保存15天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 单个日志文件的最大，超过则新建日志文件存储 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>&lt;appender&gt;</code> 定义一个名为 “FILE” 的文件配置，主要是配置日志文件保存的时间、单个日志文件存储的大小、以及文件保存的路径和日志的输出格式。</p><h3 id="3-4-定义日志输出级别"><a href="#3-4-定义日志输出级别" class="headerlink" title="3.4 定义日志输出级别"></a>3.4 定义日志输出级别</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.itcodai.course03"</span> <span class="attr">level</span>=<span class="string">"INFO"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了上面那些定义后，最后我们使用 <code>&lt;logger&gt;</code> 来定义一下项目中默认的日志输出级别，这里定义级别为 INFO，然后针对 INFO 级别的日志，使用 <code>&lt;root&gt;</code> 引用上面定义好的控制台日志输出和日志文件的参数。这样 logback.xml 文件中的配置就设置完了。</p><h2 id="4-使用Logger在项目中打印日志"><a href="#4-使用Logger在项目中打印日志" class="headerlink" title="4. 使用Logger在项目中打印日志"></a>4. 使用Logger在项目中打印日志</h2><p>在代码中，我们一般使用 Logger 对象来打印出一些 log 信息，可以指定打印出的日志级别，也支持占位符，很方便。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TestController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/log"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"=====测试日志debug级别打印===="</span>);</span><br><span class="line">        logger.info(<span class="string">"======测试日志info级别打印====="</span>);</span><br><span class="line">        logger.error(<span class="string">"=====测试日志error级别打印===="</span>);</span><br><span class="line">        logger.warn(<span class="string">"======测试日志warn级别打印====="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以使用占位符打印出一些参数信息</span></span><br><span class="line">        String str1 = <span class="string">"blog.itcodai.com"</span>;</span><br><span class="line">        String str2 = <span class="string">"blog.csdn.net/eson_15"</span>;</span><br><span class="line">        logger.info(<span class="string">"======倪升武的个人博客：&#123;&#125;；倪升武的CSDN博客：&#123;&#125;"</span>, str1, str2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动该项目，在浏览器中输入 <code>localhost:8080/test/log</code> 后可以看到控制台的日志记录：</p><blockquote><p>======测试日志info级别打印=====<br>=====测试日志error级别打印====<br>======测试日志warn级别打印=====<br>======倪升武的个人博客：blog.itcodai.com；倪升武的CSDN博客：blog.csdn.net/eson_15</p></blockquote><p>因为 INFO 级别比 DEBUG 级别高，所以 debug 这条没有打印出来，如果将 logback.xml 中的日志级别设置成 DEBUG，那么四条语句都会打印出来，这个大家自己去测试了。同时可以打开 D:\logs\course03\ 目录，里面有刚刚项目启动，以后后面生成的所有日志记录。在项目部署后，我们大部分都是通过查看日志文件来定位问题。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本节课主要对 slf4j 做了一个简单的介绍，并且对 Spring Boot 中如何使用 slf4j 输出日志做了详细的说明，着重分析了 <code>logback.xml</code> 文件中对日志相关信息的配置，包括日志的不同级别。最后针对这些配置，在代码中使用 Logger 打印出一些进行测试。在实际项目中，这些日志都是排查问题的过程中非常重要的资料。<br>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第04课：Spring-Boot中的项目属性配置"><a href="#第04课：Spring-Boot中的项目属性配置" class="headerlink" title="第04课：Spring Boot中的项目属性配置"></a>第04课：Spring Boot中的项目属性配置</h1><p>我们知道，在项目中，很多时候需要用到一些配置的信息，这些信息可能在测试环境和生产环境下会有不同的配置，后面根据实际业务情况有可能还会做修改，针对这种情况，我们不能将这些配置在代码中写死，最好就是写到配置文件中。比如可以把这些信息写到 <code>application.yml</code> 文件中。   </p><h2 id="1-少量配置信息的情形"><a href="#1-少量配置信息的情形" class="headerlink" title="1. 少量配置信息的情形"></a>1. 少量配置信息的情形</h2><p>举个例子，在微服务架构中，最常见的就是某个服务需要调用其他服务来获取其提供的相关信息，那么在该服务的配置文件中需要配置被调用的服务地址，比如在当前服务里，我们需要调用订单微服务获取订单相关的信息，假设 订单服务的端口号是 8002，那我们可以做如下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line"></span><br><span class="line"># 配置微服务的地址</span><br><span class="line">url:</span><br><span class="line">  # 订单微服务的地址</span><br><span class="line">  orderUrl: http://localhost:8002</span><br></pre></td></tr></table></figure><p>然后在业务代码中如何获取到这个配置的订单服务地址呢？我们可以使用 <code>@Value</code> 注解来解决。在对应的类中加上一个属性，在属性上使用 <code>@Value</code> 注解即可获取到配置文件中的配置信息，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ConfigController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;url.orderUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String orderUrl;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"=====获取的订单服务地址为：&#123;&#125;"</span>, orderUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Value</code> 注解上通过 <code>${key}</code> 即可获取配置文件中和 key 对应的 value 值。我们启动一下项目，在浏览器中输入 <code>localhost:8080/test/config</code> 请求服务后，可以看到控制台会打印出订单服务的地址：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;获取的订单服务地址为：http:&#x2F;&#x2F;localhost:8002</span><br></pre></td></tr></table></figure><p>说明我们成功获取到了配置文件中的订单微服务地址，在实际项目中也是这么用的，后面如果因为服务器部署的原因，需要修改某个服务的地址，那么只要在配置文件中修改即可。  </p><h2 id="2-多个配置信息的情形"><a href="#2-多个配置信息的情形" class="headerlink" title="2. 多个配置信息的情形"></a>2. 多个配置信息的情形</h2><p>这里再引申一个问题，随着业务复杂度的增加，一个项目中可能会有越来越多的微服务，某个模块可能需要调用多个微服务获取不同的信息，那么就需要在配置文件中配置多个微服务的地址。可是，在需要调用这些微服务的代码中，如果这样一个个去使用 <code>@Value</code> 注解引入相应的微服务地址的话，太过于繁琐，也不科学。</p><p>所以，在实际项目中，业务繁琐，逻辑复杂的情况下，需要考虑封装一个或多个配置类。举个例子：假如在当前服务中，某个业务需要同时调用订单微服务、用户微服务和购物车微服务，分别获取订单、用户和购物车相关信息，然后对这些信息做一定的逻辑处理。那么在配置文件中，我们需要将这些微服务的地址都配置好：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 配置多个微服务的地址</span><br><span class="line">url:</span><br><span class="line">  # 订单微服务的地址</span><br><span class="line">  orderUrl: http://localhost:8002</span><br><span class="line">  # 用户微服务的地址</span><br><span class="line">  userUrl: http://localhost:8003</span><br><span class="line">  # 购物车微服务的地址</span><br><span class="line">  shoppingUrl: http://localhost:8004</span><br></pre></td></tr></table></figure><p>也许实际业务中，远远不止这三个微服务，甚至十几个都有可能。对于这种情况，我们可以先定义一个 <code>MicroServiceUrl</code> 类来专门保存微服务的 url，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"url"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroServiceUrl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderUrl;</span><br><span class="line">    <span class="keyword">private</span> String userUrl;</span><br><span class="line">    <span class="keyword">private</span> String shoppingUrl;</span><br><span class="line">    <span class="comment">// 省去get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的朋友应该可以看到，使用 <code>@ConfigurationProperties</code> 注解并且使用 prefix 来指定一个前缀，然后该类中的属性名就是配置中去掉前缀后的名字，一一对应即可。即：前缀名 + 属性名就是配置文件中定义的 key。同时，该类上面需要加上 <code>@Component</code> 注解，把该类作为组件放到Spring容器中，让 Spring 去管理，我们使用的时候直接注入即可。</p><p>需要注意的是，使用 <code>@ConfigurationProperties</code> 注解需要导入它的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>OK，到此为止，我们将配置写好了，接下来写个 Controller 来测试一下。此时，不需要在代码中一个个引入这些微服务的 url 了，直接通过 <code>@Resource</code> 注解将刚刚写好配置类注入进来即可使用了，非常方便。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(TestController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MicroServiceUrl microServiceUrl;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"=====获取的订单服务地址为：&#123;&#125;"</span>, microServiceUrl.getOrderUrl());</span><br><span class="line">        LOGGER.info(<span class="string">"=====获取的用户服务地址为：&#123;&#125;"</span>, microServiceUrl.getUserUrl());</span><br><span class="line">        LOGGER.info(<span class="string">"=====获取的购物车服务地址为：&#123;&#125;"</span>, microServiceUrl.getShoppingUrl());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次启动项目，请求一下可以看到，控制台打印出如下信息，说明配置文件生效，同时正确获取配置文件内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;获取的订单服务地址为：http:&#x2F;&#x2F;localhost:8002</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;获取的订单服务地址为：http:&#x2F;&#x2F;localhost:8002</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;获取的用户服务地址为：http:&#x2F;&#x2F;localhost:8003</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;获取的购物车服务地址为：http:&#x2F;&#x2F;localhost:8004</span><br></pre></td></tr></table></figure><h2 id="3-指定项目配置文件"><a href="#3-指定项目配置文件" class="headerlink" title="3. 指定项目配置文件"></a>3. 指定项目配置文件</h2><p>我们知道，在实际项目中，一般有两个环境：开发环境和生产环境。开发环境中的配置和生产环境中的配置往往不同，比如：环境、端口、数据库、相关地址等等。我们不可能在开发环境调试好之后，部署到生产环境后，又要将配置信息全部修改成生产环境上的配置，这样太麻烦，也不科学。</p><p>最好的解决方法就是开发环境和生产环境都有一套对用的配置信息，然后当我们在开发时，指定读取开发环境的配置，当我们将项目部署到服务器上之后，再指定去读取生产环境的配置。</p><p>我们新建两个配置文件： <code>application-dev.yml</code> 和 <code>application-pro.yml</code>，分别用来对开发环境和生产环境进行相关配置。这里为了方便，我们分别设置两个访问端口号，开发环境用 8001，生产环境用 8002.</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 开发环境配置文件</span><br><span class="line">server:</span><br><span class="line">  port: 8001</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 开发环境配置文件</span><br><span class="line">server:</span><br><span class="line">  port: 8002</span><br></pre></td></tr></table></figure><p>然后在 <code>application.yml</code> 文件中指定读取哪个配置文件即可。比如我们在开发环境下，指定读取 <code>applicationn-dev.yml</code> 文件，如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active:</span><br><span class="line">    - dev</span><br></pre></td></tr></table></figure><p>这样就可以在开发的时候，指定读取  <code>application-dev.yml</code> 文件，访问的时候使用 8001 端口，部署到服务器后，只需要将 <code>application.yml</code> 中指定的文件改成 <code>application-pro.yml</code> 即可，然后使用 8002 端口访问，非常方便。</p><h2 id="4-总结-2"><a href="#4-总结-2" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本节课主要讲解了 Spring Boot 中如何在业务代码中读取相关配置，包括单一配置和多个配置项，在微服务中，这种情况非常常见，往往会有很多其他微服务需要调用，所以封装一个配置类来接收这些配置是个很好的处理方式。除此之外，例如数据库相关的连接参数等等，也可以放到一个配置类中，其他遇到类似的场景，都可以这么处理。最后介绍了开发环境和生产环境配置的快速切换方式，省去了项目部署时，诸多配置信息的修改。<br>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第05课：Spring-Boot中的MVC支持"><a href="#第05课：Spring-Boot中的MVC支持" class="headerlink" title="第05课：Spring Boot中的MVC支持"></a>第05课：Spring Boot中的MVC支持</h1><p>Spring Boot 的 MVC 支持主要来介绍实际项目中最常用的几个注解，包括 <code>@RestController</code>、 <code>@RequestMapping</code>、<code>@PathVariable</code>、<code>@RequestParam</code> 以及 <code>@RequestBody</code>。主要介绍这几个注解常用的使用方式和特点。  </p><h2 id="1-RestController"><a href="#1-RestController" class="headerlink" title="1. @RestController"></a>1. @RestController</h2><p><code>@RestController</code> 是 Spring Boot 新增的一个注解，我们看一下该注解都包含了哪些东西。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出， <code>@RestController</code> 注解包含了原来的 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解，使用过 Spring 的朋友对 <code>@Controller</code> 注解已经非常了解了，这里不再赘述， <code>@ResponseBody</code> 注解是将返回的数据结构转换为 Json 格式。所以 <code>@RestController</code> 可以看作是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的结合体，相当于偷个懒，我们使用 <code>@RestController</code> 之后就不用再使用 <code>@Controller</code> 了。但是需要注意一个问题：如果是前后端分离，不用模板渲染的话，比如 Thymeleaf，这种情况下是可以直接使用<code>@RestController</code> 将数据以 json 格式传给前端，前端拿到之后解析；但如果不是前后端分离，需要使用模板来渲染的话，一般 Controller 中都会返回到具体的页面，那么此时就不能使用<code>@RestController</code>了，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"user"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实是需要返回到 user.html 页面的，如果使用 <code>@RestController</code> 的话，会将 user 作为字符串返回的，所以这时候我们需要使用 <code>@Controller</code> 注解。这在下一节 Spring Boot 集成 Thymeleaf 模板引擎中会再说明。</p><h2 id="2-RequestMapping"><a href="#2-RequestMapping" class="headerlink" title="2. @RequestMapping"></a>2. @RequestMapping</h2><p><code>@RequestMapping</code> 是一个用来处理请求地址映射的注解，它可以用于类上，也可以用于方法上。在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上，表示类中的所有响应请求的方法都是以该地址作为父路径；在方法的级别表示进一步指定到处理方法的映射关系。</p><p>该注解有6个属性，一般在项目中比较常用的有三个属性：value、method 和 produces。</p><ul><li>value 属性：指定请求的实际地址，value 可以省略不写</li><li>method 属性：指定请求的类型，主要有 GET、PUT、POST、DELETE，默认为 GET</li><li>produces属性：指定返回内容类型，如 produces = “application/json; charset=UTF-8”</li></ul><p><code>@RequestMapping</code> 注解比较简单，举个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>, produces = <span class="string">"application/json; charset=UTF-8"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/get"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很简单，启动项目在浏览器中输入 <code>localhost:8080/test/get</code> 测试一下即可。</p><p>针对四种不同的请求方式，是有相应注解的，不用每次在 <code>@RequestMapping</code> 注解中加 method 属性来指定，上面的 GET 方式请求可以直接使用 <code>@GetMapping(&quot;/get&quot;)</code> 注解，效果一样。相应地，PUT 方式、POST 方式和 DELETE 方式对应的注解分别为 <code>@PutMapping</code>、<code>@PostMapping</code> 和 <code>DeleteMapping</code>。</p><h2 id="3-PathVariable"><a href="#3-PathVariable" class="headerlink" title="3. @PathVariable"></a>3. @PathVariable</h2><p><code>@PathVariable</code> 注解主要是用来获取 url 参数，Spring Boot 支持 restfull 风格的 url，比如一个 GET 请求携带一个参数 id 过来，我们将 id 作为参数接收，可以使用 <code>@PathVariable</code> 注解。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPathVariable</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"获取到的id为："</span> + id);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意一个问题，如果想要 url 中占位符中的 id 值直接赋值到参数 id 中，需要保证 url 中的参数和方法接收参数一致，否则就无法接收。如果不一致的话，其实也可以解决，需要用 <code>@PathVariable</code> 中的 value 属性来指定对应关系。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user/&#123;idd&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPathVariable</span><span class="params">(@PathVariable(value = <span class="string">"idd"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"获取到的id为："</span> + id);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于访问的 url，占位符的位置可以在任何位置，不一定非要在最后，比如这样也行：<code>/xxx/{id}/user</code>。另外，url 也支持多个占位符，方法参数使用同样数量的参数来接收，原理和一个参数是一样的，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;idd&#125;/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPathVariable</span><span class="params">(@PathVariable(value = <span class="string">"idd"</span>)</span> Integer id, @PathVariable String name) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取到的id为："</span> + id);</span><br><span class="line">        System.out.println(<span class="string">"获取到的name为："</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行项目，在浏览器中请求 <code>localhost:8080/test/user/2/zhangsan</code> 可以看到控制台输出如下信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取到的id为：2</span><br><span class="line">获取到的name为：zhangsan</span><br></pre></td></tr></table></figure><p>所以支持多个参数的接收。同样地，如果 url 中的参数和方法中的参数名称不同的话，也需要使用 value 属性来绑定两个参数。</p><h2 id="4-RequestParam"><a href="#4-RequestParam" class="headerlink" title="4. @RequestParam"></a>4. @RequestParam</h2><p><code>@RequestParam</code> 注解顾名思义，也是获取请求参数的，上面我们介绍了 <code>@PathValiable</code> 注解也是获取请求参数的，那么 <code>@RequestParam</code> 和 <code>@PathVariable</code> 有什么不同呢？主要区别在于： <code>@PathValiable</code> 是从 url 模板中获取参数值， 即这种风格的 url：<code>http://localhost:8080/user/{id}</code> ；而 <code>@RequestParam</code> 是从 request 里面获取参数值，即这种风格的 url：<code>http://localhost:8080/user?id=1</code>  。我们使用该 url 带上参数 id 来测试一下如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(@RequestParam Integer id)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"获取到的id为："</span> + id);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以正常从控制台打印出 id 信息。同样地，url 上面的参数和方法的参数需要一致，如果不一致，也需要使用 value 属性来说明，比如 url 为：<code>http://localhost:8080/user?idd=1</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(@RequestParam(value = <span class="string">"idd"</span>, required = <span class="keyword">false</span>)</span> Integer id) </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"获取到的id为："</span> + id);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 value 属性外，还有个两个属性比较常用：</p><ul><li>required 属性：true 表示该参数必须要传，否则就会报 404 错误，false 表示可有可无。</li><li>defaultValue 属性：默认值，表示如果请求中没有同名参数时的默认值。</li></ul><p>从 url 中可以看出，<code>@RequestParam</code> 注解用于 GET 请求上时，接收拼接在 url 中的参数。除此之外，该注解还可以用于 POST 请求，接收前端表单提交的参数，假如前端通过表单提交 username 和 password 两个参数，那我们可以使用 <code>@RequestParam</code> 来接收，用法和上面一样。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/form1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testForm</span><span class="params">(@RequestParam String username, @RequestParam String password)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取到的username为："</span> + username);</span><br><span class="line">        System.out.println(<span class="string">"获取到的password为："</span> + password);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们使用 postman 来模拟一下表单提交，测试一下接口：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200215043749282.png"  alt="使用postman测试表单提交"></p><p>那么问题来了，如果表单数据很多，我们不可能在后台方法中写上很多参数，每个参数还要 <code>@RequestParam</code> 注解。针对这种情况，我们需要封装一个实体类来接收这些参数，实体中的属性名和表单中的参数名一致即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="comment">// set get</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用实体接收的话，我们不能在前面加 <code>@RequestParam</code> 注解了，直接使用即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/form2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testForm</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取到的username为："</span> + user.getUsername());</span><br><span class="line">        System.out.println(<span class="string">"获取到的password为："</span> + user.getPassword());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用 postman 再次测试一下表单提交，观察一下返回值和控制台打印出的日志即可。在实际项目中，一般都是封装一个实体类来接收表单数据，因为实际项目中表单数据一般都很多。</p><h2 id="5-RequestBody"><a href="#5-RequestBody" class="headerlink" title="5. @RequestBody"></a>5. @RequestBody</h2><p><code>@RequestBody</code> 注解用于接收前端传来的实体，接收参数也是对应的实体，比如前端通过 json 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 <code>@RequestBody</code> 接收会非常方便。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="comment">// set get</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestBody</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"获取到的username为："</span> + user.getUsername());</span><br><span class="line">System.out.println(<span class="string">"获取到的password为："</span> + user.getPassword());</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 postman 工具来测试一下效果，打开 postman，然后输入请求地址和参数，参数我们用 json 来模拟，如下图所有，调用之后返回 success。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200215043853532.png"  alt="使用Postman测试requestBody"></p><p>同时看一下后台控制台输出的日志：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取到的username为：倪升武</span><br><span class="line">获取到的password为：123456</span><br></pre></td></tr></table></figure><p>可以看出，<code>@RequestBody</code> 注解用于 POST 请求上，接收 json 实体参数。它和上面我们介绍的表单提交有点类似，只不过参数的格式不同，一个是 json 实体，一个是表单提交。在实际项目中根据具体场景和需要使用对应的注解即可。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本节课主要讲解了 Spring Boot 中对 MVC 的支持，分析了 <code>@RestController</code>、 <code>@RequestMapping</code>、<code>@PathVariable</code>、 <code>@RequestParam</code> 和 <code>@RequestBody</code> 四个注解的使用方式，由于 <code>@RestController</code> 中集成了 <code>@ResponseBody</code> 所以对返回 json 的注解不再赘述。以上四个注解是使用频率很高的注解，在所有的实际项目中基本都会遇到，要熟练掌握。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第06课：Spring-Boot集成-Swagger2-展现在线接口文档"><a href="#第06课：Spring-Boot集成-Swagger2-展现在线接口文档" class="headerlink" title="第06课：Spring Boot集成 Swagger2 展现在线接口文档"></a>第06课：Spring Boot集成 Swagger2 展现在线接口文档</h1><h2 id="1-Swagger-简介"><a href="#1-Swagger-简介" class="headerlink" title="1. Swagger 简介"></a>1. Swagger 简介</h2><h3 id="1-1-解决的问题"><a href="#1-1-解决的问题" class="headerlink" title="1.1 解决的问题"></a>1.1 解决的问题</h3><p>随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。前端和后端的唯一联系，变成了 API 接口，所以 API 文档变成了前后端开发人员联系的纽带，变得越来越重要。</p><p>那么问题来了，随着代码的不断更新，开发人员在开发新的接口或者更新旧的接口后，由于开发任务的繁重，往往文档很难持续跟着更新，Swagger 就是用来解决该问题的一款重要的工具，对使用接口的人来说，开发人员不需要给他们提供文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。</p><h3 id="1-2-Swagger-官方"><a href="#1-2-Swagger-官方" class="headerlink" title="1.2 Swagger 官方"></a>1.2 Swagger 官方</h3><p>我们打开 <a href="https://swagger.io/" target="_blank" rel="noopener">Swagger 官网</a>，官方对 Swagger 的定义为：</p><blockquote><p>The Best APIs are Built with Swagger Tools </p></blockquote><p>翻译成中文是：“最好的 API 是使用 Swagger 工具构建的”。由此可见，Swagger 官方对其功能和所处的地位非常自信，由于其非常好用，所以官方对其定位也合情合理。如下图所示：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200215043936444.png"  alt="官方对swagger的定位"></p><p>本文主要讲解在 Spring Boot 中如何导入 Swagger2 工具来展现项目中的接口文档。本节课使用的 Swagger 版本为 2.2.2。下面开始进入 Swagger2 之旅。</p><h2 id="2-Swagger2-的-maven-依赖"><a href="#2-Swagger2-的-maven-依赖" class="headerlink" title="2. Swagger2 的 maven 依赖"></a>2. Swagger2 的 maven 依赖</h2><p>使用 Swagger2 工具，必须要导入 maven 依赖，当前官方最高版本是 2.8.0，我尝试了一下，个人感觉页面展示的效果不太好，而且不够紧凑，不利于操作。另外，最新版本并不一定是最稳定版本，当前我们实际项目中使用的是 2.2.2 版本，该版本稳定，界面友好，所以本节课主要围绕着 2.2.2 版本来展开，依赖如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-Swagger2-的配置"><a href="#3-Swagger2-的配置" class="headerlink" title="3. Swagger2 的配置"></a>3. Swagger2 的配置</h2><p>使用 Swagger2 需要进行配置，Spring Boot 中对 Swagger2 的配置非常方便，新建一个配置类，Swagger2 的配置类上除了添加必要的 <code>@Configuration</code> 注解外，还需要添加 <code>@EnableSwagger2</code> 注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                <span class="comment">// 指定构建api文档的详细信息的方法：apiInfo()</span></span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.itcodai.course06.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建api文档的详细信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                <span class="comment">// 设置页面标题</span></span><br><span class="line">                .title(<span class="string">"Spring Boot集成Swagger2接口总览"</span>)</span><br><span class="line">                <span class="comment">// 设置接口描述</span></span><br><span class="line">                .description(<span class="string">"跟武哥一起学Spring Boot第06课"</span>)</span><br><span class="line">                <span class="comment">// 设置联系方式</span></span><br><span class="line">                .contact(<span class="string">"倪升武，"</span> + <span class="string">"CSDN：http://blog.csdn.net/eson_15"</span>)</span><br><span class="line">                <span class="comment">// 设置版本</span></span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                <span class="comment">// 构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该配置类中，已经使用注释详细解释了每个方法的作用了，在此不再赘述。到此为止，我们已经配置好了 Swagger2 了。现在我们可以测试一下配置有没有生效，启动项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code>，即可看到 swagger2 的接口页面，如下图所示，说明Swagger2 集成成功。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200215044013383.png"  alt="swagger2页面"></p><p>结合该图，对照上面的 Swagger2 配置文件中的配置，可以很明确的知道配置类中每个方法的作用。这样就很容易理解和掌握 Swagger2 中的配置了，也可以看出，其实 Swagger2 配置很简单。</p><p>【友情提示】可能有很多朋友在配置 Swagger 的时候会遇到下面的情况，而且还关不掉的，这是因为浏览器缓存引起的，清空一下浏览器缓存即可解决问题。</p><p><img src="/" class="lazyload" data-src="http://p99jlm9k5.bkt.clouddn.com/blog/images/1/error.png"  alt="错误页面-倪升武的博客-图2"></p><h2 id="4-Swagger2-的使用"><a href="#4-Swagger2-的使用" class="headerlink" title="4. Swagger2 的使用"></a>4. Swagger2 的使用</h2><p>上面我们已经配置好了 Swagger2，并且也启动测试了一下，功能正常，下面我们开始使用 Swagger2，主要来介绍 Swagger2 中的几个常用的注解，分别在实体类上、 Controller 类上以及 Controller 中的方法上，最后我们看一下 Swagger2 是如何在页面上呈现在线接口文档的，并且结合 Controller 中的方法在接口中测试一下数据。</p><h3 id="4-1-实体类注解"><a href="#4-1-实体类注解" class="headerlink" title="4.1 实体类注解"></a>4.1 实体类注解</h3><p>本节我们建一个 User 实体类，主要介绍一下 Swagger2 中的 <code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 注解，同时为后面的测试做准备。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"用户实体类"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户唯一标识"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户姓名"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"用户密码"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释下 <code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 注解：</p><blockquote><p><code>@ApiModel</code> 注解用于实体类，表示对类进行说明，用于参数用实体类接收。<br><code>@ApiModelProperty</code> 注解用于类中属性，表示对 model 属性的说明或者数据操作更改。</p></blockquote><p>该注解在在线 API 文档中的具体效果在下文说明。</p><h3 id="4-2-Controller-类中相关注解"><a href="#4-2-Controller-类中相关注解" class="headerlink" title="4.2 Controller 类中相关注解"></a>4.2 Controller 类中相关注解</h3><p>我们写一个 TestController，再写几个接口，然后学习一下 Controller 中和 Swagger2 相关的注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itcodai.course06.entiy.JsonResult;</span><br><span class="line"><span class="keyword">import</span> com.itcodai.course06.entiy.User;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/swagger"</span>)</span><br><span class="line"><span class="meta">@Api</span>(value = <span class="string">"Swagger2 在线接口文档"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"根据用户唯一标识获取用户信息"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;User&gt; <span class="title">getUserInfo</span><span class="params">(@PathVariable @ApiParam(value = <span class="string">"用户唯一标识"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟数据库中根据id获取User信息</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(id, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来学习一下 <code>@Api</code> 、 <code>@ApiOperation</code> 和 <code>@ApiParam</code> 注解。</p><blockquote><p><code>@Api</code> 注解用于类上，表示标识这个类是 swagger 的资源。<br><code>@ApiOperation</code> 注解用于方法，表示一个 http 请求的操作。<br><code>@ApiParam</code> 注解用于参数上，用来标明参数信息。</p></blockquote><p>这里返回的是 JsonResult，是第02课中学习返回 json 数据时封装的实体。以上是 Swagger 中最常用的 5 个注解，接下来运行一下项目工程，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 看一下 Swagger 页面的接口状态。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200215044156305.png"  alt="swagger接口展示"></p><p>可以看出，Swagger 页面对该接口的信息展示的非常全面，每个注解的作用以及展示的地方在上图中已经标明，通过页面即可知道该接口的所有信息，那么我们直接在线测试一下该接口返回的信息，输入id为1，看一下返回数据：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200215044226292.png"  alt="返回数据测试"></p><p>可以看出，直接在页面返回了 json 格式的数据，开发人员可以直接使用该在线接口来测试数据的正确与否，非常方便。上面是对于单个参数的输入，如果输入参数为某个对象这种情况，Swagger 是什么样子呢？我们再写一个接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"添加用户信息"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;Void&gt; <span class="title">insertUser</span><span class="params">(@RequestBody @ApiParam(value = <span class="string">"用户信息"</span>)</span> User user) </span>&#123;</span><br><span class="line">        <span class="comment">// 处理添加逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult&lt;&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重启项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 看一下效果：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200215044256579.png"  alt="swagger接口展示"></p><h2 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>OK，本节课详细分析了 Swagger 的优点，以及 Spring Boot 如何集成 Swagger2，包括配置，相关注解的讲解，涉及到了实体类和接口类，以及如何使用。最后通过页面测试，体验了 Swagger 的强大之处，基本上是每个项目组中必备的工具之一，所以要掌握该工具的使用，也不难。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第07课：Spring-Boot集成Thymeleaf模板引擎"><a href="#第07课：Spring-Boot集成Thymeleaf模板引擎" class="headerlink" title="第07课：Spring Boot集成Thymeleaf模板引擎"></a>第07课：Spring Boot集成Thymeleaf模板引擎</h1><h2 id="1-Thymeleaf-介绍"><a href="#1-Thymeleaf-介绍" class="headerlink" title="1. Thymeleaf 介绍"></a>1. Thymeleaf 介绍</h2><blockquote><p>Thymeleaf 是适用于 Web 和独立环境的现代服务器端 Java 模板引擎。<br>Thymeleaf 的主要目标是为您的开发工作流程带来优雅的自然模板 - 可以在浏览器中正确显示的HTML，也可以用作静态原型，从而在开发团队中实现更强大的协作。  </p></blockquote><p>以上翻译自 Thymeleaf 官方网站。传统的 JSP+JSTL 组合是已经过去了，Thymeleaf 是现代服务端的模板引擎，与传统的 JSP 不同，Thymeleaf 可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。   </p><p>什么意思呢？就是说在本地环境或者有网络的环境下，Thymeleaf 均可运行。由于 thymeleaf 支持 html 原型，也支持在 html 标签里增加额外的属性来达到 “模板+数据” 的展示方式，所以美工可以直接在浏览器中查看页面效果，当服务启动后，也可以让后台开发人员查看带数据的动态页面效果。比如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui right aligned basic segment"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ui orange basic label"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;blog.flag&#125;"</span>&gt;</span>静态原创信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"ui center aligned header"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;blog.title&#125;"</span>&gt;</span>这是静态标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类似与上面这样，在静态页面时，会展示静态信息，当服务启动后，动态获取数据库中的数据后，就可以展示动态数据，<code>th:text</code> 标签是用来动态替换文本的，这会在下文说明。该例子说明浏览器解释 html 时会忽略 html 中未定义的标签属性（比如 <code>th:text</code>），所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示数据。 </p><h2 id="2-依赖导入"><a href="#2-依赖导入" class="headerlink" title="2. 依赖导入"></a>2. 依赖导入</h2><p>在 Spring Boot 中使用 thymeleaf 模板需要引入依赖，可以在创建项目工程时勾选 Thymeleaf，也可以创建之后再手动导入，如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，在 html 页面上如果要使用 thymeleaf 模板，需要在页面标签中引入：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-Thymeleaf相关配置"><a href="#3-Thymeleaf相关配置" class="headerlink" title="3. Thymeleaf相关配置"></a>3. Thymeleaf相关配置</h2><p>因为 Thymeleaf 中已经有默认的配置了，我们不需要再对其做过多的配置，有一个需要注意一下，Thymeleaf 默认是开启页面缓存的，所以在开发的时候，需要关闭这个页面缓存，配置如下。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span> <span class="comment">#关闭缓存</span></span><br></pre></td></tr></table></figure><p>否则会有缓存，导致页面没法及时看到更新后的效果。 比如你修改了一个文件，已经 update 到 tomcat 了，但刷新页面还是之前的页面，就是因为缓存引起的。</p><h2 id="4-Thymeleaf-的使用"><a href="#4-Thymeleaf-的使用" class="headerlink" title="4. Thymeleaf 的使用"></a>4. Thymeleaf 的使用</h2><h3 id="4-1-访问静态页面"><a href="#4-1-访问静态页面" class="headerlink" title="4.1 访问静态页面"></a>4.1 访问静态页面</h3><p>这个和 Thymeleaf 没啥关系，应该说是通用的，我把它一并写到这里的原因是一般我们做网站的时候，都会做一个 404 页面和 500 页面，为了出错时给用户一个友好的展示，而不至于一堆异常信息抛出来。Spring Boot 中会自动识别模板目录（templates/）下的 404.html 和 500.html 文件。我们在 templates/ 目录下新建一个 error 文件夹，专门放置错误的 html 页面，然后分别打印些信息。以 404.html 为例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    这是404页面</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们再写一个 controller 来测试一下 404 和 500 页面：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/thymeleaf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test404"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test404</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test500"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test500</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当我们在浏览器中输入 <code>localhost:8080/thymeleaf/test400</code> 时，故意输入错误，找不到对应的方法，就会跳转到 404.html 显示。<br>当我们在浏览器中输入 <code>localhost:8088/thymeleaf/test505</code> 时，会抛出异常，然后会自动跳转到 500.html 显示。</p></blockquote><p>【注】这里有个问题需要注意一下，前面的课程中我们说了微服务中会走向前后端分离，我们在 Controller 层上都是使用的 <code>@RestController</code> 注解，自动会把返回的数据转成 json 格式。但是在使用模板引擎时，Controller 层就不能用 <code>@RestController</code> 注解了，因为在使用 thymeleaf 模板时，返回的是视图文件名，比如上面的 Controller 中是返回到 index.html 页面，如果使用 <code>@RestController</code> 的话，会把 index 当作 String 解析了，直接返回到页面了，而不是去找 index.html 页面，大家可以试一下。所以在使用模板时要用 <code>@Controller</code> 注解。</p><h3 id="4-2-Thymeleaf-中处理对象"><a href="#4-2-Thymeleaf-中处理对象" class="headerlink" title="4.2 Thymeleaf 中处理对象"></a>4.2 Thymeleaf 中处理对象</h3><p>我们来看一下 thymeleaf 模板中如何处理对象信息，假如我们在做个人博客的时候，需要给前端传博主相关信息来展示，那么我们会封装成一个博主对象，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blogger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pass;</span><br><span class="line"><span class="comment">// 省去set和get</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在controller层中初始化一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getBlogger"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBlogger</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">Blogger blogger = <span class="keyword">new</span> Blogger(<span class="number">1L</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">model.addAttribute(<span class="string">"blogger"</span>, blogger);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"blogger"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先初始化一个 Blogger 对象，然后将该对象放到 Model 中，然后返回到 blogger.html 页面去渲染。接下来我们再写一个 blogger.html 来渲染 blogger 信息：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>博主信息<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">th:object</span>=<span class="string">"$&#123;blogger&#125;"</span> &gt;</span></span><br><span class="line">    用户编号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;blogger.id&#125;"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;blogger.getName()&#125;"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    登陆密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">th:value</span>=<span class="string">"*&#123;pass&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出，在 thymeleaf 模板中，使用 <code>th:object=&quot;${}&quot;</code> 来获取对象信息，然后在表单里面可以有三种方式来获取对象属性。如下：</p><blockquote><p>使用 <code>th:value=&quot;*{属性名}&quot;</code><br>使用 <code>th:value=&quot;${对象.属性名}&quot;</code>，对象指的是上面使用 <code>th:object</code> 获取的对象<br>使用 <code>th:value=&quot;${对象.get方法}&quot;</code>，对象指的是上面使用 <code>th:object</code> 获取的对象</p></blockquote><p>可以看出，在 Thymeleaf 中可以像写 java 一样写代码，很方便。我们在浏览器中输入 <code>localhost:8080/thymeleaf/getBlogger</code> 来测试一下数据：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200215044353803.jpg"  alt="thymeleaf中处理对象"></p><h3 id="4-3-Thymeleaf-中处理-List"><a href="#4-3-Thymeleaf-中处理-List" class="headerlink" title="4.3 Thymeleaf 中处理 List"></a>4.3 Thymeleaf 中处理 List</h3><p>处理 List 的话，和处理上面介绍的对象差不多，但是需要在 thymeleaf 中进行遍历。我们先在 Controller 中模拟一个 List。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getList"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getList</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    Blogger blogger1 = <span class="keyword">new</span> Blogger(<span class="number">1L</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    Blogger blogger2 = <span class="keyword">new</span> Blogger(<span class="number">2L</span>, <span class="string">"达人课"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    List&lt;Blogger&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(blogger1);</span><br><span class="line">    list.add(blogger2);</span><br><span class="line">    model.addAttribute(<span class="string">"list"</span>, list);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们写一个 list.html 来获取该 list 信息，然后在 list.html 中遍历这个list。如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>博主信息<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">th:each</span>=<span class="string">"blogger : $&#123;list&#125;"</span> &gt;</span></span><br><span class="line">    用户编号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;blogger.id&#125;"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;blogger.name&#125;"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    登录密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;blogger.getPass()&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出，其实和处理单个对象信息差不多，Thymeleaf 使用 <code>th:each</code> 进行遍历，<code>${}</code> 取 model 中传过来的参数，然后自定义 list 中取出来的每个对象，这里定义为 blogger。表单里面可以直接使用 <code>${对象.属性名}</code> 来获取 list 中对象的属性值，也可以使用 <code>${对象.get方法}</code> 来获取，这点和上面处理对象信息是一样的，但是不能使用 <code>*{属性名}</code> 来获取对象中的属性，thymeleaf 模板获取不到。    </p><h3 id="4-4-其他常用-thymeleaf-操作"><a href="#4-4-其他常用-thymeleaf-操作" class="headerlink" title="4.4 其他常用 thymeleaf 操作"></a>4.4 其他常用 thymeleaf 操作</h3><p>我们来总结一下 thymeleaf 中的一些常用的标签操作，如下：</p><table><thead><tr><th>标签</th><th>功能</th><th>例子</th></tr></thead><tbody><tr><td><code>th:value</code></td><td>给属性赋值</td><td><code>&lt;input th:value=&quot;${blog.name}&quot; /&gt;</code></td></tr><tr><td><code>th:style</code></td><td>设置样式</td><td><code>th:style=&quot;&#39;display:&#39;+@{(${sitrue}?&#39;none&#39;:&#39;inline-block&#39;)} + &#39;&#39;&quot;</code></td></tr><tr><td><code>th:onclick</code></td><td>点击事件</td><td><code>th:onclick=&quot;&#39;getInfo()&#39;&quot;</code></td></tr><tr><td><code>th:if</code></td><td>条件判断</td><td><code>&lt;a th:if=&quot;${userId == collect.userId}&quot; &gt;</code></td></tr><tr><td><code>th:href</code></td><td>超链接</td><td><code>&lt;a th:href=&quot;@{/blogger/login}&quot;&gt;Login&lt;/a&gt; /&gt;</code></td></tr><tr><td><code>th:unless</code></td><td>条件判断和<code>th:if</code>相反</td><td><code>&lt;a th:href=&quot;@{/blogger/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt;</code></td></tr><tr><td><code>th:switch</code></td><td>配合<code>th:case</code></td><td><code>&lt;div th:switch=&quot;${user.role}&quot;&gt;</code></td></tr><tr><td><code>th:case</code></td><td>配合<code>th:switch</code></td><td><code>&lt;p th:case=&quot;&#39;admin&#39;&quot;&gt;administator&lt;/p&gt;</code></td></tr><tr><td><code>th:src</code></td><td>地址引入</td><td><code>&lt;img alt=&quot;csdn logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt;</code></td></tr><tr><td><code>th:action</code></td><td>表单提交的地址</td><td><code>&lt;form th:action=&quot;@{/blogger/update}&quot;&gt;</code></td></tr></tbody></table><p>Thymeleaf 还有很多其他用法，这里就不总结了，具体的可以参考Thymeleaf的<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html" target="_blank" rel="noopener">官方文档（v3.0）</a>。主要要学会如何在 Spring Boot 中去使用 thymeleaf，遇到对应的标签或者方法，查阅官方文档即可。</p><h2 id="5-总结-2"><a href="#5-总结-2" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Thymeleaf 在 Spring Boot 中使用非常广泛，本节课主要分析了 thymeleaf 的优点，以及如何在 Spring Boot 中集成并使用 thymeleaf 模板，包括依赖、配置，相关数据的获取、以及一些注意事项等等。最后列举了一些 thymeleaf 中常用的标签，在实际项目中多使用，多查阅就能熟练掌握，thymeleaf 中的一些标签或者方法不用死记硬背，用到什么去查阅什么，关键是要会在 Spring Boot 中集成，用的多了就熟能生巧。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第08课：Spring-Boot中的全局异常处理"><a href="#第08课：Spring-Boot中的全局异常处理" class="headerlink" title="第08课：Spring Boot中的全局异常处理"></a>第08课：Spring Boot中的全局异常处理</h1><p>在项目开发过程中，不管是对底层数据库的操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。如果对每个过程都单独作异常处理，那系统的代码耦合度会变得很高，此外，开发工作量也会加大而且不好统一，这也增加了代码的维护成本。<br>针对这种实际情况，我们需要将所有类型的异常处理从各处理过程解耦出来，这样既保证了相关处理过程的功能单一，也实现了异常信息的统一处理和维护。同时，我们也不希望直接把异常抛给用户，应该对异常进行处理，对错误信息进行封装，然后返回一个友好的信息给用户。这节主要总结一下项目中如何使用 Spring Boot 如何拦截并处理全局的异常。</p><h2 id="1-定义返回的统一-json-结构"><a href="#1-定义返回的统一-json-结构" class="headerlink" title="1. 定义返回的统一 json 结构"></a>1. 定义返回的统一 json 结构</h2><p>前端或者其他服务请求本服务的接口时，该接口需要返回对应的 json 数据，一般该服务只需要返回请求着需要的参数即可，但是在实际项目中，我们需要封装更多的信息，比如状态码 code、相关信息 msg 等等，这一方面是在项目中可以有个统一的返回结构，整个项目组都适用，另一方面是方便结合全局异常处理信息，因为异常处理信息中一般我们需要把状态码和异常内容反馈给调用方。<br>这个统一的 json 结构这可以参考<a href="https://gitbook.cn/gitchat/column/5b3c9f35a3442272491a176a" target="_blank" rel="noopener">第02课：Spring Boot 返回 JSON 数据及数据封装</a>中封装的统一 json 结构，本节内容我们简化一下，只保留状态码 code 和异常信息 msg即可。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonResult</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"200"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">"操作成功"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-处理系统异常"><a href="#2-处理系统异常" class="headerlink" title="2. 处理系统异常"></a>2. 处理系统异常</h2><p>新建一个 GlobalExceptionHandler 全局异常处理类，然后加上 <code>@ControllerAdvice</code> 注解即可拦截项目中抛出的异常，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">// 打印log</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们点开 <code>@ControllerAdvice</code> 注解可以看到，<code>@ControllerAdvice</code> 注解包含了 <code>@Component</code> 注解，说明在 Spring Boot 启动时，也会把该类作为组件交给 Spring 来管理。除此之外，该注解还有个 <code>basePackages</code> 属性，该属性是用来拦截哪个包中的异常信息，一般我们不指定这个属性，我们拦截项目工程中的所有异常。<code>@ResponseBody</code> 注解是为了异常处理完之后给调用方输出一个 json 格式的封装数据。<br>在项目中如何使用呢？Spring Boot 中很简单，在方法上通过 <code>@ExceptionHandler</code> 注解来指定具体的异常，然后在方法中处理该异常信息，最后将结果通过统一的 json 结构体返回给调用者。下面我们举几个例子来说明如何来使用。</p><h3 id="2-1-处理参数缺失异常"><a href="#2-1-处理参数缺失异常" class="headerlink" title="2.1 处理参数缺失异常"></a>2.1 处理参数缺失异常</h3><p>在前后端分离的架构中，前端请求后台的接口都是通过 rest 风格来调用，有时候，比如 POST 请求 需要携带一些参数，但是往往有时候参数会漏掉。另外，在微服务架构中，涉及到多个微服务之间的接口调用时，也可能出现这种情况，此时我们需要定义一个处理参数缺失异常的方法，来给前端或者调用方提示一个友好信息。  </p><p>参数缺失的时候，会抛出 <code>HttpMessageNotReadableException</code>，我们可以拦截该异常，做一个友好处理，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 缺少请求参数异常</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> ex HttpMessageNotReadableException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(MissingServletRequestParameterException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.BAD_REQUEST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleHttpMessageNotReadableException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MissingServletRequestParameterException ex)</span> </span>&#123;</span><br><span class="line">    logger.error(<span class="string">"缺少请求参数，&#123;&#125;"</span>, ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="string">"400"</span>, <span class="string">"缺少必要的请求参数"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来写个简单的 Controller 测试一下该异常，通过 POST 请求方式接收两个参数：姓名和密码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/exception"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExceptionController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">test</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name,</span></span><br><span class="line"><span class="function">                           @<span class="title">RequestParam</span><span class="params">(<span class="string">"pass"</span>)</span> String pass) </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"name：&#123;&#125;"</span>, name);</span><br><span class="line">        logger.info(<span class="string">"pass：&#123;&#125;"</span>, pass);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 Postman 来调用一下该接口，调用的时候，只传姓名，不传密码，就会抛缺少参数异常，该异常被捕获之后，就会进入我们写好的逻辑，给调用方返回一个友好信息，如下：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020021504443480.png"  alt="缺失参数异常"></p><h3 id="2-2-处理空指针异常"><a href="#2-2-处理空指针异常" class="headerlink" title="2.2 处理空指针异常"></a>2.2 处理空指针异常</h3><p>空指针异常是开发中司空见惯的东西了，一般发生的地方有哪些呢？<br>先来聊一聊一些注意的地方，比如在微服务中，经常会调用其他服务获取数据，这个数据主要是 json 格式的，但是在解析 json 的过程中，可能会有空出现，所以我们在获取某个 jsonObject 时，再通过该 jsonObject 去获取相关信息时，应该要先做非空判断。<br>还有一个很常见的地方就是从数据库中查询的数据，不管是查询一条记录封装在某个对象中，还是查询多条记录封装在一个 List 中，我们接下来都要去处理数据，那么就有可能出现空指针异常，因为谁也不能保证从数据库中查出来的东西就一定不为空，所以在使用数据时一定要先做非空判断。<br>对空指针异常的处理很简单，和上面的逻辑一样，将异常信息换掉即可。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空指针异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex NullPointerException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(NullPointerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleTypeMismatchException</span><span class="params">(NullPointerException ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"空指针异常，&#123;&#125;"</span>, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="string">"500"</span>, <span class="string">"空指针异常了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个我就不测试了，代码中 ExceptionController 有个 <code>testNullPointException</code> 方法，模拟了一个空指针异常，我们在浏览器中请求一下对应的 url 即可看到返回的信息：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="string">"500"</span>,<span class="attr">"msg"</span>:<span class="string">"空指针异常了"</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-一劳永逸？"><a href="#2-3-一劳永逸？" class="headerlink" title="2.3 一劳永逸？"></a>2.3 一劳永逸？</h3><p>当然了，异常很多，比如还有 RuntimeException，数据库还有一些查询或者操作异常等等。由于 Exception 异常是父类，所有异常都会继承该异常，所以我们可以直接拦截 Exception 异常，一劳永逸：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统异常 预期以外异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleUnexpectedServer</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"系统异常："</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="string">"500"</span>, <span class="string">"系统发生异常，请联系管理员"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是项目中，我们一般都会比较详细的去拦截一些常见异常，拦截 Exception 虽然可以一劳永逸，但是不利于我们去排查或者定位问题。实际项目中，可以把拦截 Exception 异常写在 GlobalExceptionHandler 最下面，如果都没有找到，最后再拦截一下 Exception 异常，保证输出信息友好。</p><h2 id="3-拦截自定义异常"><a href="#3-拦截自定义异常" class="headerlink" title="3. 拦截自定义异常"></a>3. 拦截自定义异常</h2><p>在实际项目中，除了拦截一些系统异常外，在某些业务上，我们需要自定义一些业务异常，比如在微服务中，服务之间的相互调用很平凡，很常见。要处理一个服务的调用时，那么可能会调用失败或者调用超时等等，此时我们需要自定义一个异常，当调用失败时抛出该异常，给 GlobalExceptionHandler 去捕获。</p><h3 id="3-1-定义异常信息"><a href="#3-1-定义异常信息" class="headerlink" title="3.1 定义异常信息"></a>3.1 定义异常信息</h3><p>由于在业务中，有很多异常，针对不同的业务，可能给出的提示信息不同，所以为了方便项目异常信息管理，我们一般会定义一个异常信息枚举类。比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务异常提示信息枚举类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> BusinessMsgEnum &#123;</span><br><span class="line">    <span class="comment">/** 参数异常 */</span></span><br><span class="line">    PARMETER_EXCEPTION(<span class="string">"102"</span>, <span class="string">"参数异常!"</span>),</span><br><span class="line">    <span class="comment">/** 等待超时 */</span></span><br><span class="line">    SERVICE_TIME_OUT(<span class="string">"103"</span>, <span class="string">"服务调用超时！"</span>),</span><br><span class="line">    <span class="comment">/** 参数过大 */</span></span><br><span class="line">    PARMETER_BIG_EXCEPTION(<span class="string">"102"</span>, <span class="string">"输入的图片数量不能超过50张!"</span>),</span><br><span class="line">    <span class="comment">/** 500 : 一劳永逸的提示也可以在这定义 */</span></span><br><span class="line">    UNEXPECTED_EXCEPTION(<span class="string">"500"</span>, <span class="string">"系统发生异常，请联系管理员！"</span>);</span><br><span class="line">    <span class="comment">// 还可以定义更多的业务异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BusinessMsgEnum</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// set get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-拦截自定义异常"><a href="#3-2-拦截自定义异常" class="headerlink" title="3.2 拦截自定义异常"></a>3.2 拦截自定义异常</h3><p>然后我们可以定义一个业务异常，当出现业务异常时，我们就抛这个自定义的业务异常即可。比如我们定义一个 BusinessErrorException 异常，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义业务异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessErrorException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7480022450501760611L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常提示信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessErrorException</span><span class="params">(BusinessMsgEnum businessMsgEnum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = businessMsgEnum.code();</span><br><span class="line">        <span class="keyword">this</span>.message = businessMsgEnum.msg();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// get set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中，传入我们上面自定义的异常枚举类，所以在项目中，如果有新的异常信息需要添加，我们直接在枚举类中添加即可，很方便，做到统一维护，然后再拦截该异常时获取即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截业务异常，返回业务异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BusinessErrorException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleBusinessError</span><span class="params">(BusinessErrorException ex)</span> </span>&#123;</span><br><span class="line">        String code = ex.getCode();</span><br><span class="line">        String message = ex.getMessage();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(code, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在业务代码中，我们可以直接模拟一下抛出业务异常，测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/exception"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExceptionController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/business"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">testException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessErrorException(BusinessMsgEnum.UNEXPECTED_EXCEPTION);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下项目，测试一下，返回 json 如下，说明我们自定义的业务异常捕获成功：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"code"</span>:<span class="string">"500"</span>,<span class="attr">"msg"</span>:<span class="string">"系统发生异常，请联系管理员！"</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结-3"><a href="#4-总结-3" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本节课程主要讲解了Spring Boot 的全局异常处理，包括异常信息的封装、异常信息的捕获和处理，以及在实际项目中，我们用到的自定义异常枚举类和业务异常的捕获与处理，在项目中运用的非常广泛，基本上每个项目中都需要做全局异常处理。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第09课：Spring-Boot中的切面AOP处理"><a href="#第09课：Spring-Boot中的切面AOP处理" class="headerlink" title="第09课：Spring Boot中的切面AOP处理"></a>第09课：Spring Boot中的切面AOP处理</h1><h2 id="1-什么是AOP"><a href="#1-什么是AOP" class="headerlink" title="1. 什么是AOP"></a>1. 什么是AOP</h2><p>AOP：Aspect Oriented Programming 的缩写，意为：面向切面编程。面向切面编程的目标就是分离关注点。什么是关注点呢？就是关注点，就是你要做的事情。假如你是一位公子哥，没啥人生目标，每天衣来伸手，饭来张口，整天只知道一件事：玩（这就是你的关注点，你只要做这一件事）！但是有个问题，你在玩之前，你还需要起床、穿衣服、穿鞋子、叠被子、做早饭等等等等，但是这些事情你不想关注，也不用关注，你只想想玩，那么怎么办呢？  </p><p>对！这些事情通通交给下人去干。你有一个专门的仆人 A 帮你穿衣服，仆人 B 帮你穿鞋子，仆人 C 帮你叠好被子，仆人 D 帮你做饭，然后你就开始吃饭、去玩（这就是你一天的正事），你干完你的正事之后，回来，然后一系列仆人又开始帮你干这个干那个，然后一天就结束了！  </p><p>这就是 AOP。AOP 的好处就是你只需要干你的正事，其它事情别人帮你干。也许有一天，你想裸奔，不想穿衣服，那么你把仆人 A 解雇就是了！也许有一天，出门之前你还想带点钱，那么你再雇一个仆人 E 专门帮你干取钱的活！这就是AOP。每个人各司其职，灵活组合，达到一种可配置的、可插拔的程序结构。</p><h2 id="2-Spring-Boot-中的-AOP-处理"><a href="#2-Spring-Boot-中的-AOP-处理" class="headerlink" title="2. Spring Boot 中的 AOP 处理"></a>2. Spring Boot 中的 AOP 处理</h2><h3 id="2-1-AOP-依赖"><a href="#2-1-AOP-依赖" class="headerlink" title="2.1 AOP 依赖"></a>2.1 AOP 依赖</h3><p>使用AOP，首先需要引入AOP的依赖。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-实现-AOP-切面"><a href="#2-2-实现-AOP-切面" class="headerlink" title="2.2 实现 AOP 切面"></a>2.2 实现 AOP 切面</h3><p>Spring Boot 中使用 AOP 非常简单，假如我们要在项目中打印一些 log，在引入了上面的依赖之后，我们新建一个类 LogAspectHandler，用来定义切面和处理方法。只要在类上加个<code>@Aspect</code>注解即可。<code>@Aspect</code> 注解用来描述一个切面类，定义切面类的时候需要打上这个注解。<code>@Component</code> 注解让该类交给 Spring 来管理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要介绍几个常用的注解及使用：</p><blockquote><p>1.@Pointcut：定义一个切面，即上面所描述的关注的某件事入口。<br>2.@Before：在做某件事之前做的事。<br>3.@After：在做某件事之后做的事。<br>4.@AfterReturning：在做某件事之后，对其返回值做增强处理。<br>5.@AfterThrowing：在做某件事抛出异常时，处理。</p></blockquote><h4 id="2-2-1-Pointcut-注解"><a href="#2-2-1-Pointcut-注解" class="headerlink" title="2.2.1 @Pointcut 注解"></a>2.2.1 @Pointcut 注解</h4><p><code>@Pointcut</code> 注解：用来定义一个切面（切入点），即上文中所关注的某件事情的入口。切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个切面，拦截com.itcodai.course09.controller包和子包下的所有方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.itcodai.course09.controller..*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Pointcut</code> 注解指定一个切面，定义需要拦截的东西，这里介绍两个常用的表达式：一个是使用 <code>execution()</code>，另一个是使用 <code>annotation()</code>。<br>以 <code>execution(* com.itcodai.course09.controller..*.*(..)))</code> 表达式为例，语法如下：</p><blockquote><p><code>execution()</code> 为表达式主体<br>第一个 <code>*</code> 号的位置：表示返回值类型，<code>*</code> 表示所有类型<br>包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，<code>com.itcodai.course09.controller</code> 包、子包下所有类的方法<br>第二个 <code>*</code> 号的位置：表示类名，<code>*</code> 表示所有类<br><code>*(..)</code> ：这个星号表示方法名，<code>*</code> 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数</p></blockquote><p><code>annotation()</code> 方式是针对某个注解来定义切面，比如我们对具有<code>@GetMapping</code>注解的方法做切面，可以如下定义切面：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(org.springframework.web.bind.annotation.GetMapping)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotationCut</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>然后使用该切面的话，就会切入注解是 <code>@GetMapping</code> 的方法。因为在实际项目中，可能对于不同的注解有不同的逻辑处理，比如 <code>@GetMapping</code>、<code>@PostMapping</code>、<code>@DeleteMapping</code> 等。所以这种按照注解的切入方式在实际项目中也很常用。</p><h4 id="2-2-2-Before-注解"><a href="#2-2-2-Before-注解" class="headerlink" title="2.2.2 @Before 注解"></a>2.2.2 @Before 注解</h4><p><code>@Before</code> 注解指定的方法在切面切入目标方法之前执行，可以做一些 log 处理，也可以做一些信息的统计，比如获取用户的请求 url 以及用户的 ip 地址等等，这个在做个人站点的时候都能用得到，都是常用的方法。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在上面定义的切面方法之前执行该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint jointPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"====doBefore方法进入了===="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取签名</span></span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        <span class="comment">// 获取切入的包名</span></span><br><span class="line">        String declaringTypeName = signature.getDeclaringTypeName();</span><br><span class="line">        <span class="comment">// 获取即将执行的方法名</span></span><br><span class="line">        String funcName = signature.getName();</span><br><span class="line">        logger.info(<span class="string">"即将执行方法为: &#123;&#125;，属于&#123;&#125;包"</span>, funcName, declaringTypeName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 也可以用来记录一些信息，比如获取请求的url和ip</span></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        <span class="comment">// 获取请求url</span></span><br><span class="line">        String url = request.getRequestURL().toString();</span><br><span class="line">        <span class="comment">// 获取请求ip</span></span><br><span class="line">        String ip = request.getRemoteAddr();</span><br><span class="line">        logger.info(<span class="string">"用户请求的url为：&#123;&#125;，ip地址为：&#123;&#125;"</span>, url, ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JointPoint 对象很有用，可以用它来获取一个签名，然后利用签名可以获取请求的包名、方法名，包括参数（通过 <code>joinPoint.getArgs()</code> 获取）等等。</p><h4 id="2-2-3-After-注解"><a href="#2-2-3-After-注解" class="headerlink" title="2.2.3 @After 注解"></a>2.2.3 @After 注解</h4><p><code>@After</code> 注解和 <code>@Before</code>  注解相对应，指定的方法在切面切入目标方法之后执行，也可以做一些完成某方法之后的 log 处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个切面，拦截com.itcodai.course09.controller包下的所有方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.itcodai.course09.controller..*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在上面定义的切面方法之后执行该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint jointPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"====doAfter方法进入了===="</span>);</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        String method = signature.getName();</span><br><span class="line">        logger.info(<span class="string">"方法&#123;&#125;已经执行完"</span>, method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们来写一个 Controller 来测试一下执行结果，新建一个 AopController 如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/aop"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testAop</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目，在浏览器中输入 <code>localhost:8080/aop/CSDN</code>，观察一下控制台的输出信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;doBefore方法进入了&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">即将执行方法为: testAop，属于com.itcodai.course09.controller.AopController包  </span><br><span class="line">用户请求的url为：http:&#x2F;&#x2F;localhost:8080&#x2F;aop&#x2F;name，ip地址为：0:0:0:0:0:0:0:1  </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;doAfter方法进入了&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">方法testAop已经执行完</span><br></pre></td></tr></table></figure><p>从打印出来的 log 中可以看出程序执行的逻辑与顺序，可以很直观的掌握 <code>@Before</code> 和 <code>@After</code> 两个注解的实际作用。</p><h4 id="2-2-4-AfterReturning-注解"><a href="#2-2-4-AfterReturning-注解" class="headerlink" title="2.2.4 @AfterReturning 注解"></a>2.2.4 @AfterReturning 注解</h4><p><code>@AfterReturning</code> 注解和 <code>@After</code> 有些类似，区别在于 <code>@AfterReturning</code> 注解可以用来捕获切入方法执行完之后的返回值，对返回值进行业务逻辑上的增强处理，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在上面定义的切面方法返回后执行该方法，可以捕获返回对象或者对返回对象进行增强</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(pointcut = <span class="string">"pointCut()"</span>, returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        String classMethod = signature.getName();</span><br><span class="line">        logger.info(<span class="string">"方法&#123;&#125;执行完毕，返回参数为：&#123;&#125;"</span>, classMethod, result);</span><br><span class="line">        <span class="comment">// 实际项目中可以根据业务做具体的返回值增强</span></span><br><span class="line">        logger.info(<span class="string">"对返回参数进行业务上的增强：&#123;&#125;"</span>, result + <span class="string">"增强版"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：在 <code>@AfterReturning</code>注解 中，属性 <code>returning</code> 的值必须要和参数保持一致，否则会检测不到。该方法中的第二个入参就是被切方法的返回值，在 <code>doAfterReturning</code> 方法中可以对返回值进行增强，可以根据业务需要做相应的封装。我们重启一下服务，再测试一下（多余的 log 我不贴出来了）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法testAop执行完毕，返回参数为：Hello CSDN  </span><br><span class="line">对返回参数进行业务上的增强：Hello CSDN增强版</span><br></pre></td></tr></table></figure><h4 id="2-2-5-AfterThrowing-注解"><a href="#2-2-5-AfterThrowing-注解" class="headerlink" title="2.2.5 @AfterThrowing 注解"></a>2.2.5 @AfterThrowing 注解</h4><p>顾名思义，<code>@AfterThrowing</code> 注解是当被切方法执行时抛出异常时，会进入 <code>@AfterThrowing</code> 注解的方法中执行，在该方法中可以做一些异常的处理逻辑。要注意的是 <code>throwing</code> 属性的值必须要和参数一致，否则会报错。该方法中的第二个入参即为抛出的异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用AOP处理log</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/05/04 20:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在上面定义的切面方法执行抛异常时，执行该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint jointPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex ex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(pointcut = <span class="string">"pointCut()"</span>, throwing = <span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable ex)</span> </span>&#123;</span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        String method = signature.getName();</span><br><span class="line">        <span class="comment">// 处理异常的逻辑</span></span><br><span class="line">        logger.info(<span class="string">"执行方法&#123;&#125;出错，异常为：&#123;&#125;"</span>, method, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法我就不测试了，大家可以自行测试一下。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本节课针对 Spring Boot 中的切面 AOP 做了详细的讲解，主要介绍了 Spring Boot 中 AOP 的引入，常用注解的使用，参数的使用，以及常用 api 的介绍。AOP 在实际项目中很有用，对切面方法执行前后都可以根据具体的业务，做相应的预处理或者增强处理，同时也可以用作异常捕获处理，可以根据具体业务场景，合理去使用 AOP。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第10课：Spring-Boot集成MyBatis"><a href="#第10课：Spring-Boot集成MyBatis" class="headerlink" title="第10课：Spring Boot集成MyBatis"></a>第10课：Spring Boot集成MyBatis</h1><h2 id="1-MyBatis-介绍"><a href="#1-MyBatis-介绍" class="headerlink" title="1. MyBatis 介绍"></a>1. MyBatis 介绍</h2><p>大家都知道，MyBatis 框架是一个持久层框架，是 Apache 下的顶级项目。Mybatis 可以让开发者的主要精力放在 sql 上，通过 Mybatis 提供的映射方式，自由灵活的生成满足需要的 sql 语句。使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs 映射成数据库中的记录，在国内可谓是占据了半壁江山。本节课程主要通过两种方式来对 Spring Boot 集成 MyBatis 做一讲解。重点讲解一下基于注解的方式。因为实际项目中使用注解的方式更多一点，更简洁一点，省去了很多 xml 配置（这不是绝对的，有些项目组中可能也在使用 xml 的方式）。</p><h2 id="2-MyBatis-的配置"><a href="#2-MyBatis-的配置" class="headerlink" title="2. MyBatis 的配置"></a>2. MyBatis 的配置</h2><h2 id="2-1-依赖导入"><a href="#2-1-依赖导入" class="headerlink" title="2.1 依赖导入"></a>2.1 依赖导入</h2><p>Spring Boot 集成 MyBatis，需要导入 <code>mybatis-spring-boot-starter</code> 和 mysql 的依赖，这里我们使用的版本时 1.3.2，如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们点开 <code>mybatis-spring-boot-starter</code> 依赖，可以看到我们之前使用 Spring 时候熟悉的依赖，就像我在课程的一开始介绍的那样，Spring Boot 致力于简化编码，使用 starter 系列将相关依赖集成在一起，开发者不需要关注繁琐的配置，非常方便。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省去其他 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-properties-yml配置"><a href="#2-2-properties-yml配置" class="headerlink" title="2.2 properties.yml配置"></a>2.2 properties.yml配置</h2><p>我们再来看一下，集成 MyBatis 时需要在 properties.yml 配置文件中做哪些基本配置呢？</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 服务端口号</span><br><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line"># 数据库地址</span><br><span class="line">datasource:</span><br><span class="line">  url: localhost:3306/blog_test</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource: # 数据库配置</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://$&#123;datasource.url&#125;?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    hikari:</span><br><span class="line">      maximum-pool-size: 10 # 最大连接池数</span><br><span class="line">      max-lifetime: 1770000</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  # 指定别名设置的包为所有entity</span><br><span class="line">  type-aliases-package: com.itcodai.course10.entity</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: true # 驼峰命名规范</span><br><span class="line">  mapper-locations: # mapper映射文件位置</span><br><span class="line">    - classpath:mapper/*.xml</span><br></pre></td></tr></table></figure><p>我们来简单介绍一下上面的这些配置：关于数据库的相关配置，我就不详细的解说了，这点相信大家已经非常熟练了，配置一下用户名、密码、数据库连接等等，这里使用的连接池是 Spring Boot 自带的 hikari，感兴趣的朋友可以去百度或者谷歌搜一搜，了解一下。  </p><p>这里说明一下 <code>map-underscore-to-camel-case: true</code>， 用来开启驼峰命名规范，这个比较好用，比如数据库中字段名为：<code>user_name</code>， 那么在实体类中可以定义属性为 <code>userName</code> （甚至可以写成 <code>username</code>，也能映射上），会自动匹配到驼峰属性，如果不这样配置的话，针对字段名和属性名不同的情况，会映射不到。</p><h2 id="3-基于-xml-的整合"><a href="#3-基于-xml-的整合" class="headerlink" title="3. 基于 xml 的整合"></a>3. 基于 xml 的整合</h2><p>使用原始的 xml 方式，需要新建 UserMapper.xml 文件，在上面的 application.yml 配置文件中，我们已经定义了 xml 文件的路径：<code>classpath:mapper/*.xml</code>，所以我们在 resources 目录下新建一个 mapper 文件夹，然后创建一个 UserMapper.xml 文件。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.itcodai.course10.dao.UserMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.itcodai.course10.entity.User"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByName"</span> <span class="attr">resultType</span>=<span class="string">"User"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span>&gt;</span></span><br><span class="line">       select * from user where user_name = #&#123;username&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这和整合 Spring 一样的，namespace 中指定的是对应的 Mapper， <code>&lt;resultMap&gt;</code> 中指定对应的实体类，即 User。然后在内部指定表的字段和实体的属性相对应即可。这里我们写一个根据用户名查询用户的 sql。  </p><p>实体类中有 id，username 和 password，我不在这贴代码，大家可以下载源码查看。UserMapper.java 文件中写一个接口即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">getUserByName</span><span class="params">(String username)</span></span>;</span><br></pre></td></tr></table></figure><p>中间省略 service 的代码，我们写一个 Controller 来测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getUserByName/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserByName</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserByName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目，在浏览器中输入：<code>http://localhost:8080/getUserByName/CSDN</code> 即可查询到数据库表中用户名为 CSDN 的用户信息（事先搞两个数据进去即可）：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="number">2</span>,<span class="attr">"username"</span>:<span class="string">"CSDN"</span>,<span class="attr">"password"</span>:<span class="string">"123456"</span>&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意一下：Spring Boot 如何知道这个 Mapper 呢？一种方法是在上面的 mapper 层对应的类上面添加 <code>@Mapper</code> 注解即可，但是这种方法有个弊端，当我们有很多个 mapper 时，那么每一个类上面都得添加 <code>@Mapper</code> 注解。另一种比较简便的方法是在 Spring Boot 启动类上添加<code>@MaperScan</code> 注解，来扫描一个包下的所有 mapper。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.itcodai.course10.dao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course10Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Course10Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，<code>com.itcodai.course10.dao</code> 包下的所有 mapper 都会被扫描到了。</p><h2 id="4-基于注解的整合"><a href="#4-基于注解的整合" class="headerlink" title="4. 基于注解的整合"></a>4. 基于注解的整合</h2><p>基于注解的整合就不需要 xml 配置文件了，MyBatis 主要提供了 <code>@Select</code>， <code>@Insert</code>， <code>@Update</code>， <code>Delete</code> 四个注解。这四个注解是用的非常多的，也很简单，注解后面跟上对应的 sql 语句即可，我们举个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure><p>这跟 xml 文件中写 sql 语句是一样的，这样就不需要 xml 文件了，但是有个问题，有人可能会问，如果是两个参数呢？如果是两个参数，我们需要使用 <code>@Param</code> 注解来指定每一个参数的对应关系，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125; and user_name=#&#123;name&#125;"</span>)</span><br><span class="line"><span class="function">User <span class="title">getUserByIdAndName</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Long id, @<span class="title">Param</span><span class="params">(<span class="string">"name"</span>)</span> String username)</span>;</span><br></pre></td></tr></table></figure><p>可以看出，<code>@Param</code> 指定的参数应该要和 sql 中 <code>#{}</code> 取的参数名相同，不同则取不到。可以在 controller 中自行测试一下，接口都在源码中，文章中我就不贴测试代码和结果了。  </p><p>有个问题需要注意一下，一般我们在设计表字段后，都会根据自动生成工具生成实体类，这样的话，基本上实体类是能和表字段对应上的，最起码也是驼峰对应的，由于在上面配置文件中开启了驼峰的配置，所以字段都是能对的上的。但是，万一有对不上的呢？我们也有解决办法，使用 <code>@Results</code> 注解来解决。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@Results</span>(&#123;</span><br><span class="line">        <span class="meta">@Result</span>(property = <span class="string">"username"</span>, column = <span class="string">"user_name"</span>),</span><br><span class="line">        <span class="meta">@Result</span>(property = <span class="string">"password"</span>, column = <span class="string">"password"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure><p><code>@Results</code> 中的 <code>@Result</code> 注解是用来指定每一个属性和字段的对应关系，这样的话就可以解决上面说的这个问题了。  </p><p>当然了，我们也可以 xml 和注解相结合使用，目前我们实际的项目中也是采用混用的方式，因为有时候 xml 方便，有时候注解方便，比如就上面这个问题来说，如果我们定义了上面的这个 UserMapper.xml，那么我们完全可以使用 <code>@ResultMap</code> 注解来替代 <code>@Results</code> 注解，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResultMap</span>(<span class="string">"BaseResultMap"</span>)</span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure><p><code>@ResultMap</code> 注解中的值从哪来呢？对应的是 UserMapper.xml 文件中定义的 <code>&lt;resultMap&gt;</code> 时对应的 id 值：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.itcodai.course10.entity.User"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种 xml 和注解结合着使用的情况也很常见，而且也减少了大量的代码，因为 xml 文件可以使用自动生成工具去生成，也不需要人为手动敲，所以这种使用方式也很常见。</p><h2 id="5-总结-3"><a href="#5-总结-3" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本节课主要系统的讲解了 Spring Boot 集成 MyBatis 的过程，分为基于 xml 形式和基于注解的形式来讲解，通过实际配置手把手讲解了 Spring Boot 中 MyBatis 的使用方式，并针对注解方式，讲解了常见的问题已经解决方式，有很强的实战意义。在实际项目中，建议根据实际情况来确定使用哪种方式，一般 xml 和注解都在用。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第11课：Spring-Boot事务配置管理"><a href="#第11课：Spring-Boot事务配置管理" class="headerlink" title="第11课：Spring Boot事务配置管理"></a>第11课：Spring Boot事务配置管理</h1><h2 id="1-事务相关"><a href="#1-事务相关" class="headerlink" title="1. 事务相关"></a>1. 事务相关</h2><p>场景：我们在开发企业应用时，由于数据操作在顺序执行的过程中，线上可能有各种无法预知的问题，任何一步操作都有可能发生异常，异常则会导致后续的操作无法完成。此时由于业务逻辑并未正确的完成，所以在之前操作过数据库的动作并不可靠，需要在这种情况下进行数据的回滚。  </p><p>事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。这很好理解，转账、购票等等，必须整个事件流程全部执行完才能人为该事件执行成功，不能转钱转到一半，系统死了，转账人钱没了，收款人钱还没到。</p><p>事务管理是 Spring Boot 框架中最为常用的功能之一，我们在实际应用开发时，基本上在 service 层处理业务逻辑的时候都要加上事务，当然了，有时候可能由于场景需要，也不用加事务（比如我们就要往一个表里插数据，相互没有影响，插多少是多少，不能因为某个数据挂了，把之前插的全部回滚）。</p><h2 id="2-Spring-Boot-事务配置"><a href="#2-Spring-Boot-事务配置" class="headerlink" title="2. Spring Boot 事务配置"></a>2. Spring Boot 事务配置</h2><h3 id="2-1-依赖导入-1"><a href="#2-1-依赖导入-1" class="headerlink" title="2.1 依赖导入"></a>2.1 依赖导入</h3><p>在 Spring Boot 中使用事务，需要导入 mysql 依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入了 mysql 依赖后，Spring Boot 会自动注入 DataSourceTransactionManager，我们不需要任何其他的配置就可以用 <code>@Transactional</code> 注解进行事务的使用。关于 mybatis 的配置，在上一节课中已经说明了，这里还是使用上一节课中的 mybatis 配置即可。  </p><h3 id="2-2-事务的测试"><a href="#2-2-事务的测试" class="headerlink" title="2.2 事务的测试"></a>2.2 事务的测试</h3><p>我们首先在数据库表中插入一条数据：<br>|id|user_name|password|<br>|:–:|:–:|:–:|<br>|1|倪升武|123456|</p><p>然后我们写一个插入的 mapper：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into user (user_name, password) values (#&#123;username&#125;, #&#123;password&#125;)"</span>)</span><br><span class="line">    <span class="function">Integer <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，接下来我们来测试一下 Spring Boot 中的事务处理，在 service 层，我们手动抛出个异常来模拟实际中出现的异常，然后观察一下事务有没有回滚，如果数据库中没有新的记录，则说明事务回滚成功。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isertUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入用户信息</span></span><br><span class="line">        userMapper.insertUser(user);</span><br><span class="line">        <span class="comment">// 手动抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/adduser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(@RequestBody User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != user) &#123;</span><br><span class="line">            userService.isertUser(user);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"false"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 postman 调用一下该接口，因为在程序中抛出了个异常，会造成事务回滚，我们刷新一下数据库，并没有增加一条记录，说明事务生效了。事务很简单，我们平时在使用的时候，一般不会有多少问题，但是并不仅仅如此……</p><h2 id="3-常见问题总结"><a href="#3-常见问题总结" class="headerlink" title="3. 常见问题总结"></a>3. 常见问题总结</h2><p>从上面的内容中可以看出，Spring Boot 中使用事务非常简单，<code>@Transactional</code> 注解即可解决问题，说是这么说，但是在实际项目中，是有很多小坑在等着我们，这些小坑是我们在写代码的时候没有注意到，而且正常情况下不容易发现这些小坑，等项目写大了，某一天突然出问题了，排查问题非常困难，到时候肯定是抓瞎，需要费很大的精力去排查问题。  </p><p>这一小节，我专门针对实际项目中经常出现的，和事务相关的细节做一下总结，希望读者在读完之后，能够落实到自己的项目中，能有所受益。</p><h3 id="3-1-异常并没有被-”捕获“-到"><a href="#3-1-异常并没有被-”捕获“-到" class="headerlink" title="3.1 异常并没有被 ”捕获“ 到"></a>3.1 异常并没有被 ”捕获“ 到</h3><p>首先要说的，就是异常并没有被 ”捕获“ 到，导致事务并没有回滚。我们在业务层代码中，也许已经考虑到了异常的存在，或者编辑器已经提示我们需要抛出异常，但是这里面有个需要注意的地方：并不是说我们把异常抛出来了，有异常了事务就会回滚，我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isertUser2</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 插入用户信息</span></span><br><span class="line">        userMapper.insertUser(user);</span><br><span class="line">        <span class="comment">// 手动抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"数据库异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看上面这个代码，其实并没有什么问题，手动抛出一个 <code>SQLException</code> 来模拟实际中操作数据库发生的异常，在这个方法中，既然抛出了异常，那么事务应该回滚，实际却不如此，读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据的。  </p><p>那么问题出在哪呢？因为 Spring Boot 默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。比如上面我们的例子中抛出的 RuntimeException 就没有问题，但是抛出 SQLException 就无法回滚了。针对非运行时异常，如果要进行事务回滚的话，可以在 <code>@Transactional</code> 注解中使用 <code>rollbackFor</code> 属性来指定异常，比如 <code>@Transactional(rollbackFor = Exception.class)</code>，这样就没有问题了，所以在实际项目中，一定要指定异常。</p><h3 id="3-2-异常被-”吃“-掉"><a href="#3-2-异常被-”吃“-掉" class="headerlink" title="3.2 异常被 ”吃“ 掉"></a>3.2 异常被 ”吃“ 掉</h3><p>这个标题很搞笑，异常怎么会被吃掉呢？还是回归到现实项目中去，我们在处理异常时，有两种方式，要么抛出去，让上一层来捕获处理；要么把异常 try catch 掉，在异常出现的地方给处理掉。就因为有这中 try…catch，所以导致异常被 ”吃“ 掉，事务无法回滚。我们还是看上面那个例子，只不过简单修改一下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">isertUser3</span>(<span class="title">User</span> <span class="title">user</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 插入用户信息</span></span><br><span class="line">            userMapper.insertUser(user);</span><br><span class="line">            <span class="comment">// 手动抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"数据库异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// 异常处理逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据，说明事务并没有因为抛出异常而回滚。这个细节往往比上面那个坑更难以发现，因为我们的思维很容易导致 try…catch 代码的产生，一旦出现这种问题，往往排查起来比较费劲，所以我们平时在写代码时，一定要多思考，多注意这种细节，尽量避免给自己埋坑。  </p><p>那这种怎么解决呢？直接往上抛，给上一层来处理即可，千万不要在事务中把异常自己 ”吃“ 掉。</p><h3 id="3-3-事务的范围"><a href="#3-3-事务的范围" class="headerlink" title="3.3 事务的范围"></a>3.3 事务的范围</h3><p>事务范围这个东西比上面两个坑埋的更深！我之所以把这个也写上，是因为这是我之前在实际项目中遇到的，该场景在这个课程中我就不模拟了，我写一个 demo 让大家看一下，把这个坑记住即可，以后在写代码时，遇到并发问题，就会注意这个坑了，那么这节课也就有价值了。  </p><p>我来写个 demo：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">synchronized</span> <span class="title">void</span> <span class="title">isertUser4</span>(<span class="title">User</span> <span class="title">user</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 实际中的具体业务……</span></span><br><span class="line">        userMapper.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，因为要考虑并发问题，我在业务层代码的方法上加了个 synchronized 关键字。我举个实际的场景，比如一个数据库中，针对某个用户，只有一条记录，下一个插入动作过来，会先判断该数据库中有没有相同的用户，如果有就不插入，就更新，没有才插入，所以理论上，数据库中永远就一条同一用户信息，不会出现同一数据库中插入了两条相同用户的信息。  </p><p>但是在压测时，就会出现上面的问题，数据库中确实有两条同一用户的信息，分析其原因，在于事务的范围和锁的范围问题。  </p><p>从上面方法中可以看到，方法上是加了事务的，那么也就是说，在执行该方法开始时，事务启动，执行完了后，事务关闭。但是 synchronized 没有起作用，其实根本原因是因为事务的范围比锁的范围大。也就是说，在加锁的那部分代码执行完之后，锁释放掉了，但是事务还没结束，此时另一个线程进来了，事务没结束的话，第二个线程进来时，数据库的状态和第一个线程刚进来是一样的。即由于mysql Innodb引擎的默认隔离级别是可重复读（在同一个事务里，SELECT的结果是事务开始时时间点的状态），线程二事务开始的时候，线程一还没提交完成，导致读取的数据还没更新。第二个线程也做了插入动作，导致了脏数据。  </p><p>这个问题可以避免，第一，把事务去掉即可（不推荐）；第二，在调用该 service 的地方加锁，保证锁的范围比事务的范围大即可。</p><h2 id="4-总结-4"><a href="#4-总结-4" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本章主要总结了 Spring Boot 中如何使用事务，只要使用 <code>@Transactional</code> 注解即可使用，非常简单方便。除此之外，重点总结了三个在实际项目中可能遇到的坑点，这非常有意义，因为事务这东西不出问题还好，出了问题比较难以排查，所以总结的这三点注意事项，希望能帮助到开发中的朋友。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第12课：Spring-Boot中使用监听器"><a href="#第12课：Spring-Boot中使用监听器" class="headerlink" title="第12课：Spring Boot中使用监听器"></a>第12课：Spring Boot中使用监听器</h1><h2 id="1-监听器介绍"><a href="#1-监听器介绍" class="headerlink" title="1. 监听器介绍"></a>1. 监听器介绍</h2><p>什么是 web 监听器？web 监听器是一种 Servlet 中特殊的类，它们能帮助开发者监听 web 中特定的事件，比如 ServletContext, HttpSession, ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。</p><h2 id="2-Spring-Boot中监听器的使用"><a href="#2-Spring-Boot中监听器的使用" class="headerlink" title="2. Spring Boot中监听器的使用"></a>2. Spring Boot中监听器的使用</h2><p>web 监听器的使用场景很多，比如监听 servlet 上下文用来初始化一些数据、监听 http session 用来获取当前在线的人数、监听客户端请求的 servlet request 对象来获取用户的访问信息等等。这一节中，我们主要通过这三个实际的使用场景来学习一下 Spring Boot 中监听器的使用。</p><h3 id="2-1-监听Servlet上下文对象"><a href="#2-1-监听Servlet上下文对象" class="headerlink" title="2.1 监听Servlet上下文对象"></a>2.1 监听Servlet上下文对象</h3><p>监听 servlet 上下文对象可以用来初始化数据，用于缓存。什么意思呢？我举一个很常见的场景，比如用户在点击某个站点的首页时，一般都会展现出首页的一些信息，而这些信息基本上或者大部分时间都保持不变的，但是这些信息都是来自数据库。如果用户的每次点击，都要从数据库中去获取数据的话，用户量少还可以接受，如果用户量非常大的话，这对数据库也是一笔很大的开销。  </p><p>针对这种首页数据，大部分都不常更新的话，我们完全可以把它们缓存起来，每次用户点击的时候，我们都直接从缓存中拿，这样既可以提高首页的访问速度，又可以降低服务器的压力。如果做的更加灵活一点，可以再加个定时器，定期的来更新这个首页缓存。就类似与 CSDN 个人博客首页中排名的变化一样。</p><p>下面我们针对这个功能，来写一个 demo，在实际中，读者可以完全套用该代码，来实现自己项目中的相关逻辑。首先写一个 Service，模拟一下从数据库查询数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实际中会根据具体的业务场景，从数据库中查询对应的信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写一个监听器，实现 <code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code> 接口，重写 <code>onApplicationEvent</code> 方法，将 ContextRefreshedEvent 对象传进去。如果我们想在加载或刷新应用上下文时，也重新刷新下我们预加载的资源，就可以通过监听 ContextRefreshedEvent 来做这样的事情。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用ApplicationListener来初始化一些数据到application域中的监听器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengni ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent contextRefreshedEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先获取到application上下文</span></span><br><span class="line">        ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();</span><br><span class="line">        <span class="comment">// 获取对应的service</span></span><br><span class="line">        UserService userService = applicationContext.getBean(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user = userService.getUser();</span><br><span class="line">        <span class="comment">// 获取application域对象，将查到的信息放到application域中</span></span><br><span class="line">        ServletContext application = applicationContext.getBean(ServletContext<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        application.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如注释中描述的一样，首先通过 contextRefreshedEvent 来获取 application 上下文，再通过 application 上下文来获取 UserService 这个 bean，项目中可以根据实际业务场景，也可以获取其他的 bean，然后再调用自己的业务代码获取相应的数据，最后存储到 application 域中，这样前端在请求相应数据的时候，我们就可以直接从 application 域中获取信息，减少数据库的压力。下面写一个 Controller 直接从 application 域中获取 user 信息来测试一下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/listener"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        ServletContext application = request.getServletContext();</span><br><span class="line">        <span class="keyword">return</span> (User) application.getAttribute(<span class="string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目，在浏览器中输入 <code>http://localhost:8080/listener/user</code> 测试一下即可，如果正常返回 user 信息，那么说明数据已经缓存成功。不过 application 这种是缓存在内存中，对内存会有消耗，后面的课程中我会讲到 redis，到时候再给大家介绍一下 redis 的缓存。</p><h3 id="2-2-监听HTTP会话-Session对象"><a href="#2-2-监听HTTP会话-Session对象" class="headerlink" title="2.2 监听HTTP会话 Session对象"></a>2.2 监听HTTP会话 Session对象</h3><p>监听器还有一个比较常用的地方就是用来监听 session 对象，来获取在线用户数量，现在有很多开发者都有自己的网站，监听 session 来获取当前在下用户数量是个很常见的使用场景，下面来介绍一下如何来使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用HttpSessionListener统计在线用户数的监听器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpSessionListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyHttpSessionListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录在线的用户数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"新用户上线了"</span>);</span><br><span class="line">        count++;</span><br><span class="line">        httpSessionEvent.getSession().getServletContext().setAttribute(<span class="string">"count"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"用户下线了"</span>);</span><br><span class="line">        count--;</span><br><span class="line">        httpSessionEvent.getSession().getServletContext().setAttribute(<span class="string">"count"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，首先该监听器需要实现 HttpSessionListener 接口，然后重写 <code>sessionCreated</code> 和 <code>sessionDestroyed</code> 方法，在 <code>sessionCreated</code> 方法中传递一个 HttpSessionEvent 对象，然后将当前 session 中的用户数量加1，<code>sessionDestroyed</code> 方法刚好相反，不再赘述。然后我们写一个 Controller 来测试一下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/listener"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前在线人数，该方法有bug</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/total"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTotalUser</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Integer count = (Integer) request.getSession().getServletContext().getAttribute(<span class="string">"count"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"当前在线人数："</span> + count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该 Controller 中是直接获取当前 session 中的用户数量，启动服务器，在浏览器中输入 <code>localhost:8080/listener/total</code> 可以看到返回的结果是1，再打开一个浏览器，请求相同的地址可以看到 count 是 2 ，这没有问题。但是如果关闭一个浏览器再打开，理论上应该还是2，但是实际测试却是 3。原因是 session 销毁的方法没有执行（可以在后台控制台观察日志打印情况），当重新打开时，服务器找不到用户原来的 session，于是又重新创建了一个 session，那怎么解决该问题呢？我们可以将上面的 Controller 方法改造一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/total2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTotalUser</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    Cookie cookie;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 把sessionId记录在浏览器中</span></span><br><span class="line">        cookie = <span class="keyword">new</span> Cookie(<span class="string">"JSESSIONID"</span>, URLEncoder.encode(request.getSession().getId(), <span class="string">"utf-8"</span>));</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">//设置cookie有效期为2天，设置长一点</span></span><br><span class="line">        cookie.setMaxAge( <span class="number">48</span>*<span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Integer count = (Integer) request.getSession().getServletContext().getAttribute(<span class="string">"count"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"当前在线人数："</span> + count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，该处理逻辑是让服务器记得原来那个 session，即把原来的 sessionId 记录在浏览器中，下次再打开时，把这个 sessionId 传过去，这样服务器就不会重新再创建了。重启一下服务器，在浏览器中再次测试一下，即可避免上面的问题。</p><h3 id="2-3-监听客户端请求Servlet-Request对象"><a href="#2-3-监听客户端请求Servlet-Request对象" class="headerlink" title="2.3 监听客户端请求Servlet Request对象"></a>2.3 监听客户端请求Servlet Request对象</h3><p>使用监听器获取用户的访问信息比较简单，实现 ServletRequestListener 接口即可，然后通过 request 对象获取一些信息。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用ServletRequestListener获取访问信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletRequestListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyServletRequestListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();</span><br><span class="line">        logger.info(<span class="string">"session id为：&#123;&#125;"</span>, request.getRequestedSessionId());</span><br><span class="line">        logger.info(<span class="string">"request url为：&#123;&#125;"</span>, request.getRequestURL());</span><br><span class="line"></span><br><span class="line">        request.setAttribute(<span class="string">"name"</span>, <span class="string">"倪升武"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"request end"</span>);</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();</span><br><span class="line">        logger.info(<span class="string">"request域中保存的name值为：&#123;&#125;"</span>, request.getAttribute(<span class="string">"name"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个比较简单，不再赘述，接下来写一个 Controller 测试一下即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/request"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRequestInfo</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"requestListener中的初始化的name数据："</span> + request.getAttribute(<span class="string">"name"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Spring-Boot中自定义事件监听"><a href="#3-Spring-Boot中自定义事件监听" class="headerlink" title="3. Spring Boot中自定义事件监听"></a>3. Spring Boot中自定义事件监听</h2><p>在实际项目中，我们往往需要自定义一些事件和监听器来满足业务场景，比如在微服务中会有这样的场景：微服务 A 在处理完某个逻辑之后，需要通知微服务 B 去处理另一个逻辑，或者微服务 A 处理完某个逻辑之后，需要将数据同步到微服务 B，这种场景非常普遍，这个时候，我们可以自定义事件以及监听器来监听，一旦监听到微服务 A 中的某事件发生，就去通知微服务 B 处理对应的逻辑。</p><h3 id="3-1-自定义事件"><a href="#3-1-自定义事件" class="headerlink" title="3.1 自定义事件"></a>3.1 自定义事件</h3><p>自定义事件需要继承 ApplicationEvent 对象，在事件中定义一个 User 对象来模拟数据，构造方法中将 User 对象传进来初始化。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义事件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source, User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省去get、set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-自定义监听器"><a href="#3-2-自定义监听器" class="headerlink" title="3.2 自定义监听器"></a>3.2 自定义监听器</h3><p>接下来，自定义一个监听器来监听上面定义的 MyEvent 事件，自定义监听器需要实现 <code>ApplicationListener</code> 接口即可。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义监听器，监听MyEvent事件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/07/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent myEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把事件中的信息获取到</span></span><br><span class="line">        User user = myEvent.getUser();</span><br><span class="line">        <span class="comment">// 处理事件，实际项目中可以通知别的微服务或者处理其他逻辑等等</span></span><br><span class="line">        System.out.println(<span class="string">"用户名："</span> + user.getUsername());</span><br><span class="line">        System.out.println(<span class="string">"密码："</span> + user.getPassword());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重写 <code>onApplicationEvent</code> 方法，将自定义的 MyEvent 事件传进来，因为该事件中，我们定义了 User 对象（该对象在实际中就是需要处理的数据，在下文来模拟），然后就可以使用该对象的信息了。</p><p>OK，定义好了事件和监听器之后，需要手动发布事件，这样监听器才能监听到，这需要根据实际业务场景来触发，针对本文的例子，我写个触发逻辑，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        MyEvent event = <span class="keyword">new</span> MyEvent(<span class="keyword">this</span>, user);</span><br><span class="line">        applicationContext.publishEvent(event);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 service 中注入 ApplicationContext，在业务代码处理完之后，通过 ApplicationContext 对象手动发布 MyEvent 事件，这样我们自定义的监听器就能监听到，然后处理监听器中写好的业务逻辑。</p><p>最后，在 Controller 中写一个接口来测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/request"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRequestInfo</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"requestListener中的初始化的name数据："</span> + request.getAttribute(<span class="string">"name"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器中输入 <code>http://localhost:8080/listener/publish</code>，然后观察一下控制台打印的用户名和密码，即可说明自定义监听器已经生效。</p><h2 id="4-总结-5"><a href="#4-总结-5" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本课系统的介绍了监听器原理，以及在 Spring Boot 中如何使用监听器，列举了监听器的三个常用的案例，有很好的实战意义。最后讲解了项目中如何自定义事件和监听器，并结合微服务中常见的场景，给出具体的代码模型，均能运用到实际项目中去，希望读者认真消化。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第13课：Spring-Boot中使用拦截器"><a href="#第13课：Spring-Boot中使用拦截器" class="headerlink" title="第13课：Spring Boot中使用拦截器"></a>第13课：Spring Boot中使用拦截器</h1><p>拦截器的原理很简单，是 AOP 的一种实现，专门拦截对动态资源的后台请求，即拦截对控制层的请求。使用场景比较多的是判断用户是否有权限请求后台，更拔高一层的使用场景也有，比如拦截器可以结合 websocket 一起使用，用来拦截 websocket 请求，然后做相应的处理等等。拦截器不会拦截静态资源，Spring Boot 的默认静态目录为 resources/static，该目录下的静态页面、js、css、图片等等，不会被拦截（也要看如何实现，有些情况也会拦截，我在下文会指出）。</p><h2 id="1-拦截器的快速使用"><a href="#1-拦截器的快速使用" class="headerlink" title="1. 拦截器的快速使用"></a>1. 拦截器的快速使用</h2><p>使用拦截器很简单，只需要两步即可：定义拦截器和配置拦截器。在配置拦截器中，Spring Boot 2.0 以后的版本和之前的版本有所不同，我会重点讲解一下这里可能出现的坑。</p><h3 id="1-1-定义拦截器"><a href="#1-1-定义拦截器" class="headerlink" title="1.1 定义拦截器"></a>1.1 定义拦截器</h3><p>定义拦截器，只需要实现 <code>HandlerInterceptor</code> 接口，<code>HandlerInterceptor</code> 接口是所有自定义拦截器或者 Spring Boot 提供的拦截器的鼻祖，所以，首先来了解下该接口。该接口中有三个方法： <code>preHandle(……)</code>、<code>postHandle(……)</code> 和 <code>afterCompletion(……)</code> 。</p><blockquote><p><code>preHandle(……)</code> 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在这个方法执行之前。所以 <code>preHandle(……)</code> 方法可以决定是否将请求放行，这是通过返回值来决定的，返回 true 则放行，返回 false 则不会向后执行。<br><code>postHandle(……)</code> 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在执行完了该方法，但是在 DispatcherServlet 视图渲染之前。所以在这个方法中有个 ModelAndView 参数，可以在此做一些修改动作。<br><code>afterCompletion(……)</code> 方法：顾名思义，该方法是在整个请求处理完成后（包括视图渲染）执行，这时做一些资源的清理工作，这个方法只有在 <code>preHandle(……)</code> 被成功执行后并且返回 true 才会被执行。  </p></blockquote><p>了解了该接口，接下来自定义一个拦截器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/08/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        Method method = handlerMethod.getMethod();</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        logger.info(<span class="string">"====拦截到了方法：&#123;&#125;，在该方法执行之前执行===="</span>, methodName);</span><br><span class="line">        <span class="comment">// 返回true才会继续执行，返回false则取消当前请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，到此为止，拦截器已经定义完成，接下来就是对该拦截器进行拦截配置。</p><h3 id="1-2-配置拦截器"><a href="#1-2-配置拦截器" class="headerlink" title="1.2 配置拦截器"></a>1.2 配置拦截器</h3><p>在 Spring Boot 2.0 之前，我们都是直接继承 WebMvcConfigurerAdapter 类，然后重写 <code>addInterceptors</code> 方法来实现拦截器的配置。但是在 Spring Boot 2.0 之后，该方法已经被废弃了（当然，也可以继续用），取而代之的是 WebMvcConfigurationSupport 方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptorConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该配置中重写 <code>addInterceptors</code> 方法，将我们上面自定义的拦截器添加进去，<code>addPathPatterns</code> 方法是添加要拦截的请求，这里我们拦截所有的请求。这样就配置好拦截器了，接下来写一个 Controller 测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/interceptor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让其跳转到 hello.html 页面，直接在 hello.html 中输出 <code>hello interceptor</code> 即可。启动项目，在浏览器中输入 <code>localhost:8080/interceptor/test</code> 看一下控制台的日志：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;拦截到了方法：test，在该方法执行之前执行&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染  </span><br><span class="line">整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了</span><br></pre></td></tr></table></figure><p>可以看出拦截器已经生效，并能看出其执行顺序。</p><h3 id="1-3-解决静态资源被拦截问题"><a href="#1-3-解决静态资源被拦截问题" class="headerlink" title="1.3 解决静态资源被拦截问题"></a>1.3 解决静态资源被拦截问题</h3><p>上文中已经介绍了拦截器的定义和配置，但是这样是否就没问题了呢？其实不然，如果使用上面这种配置的话，我们会发现一个缺陷，那就是静态资源被拦截了。可以在 resources/static/ 目录下放置一个图片资源或者 html 文件，然后启动项目直接访问，即可看到无法访问的现象。</p><p>也就是说，虽然 Spring Boot 2.0 废弃了WebMvcConfigurerAdapter，但是 WebMvcConfigurationSupport 又会导致默认的静态资源被拦截，这就需要我们手动将静态资源放开。</p><p>如何放开呢？除了在 MyInterceptorConfig 配置类中重写 <code>addInterceptors</code> 方法外，还需要再重写一个方法：<code>addResourceHandlers</code>，将静态资源放开：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addResourceHandler(<span class="string">"/**"</span>).addResourceLocations(<span class="string">"classpath:/static/"</span>);</span><br><span class="line">    <span class="keyword">super</span>.addResourceHandlers(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置好之后，重启项目，静态资源也可以正常访问了。如果你是个善于学习或者研究的人，那肯定不会止步于此，没错，上面这种方式的确能解决静态资源无法访问的问题，但是，还有更方便的方式来配置。</p><p>我们不继承 WebMvcConfigurationSupport 类，直接实现 WebMvcConfigurer 接口，然后重写 <code>addInterceptors</code> 方法，将自定义的拦截器添加进去即可，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现WebMvcConfigurer不会导致静态资源被拦截</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就非常方便了，实现 WebMvcConfigure 接口的话，不会拦截 Spring Boot 默认的静态资源。</p><p>这两种方式都可以，具体他们之间的细节，感兴趣的读者可以做进一步的研究，由于这两种方式的不同，继承 WebMvcConfigurationSupport 类的方式可以用在前后端分离的项目中，后台不需要访问静态资源（就不需要放开静态资源了）；实现 WebMvcConfigure 接口的方式可以用在非前后端分离的项目中，因为需要读取一些图片、css、js文件等等。</p><h2 id="2-拦截器使用实例"><a href="#2-拦截器使用实例" class="headerlink" title="2. 拦截器使用实例"></a>2. 拦截器使用实例</h2><h3 id="2-1-判断用户有没有登录"><a href="#2-1-判断用户有没有登录" class="headerlink" title="2.1 判断用户有没有登录"></a>2.1 判断用户有没有登录</h3><p>一般用户登录功能我们可以这么做，要么往 session 中写一个 user，要么针对每个 user 生成一个 token，第二种要更好一点，那么针对第二种方式，如果用户登录成功了，每次请求的时候都会带上该用户的 token，如果未登录，则没有该 token，服务端可以检测这个 token 参数的有无来判断用户有没有登录，从而实现拦截功能。我们改造一下 <code>preHandle</code> 方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">    Method method = handlerMethod.getMethod();</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    logger.info(<span class="string">"====拦截到了方法：&#123;&#125;，在该方法执行之前执行===="</span>, methodName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户有没有登陆，一般登陆之后的用户都有一个对应的token</span></span><br><span class="line">    String token = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == token || <span class="string">""</span>.equals(token)) &#123;</span><br><span class="line">        logger.info(<span class="string">"用户未登录，没有权限执行……请登录"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true才会继续执行，返回false则取消当前请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启项目，在浏览器中输入 <code>localhost:8080/interceptor/test</code> 后查看控制台日志，发现被拦截，如果在浏览器中输入 <code>localhost:8080/interceptor/test?token=123</code> 即可正常往下走。</p><h3 id="2-2-取消拦截操作"><a href="#2-2-取消拦截操作" class="headerlink" title="2.2 取消拦截操作"></a>2.2 取消拦截操作</h3><p>根据上文，如果我要拦截所有 <code>/admin</code> 开头的 url 请求的话，需要在拦截器配置中添加这个前缀，但是在实际项目中，可能会有这种场景出现：某个请求也是 <code>/admin</code> 开头的，但是不能拦截，比如 <code>/admin/login</code> 等等，这样的话又需要去配置。那么，可不可以做成一个类似于开关的东西，哪里不需要拦截，我就在哪里弄个开关上去，做成这种灵活的可插拔的效果呢？</p><p>是可以的，我们可以定义一个注解，该注解专门用来取消拦截操作，如果某个 Controller 中的方法我们不需要拦截掉，即可在该方法上加上我们自定义的注解即可，下面先定义一个注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该注解用来指定某个方法不用拦截</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UnInterception &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Controller 中的某个方法上添加该注解，在拦截器处理方法中添加该注解取消拦截的逻辑，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">    Method method = handlerMethod.getMethod();</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    logger.info(<span class="string">"====拦截到了方法：&#123;&#125;，在该方法执行之前执行===="</span>, methodName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过方法，可以获取该方法上的自定义注解，然后通过注解来判断该方法是否要被拦截</span></span><br><span class="line">    <span class="comment">// @UnInterception 是我们自定义的注解</span></span><br><span class="line">    UnInterception unInterception = method.getAnnotation(UnInterception<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != unInterception) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回true才会继续执行，返回false则取消当前请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller 中的方法代码可以参见源码，重启项目在浏览器中输入 <code>http://localhost:8080/interceptor/test2?token=123</code> 测试一下，可以看出，加了该注解的方法不会被拦截。</p><h2 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本节主要介绍了 Spring Boot 中拦截器的使用，从拦截器的创建、配置，到拦截器对静态资源的影响，都做了详细的分析。Spring Boot 2.0 之后拦截器的配置支持两种方式，可以根据实际情况选择不同的配置方式。最后结合实际中的使用，举了两个常用的场景，希望读者能够认真消化，掌握拦截器的使用。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第14课：Spring-Boot-中集成Redis"><a href="#第14课：Spring-Boot-中集成Redis" class="headerlink" title="第14课：Spring Boot 中集成Redis"></a>第14课：Spring Boot 中集成Redis</h1><h2 id="1-Redis-介绍"><a href="#1-Redis-介绍" class="headerlink" title="1. Redis 介绍"></a>1. Redis 介绍</h2><p>Redis 是一种非关系型数据库（NoSQL），NoSQL 是以 key-value 的形式存储的，和传统的关系型数据库不一样，不一定遵循传统数据库的一些基本要求，比如说 SQL 标准，ACID 属性，表结构等等，这类数据库主要有以下特点：非关系型的、分布式的、开源的、水平可扩展的。<br>NoSQL 使用场景有：对数据高并发读写、对海量数据的高效率存储和访问、对数据的高可扩展性和高可用性等等。<br>Redis 的 key 可以是字符串、哈希、链表、集合和有序集合。value 类型很多，包括 String、list、set、zset。这些数据类型都支持 push/pop、add/remove、取交集和并集以及更多更丰富的操作，Redis 也支持各种不同方式的排序。为了保证效率，数据都是在缓存在内存中，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中。 有了 redis 有哪些好处呢？举个比较简单的例子，看下图： </p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/4258b9c0-9f93-11e8-a34f-d93da92347ea"  alt="Redis使用场景"></p><p>Redis 集群和 Mysql 是同步的，首先会从 redis 中获取数据，如果 redis 挂了，再从 mysql 中获取数据，这样网站就不会挂掉。更多关于 redis 的介绍以及使用场景，可以谷歌和百度，在这就不赘述了。</p><h2 id="2-Redis-安装"><a href="#2-Redis-安装" class="headerlink" title="2. Redis 安装"></a>2. Redis 安装</h2><p>本课程是在 vmvare 虚拟机中来安装的 redis （centos 7），学习的时候如果有自己的阿里云服务器，也可以在阿里云中来安装 redis，都可以。只要能 ping 的通云主机或者虚拟机的 ip，然后在虚拟机或者云主机中放行对应的端口（或者关掉防火墙）即可访问 redis。下面来介绍一下 redis 的安装过程：</p><ul><li>安装 gcc 编译</li></ul><p>因为后面安装redis的时候需要编译，所以事先得先安装gcc编译。阿里云主机已经默认安装了 gcc，如果是自己安装的虚拟机，那么需要先安装一下 gcc：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><ul><li>下载 redis</li></ul><p>有两种方式下载安装包，一种是去官网上下载（<a href="https://redis.io），然后将安装包考到" target="_blank" rel="noopener">https://redis.io），然后将安装包考到</a> centos 中，另种方法是直接使用 wget 来下载：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.8.tar.gz</span><br></pre></td></tr></table></figure><p>如果没有安装过 wget，可以通过如下命令安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><ul><li>解压安装</li></ul><p>解压安装包：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar –vzxf redis-3.2.8.tar.gz</span><br></pre></td></tr></table></figure><p>然后将解压的文件夹 redis-3.2.8 放到 <code>/usr/local/</code> 下，一般安装软件都放在 <code>/usr/local</code> 下。然后进入 <code>/usr/local/redis-3.2.8/</code> 文件夹下，执行 <code>make</code> 命令即可完成安装。<br>【注】如果 make 失败，可以尝试如下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make MALLOC&#x3D;libc</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><p>安装成功之后，需要修改一下配置文件，包括允许接入的 ip，允许后台执行，设置密码等等。<br>打开 redis 配置文件：<code>vi redis.conf</code><br>在命令模式下输入 <code>/bind</code> 来查找 bind 配置，按 n 来查找下一个，找到配置后，将 bind 配置成 0.0.0.0，允许任意服务器来访问 redis，即：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure><p>使用同样的方法，将 daemonize 改成 yes （默认为 no），允许 redis 在后台执行。<br>将 requirepass 注释打开，并设置密码为 123456（密码自己设置）。</p><ul><li>启动 redis</li></ul><p>在 redis-3.2.8 目录下，指定刚刚修改好的配置文件 redis.conf 来启动 redis：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server .&#x2F;redis.conf</span><br></pre></td></tr></table></figure><p>再启动 redis 客户端：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p>由于我们设置了密码，在启动客户端之后，输入 <code>auth 123456</code> 即可登录进入客户端。<br>然后我们来测试一下，往 redis 中插入一个数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set name CSDN</span><br></pre></td></tr></table></figure><p>然后来获取 name</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get name</span><br></pre></td></tr></table></figure><p>如果正常获取到 CSDN，则说明没有问题。</p><h2 id="3-Spring-Boot-集成-Redis"><a href="#3-Spring-Boot-集成-Redis" class="headerlink" title="3. Spring Boot 集成 Redis"></a>3. Spring Boot 集成 Redis</h2><h3 id="3-1-依赖导入"><a href="#3-1-依赖导入" class="headerlink" title="3.1 依赖导入"></a>3.1 依赖导入</h3><p>Spring Boot 集成 redis 很方便，只需要导入一个 redis 的 starter 依赖即可。如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--阿里巴巴fastjson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里也导入阿里巴巴的 fastjson 是为了在后面我们要存一个实体，为了方便把实体转换成 json 字符串存进去。</p><h3 id="3-2-Redis-配置"><a href="#3-2-Redis-配置" class="headerlink" title="3.2 Redis 配置"></a>3.2 Redis 配置</h3><p>导入了依赖之后，我们在 application.yml 文件里配置 redis：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#redis相关配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment"># 配置redis的主机地址，需要修改成自己的</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.48</span><span class="number">.190</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">5000</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># 连接池中的最大空闲连接，默认值也是8。</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">500</span></span><br><span class="line">        <span class="comment"># 连接池中的最小空闲连接，默认值也是0。</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">50</span></span><br><span class="line">        <span class="comment"># 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">1000</span></span><br><span class="line">        <span class="comment"># 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><h3 id="3-3-常用-api-介绍"><a href="#3-3-常用-api-介绍" class="headerlink" title="3.3 常用 api 介绍"></a>3.3 常用 api 介绍</h3><p>Spring Boot 对 redis 的支持已经非常完善了，丰富的 api 已经足够我们日常的开发，这里我介绍几个最常用的供大家学习，其他 api 希望大家自己多学习，多研究。用到会去查即可。</p><p>有两个 redis 模板：RedisTemplate 和 StringRedisTemplate。我们不使用 RedisTemplate，RedisTemplate 提供给我们操作对象，操作对象的时候，我们通常是以 json 格式存储，但在存储的时候，会使用 Redis 默认的内部序列化器；导致我们存进里面的是乱码之类的东西。当然了，我们可以自己定义序列化，但是比较麻烦，所以使用 StringRedisTemplate 模板。StringRedisTemplate 主要给我们提供字符串操作，我们可以将实体类等转成 json 字符串即可，在取出来后，也可以转成相应的对象，这就是上面我导入了阿里 fastjson 的原因。</p><h4 id="3-3-1-redis-string-类型"><a href="#3-3-1-redis-string-类型" class="headerlink" title="3.3.1 redis:string 类型"></a>3.3.1 redis:string 类型</h4><p>新建一个 RedisService，注入 StringRedisTemplate，使用 <code>stringRedisTemplate.opsForValue()</code> 可以获取 <code>ValueOperations&lt;String, String&gt;</code> 对象，通过该对象即可读写 redis 数据库了。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set redis: string类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue();</span><br><span class="line">        valueOperations.set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get redis: string类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该对象操作的是 string，我们也可以存实体类，只需要将实体类转换成 json 字符串即可。下面来测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Course14ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Course14ApplicationTests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试redis的string类型</span></span><br><span class="line">        redisService.setString(<span class="string">"weichat"</span>,<span class="string">"程序员私房菜"</span>);</span><br><span class="line">        logger.info(<span class="string">"我的微信公众号为：&#123;&#125;"</span>, redisService.getString(<span class="string">"weichat"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是个实体，我们可以使用json工具转成json字符串，</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"CSDN"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        redisService.setString(<span class="string">"userInfo"</span>, JSON.toJSONString(user));</span><br><span class="line">        logger.info(<span class="string">"用户信息：&#123;&#125;"</span>, redisService.getString(<span class="string">"userInfo"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动 redis，然后运行这个测试用例，观察控制台打印的日志如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我的微信公众号为：程序员私房菜</span><br><span class="line">用户信息：&#123;&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;CSDN&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-redis-hash-类型"><a href="#3-3-2-redis-hash-类型" class="headerlink" title="3.3.2 redis:hash 类型"></a>3.3.2 redis:hash 类型</h4><p>hash 类型其实原理和 string 一样的，但是有两个 key，使用 <code>stringRedisTemplate.opsForHash()</code> 可以获取 <code>HashOperations&lt;String, Object, Object&gt;</code> 对象。比如我们要存储订单信息，所有订单信息都放在 order 下，针对不同用户的订单实体，可以通过用户的 id 来区分，这就相当于两个 key 了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set redis: hash类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filedKey filedkey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHash</span><span class="params">(String key, String filedKey, String value)</span></span>&#123;</span><br><span class="line">        HashOperations&lt;String, Object, Object&gt; hashOperations = stringRedisTemplate.opsForHash();</span><br><span class="line">        hashOperations.put(key,filedKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get redis: hash类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filedkey filedkey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHash</span><span class="params">(String key, String filedkey)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String) stringRedisTemplate.opsForHash().get(key, filedkey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，hash 和 string 没啥两样，只不过多了个参数，Spring Boot 中操作 redis 非常简单方便。来测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course14ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Course14ApplicationTests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试redis的hash类型</span></span><br><span class="line">        redisService.setHash(<span class="string">"user"</span>, <span class="string">"name"</span>, JSON.toJSONString(user));</span><br><span class="line">        logger.info(<span class="string">"用户姓名：&#123;&#125;"</span>, redisService.getHash(<span class="string">"user"</span>,<span class="string">"name"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-redis-list-类型"><a href="#3-3-3-redis-list-类型" class="headerlink" title="3.3.3 redis:list 类型"></a>3.3.3 redis:list 类型</h4><p>使用 <code>stringRedisTemplate.opsForList()</code> 可以获取 <code>ListOperations&lt;String, String&gt; listOperations</code>  redis 列表对象，该列表是个简单的字符串列表，可以支持从左侧添加，也可以支持从右侧添加，一个列表最多包含 2 ^ 32 -1 个元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set redis:list类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setList</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line">        ListOperations&lt;String, String&gt; listOperations = stringRedisTemplate.opsForList();</span><br><span class="line">        <span class="keyword">return</span> listOperations.leftPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get redis:list类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getList</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForList().range(key, start, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这些 api 都是一样的形式，方便记忆也方便使用。具体的 api 细节我就不展开了，大家可以自己看 api 文档。其实，这些 api 根据参数和返回值也能知道它们是做什么用的。来测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Course14ApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Course14ApplicationTests<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试redis的list类型</span></span><br><span class="line">        redisService.setList(<span class="string">"list"</span>, <span class="string">"football"</span>);</span><br><span class="line">        redisService.setList(<span class="string">"list"</span>, <span class="string">"basketball"</span>);</span><br><span class="line">        List&lt;String&gt; valList = redisService.getList(<span class="string">"list"</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(String value :valList)&#123;</span><br><span class="line">            logger.info(<span class="string">"list中有：&#123;&#125;"</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结-6"><a href="#4-总结-6" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本节主要介绍了 redis 的使用场景、安装过程，以及 Spring Boot 中集成 redis 的详细步骤。在实际项目中，通常都用 redis 作为缓存，在查询数据库的时候，会先从 redis 中查找，如果有信息，则从 redis 中取；如果没有，则从数据库中查，并且同步到 redis 中，下次 redis 中就有了。更新和删除也是如此，都需要同步到 redis。redis 在高并发场景下运用的很多。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第15课：-Spring-Boot中集成ActiveMQ"><a href="#第15课：-Spring-Boot中集成ActiveMQ" class="headerlink" title="第15课： Spring Boot中集成ActiveMQ"></a>第15课： Spring Boot中集成ActiveMQ</h1><h2 id="1-JMS-和-ActiveMQ-介绍"><a href="#1-JMS-和-ActiveMQ-介绍" class="headerlink" title="1. JMS 和 ActiveMQ 介绍"></a>1. JMS 和 ActiveMQ 介绍</h2><h3 id="1-1-JMS-是啥"><a href="#1-1-JMS-是啥" class="headerlink" title="1.1 JMS 是啥"></a>1.1 JMS 是啥</h3><p>百度百科的解释：</p><blockquote><p>JMS 即 Java 消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。</p></blockquote><p>JMS 只是接口，不同的提供商或者开源组织对其有不同的实现，ActiveMQ 就是其中之一，它支持JMS，是 Apache 推出的。JMS 中有几个对象模型：</p><blockquote><p>连接工厂：ConnectionFactory<br>JMS连接：Connection<br>JMS会话：Session<br>JMS目的：Destination<br>JMS生产者：Producer<br>JMS消费者：Consumer<br>JMS消息两种类型：点对点和发布/订阅。  </p></blockquote><p>可以看出 JMS 实际上和 JDBC 有点类似，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。本文主要使用 ActiveMQ。</p><h3 id="1-2-ActiveMQ"><a href="#1-2-ActiveMQ" class="headerlink" title="1.2 ActiveMQ"></a>1.2 ActiveMQ</h3><p>ActiveMQ 是 Apache 的一个能力强劲的开源消息总线。ActiveMQ 完全支持JMS1.1和J2EE 1.4规范，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 Java EE 应用中间仍然扮演着特殊的地位。ActiveMQ 用在异步消息的处理上，所谓异步消息即消息发送者无需等待消息接收者的处理以及返回，甚至无需关心消息是否发送成功。   </p><p>异步消息主要有两种目的地形式，队列（queue）和主题（topic），队列用于点对点形式的消息通信，主题用于发布/订阅式的消息通信。本章节主要来学习一下在 Spring Boot 中如何使用这两种形式的消息。</p><h2 id="2-ActiveMQ安装"><a href="#2-ActiveMQ安装" class="headerlink" title="2. ActiveMQ安装"></a>2. ActiveMQ安装</h2><p>使用 ActiveMQ 首先需要去官网下载，官网地址为：<a href="http://activemq.apache.org/" target="_blank" rel="noopener">http://activemq.apache.org/</a><br>本课程使用的版本是 apache-activemq-5.15.3，下载后解压缩会有一个名为 apache-activemq-5.15.3 的文件夹，没错，这就安装好了，非常简单，开箱即用。打开文件夹会看到里面有个 <code>activemq-all-5.15.3.jar</code>，这个 jar 我们是可以加进工程里的，但是使用 maven 的话，这个 jar 我们不需要。</p><p>在使用 ActiveMQ 之前，首先得先启动，刚才解压后的目录中有个 bin 目录，里面有 win32 和 win64 两个目录，根据自己电脑选择其中一个打开运行里面的 activemq.bat 即可启动 ActiveMQ。<br>消息生产者生产消息发布到queue中，然后消息消费者从queue中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费<br>启动完成后，在浏览器中输入 <code>http://127.0.0.1:8161/admin/</code> 来访问 ActiveMQ 的服务器，用户名和密码是 admin/admin。如下：</p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/cfb9c460-aa94-11e8-888f-df33be8ed191"  alt="activemq"></p><p>我们可以看到有 Queues 和 Topics 这两个选项，这两个选项分别是点对点消息和发布/订阅消息的查看窗口。何为点对点消息和发布/订阅消息呢？</p><p>点对点消息：消息生产者生产消息发布到 queue 中，然后消息消费者从 queue 中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue 中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue 支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费。</p><p>发布/订阅消息：消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。下面分析具体的实现方式。</p><h2 id="3-ActiveMQ集成"><a href="#3-ActiveMQ集成" class="headerlink" title="3. ActiveMQ集成"></a>3. ActiveMQ集成</h2><h3 id="3-1-依赖导入和配置"><a href="#3-1-依赖导入和配置" class="headerlink" title="3.1 依赖导入和配置"></a>3.1 依赖导入和配置</h3><p>在 Spring Boot 中集成 ActiveMQ 需要导入如下 starter 依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 application.yml 配置文件中，对 activemq 做一下配置：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">activemq:</span></span><br><span class="line">  <span class="comment"># activemq url</span></span><br><span class="line">    <span class="attr">broker-url:</span> <span class="string">tcp://localhost:61616</span></span><br><span class="line">    <span class="attr">in-memory:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">      <span class="comment"># 如果此处设置为true，需要添加activemq-pool的依赖包，否则会自动配置失败，无法注入JmsMessagingTemplate</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="3-2-Queue-和-Topic-的创建"><a href="#3-2-Queue-和-Topic-的创建" class="headerlink" title="3.2 Queue 和 Topic 的创建"></a>3.2 Queue 和 Topic 的创建</h3><p>首先我们需要创建两种消息 Queue 和 Topic，这两种消息的创建，我们放到 ActiveMqConfig 中来创建，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * activemq的配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布/订阅模式队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_NAME = <span class="string">"activemq.topic"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点对点模式队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"activemq.queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">topic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQTopic(TOPIC_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQQueue(QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出创建 Queue 和 Topic 两种消息，分别使用 <code>new ActiveMQQueue</code> 和 <code>new ActiveMQTopic</code> 来创建，分别跟上对应消息的名称即可。这样在其他地方就可以直接将这两种消息作为组件注入进来了。</p><h3 id="3-3-消息的发送接口"><a href="#3-3-消息的发送接口" class="headerlink" title="3.3 消息的发送接口"></a>3.3 消息的发送接口</h3><p>在 Spring Boot 中，我们只要注入 JmsMessagingTemplate 模板即可快速发送消息，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息发送者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Destination destination, String msg)</span> </span>&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(destination, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>convertAndSend</code> 方法中第一个参数是消息发送的目的地，第二个参数是具体的消息内容。</p><h3 id="3-4-点对点消息生产与消费"><a href="#3-4-点对点消息生产与消费" class="headerlink" title="3.4 点对点消息生产与消费"></a>3.4 点对点消息生产与消费</h3><h4 id="3-4-1-点对点消息的生产"><a href="#3-4-1-点对点消息的生产" class="headerlink" title="3.4.1 点对点消息的生产"></a>3.4.1 点对点消息的生产</h4><p>消息的生产，我们放到 Controller 中来做，由于上面已经生成了 Queue 消息的组件，所以在 Controller 中我们直接注入进来即可。然后调用上文的消息发送方法 <code>sendMessage</code> 即可成功生产一条消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/activemq"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ActiveMqController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MsgProducer producer;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Destination queue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/send/queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendQueueMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"===开始发送点对点消息==="</span>);</span><br><span class="line">        producer.sendMessage(queue, <span class="string">"Queue: hello activemq!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-点对点消息的消费"><a href="#3-4-2-点对点消息的消费" class="headerlink" title="3.4.2 点对点消息的消费"></a>3.4.2 点对点消息的消费</h4><p>点对点消息的消费很简单，只要我们指定目的地即可，jms 监听器一直在监听是否有消息过来，如果有，则消费。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收点对点消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = ActiveMqConfig.QUEUE_NAME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveQueueMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的消息为："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，使用 <code>@JmsListener</code> 注解来指定要监听的目的地，在消息接收方法内部，我们可以根据具体的业务需求做相应的逻辑处理即可。</p><h4 id="3-4-3-测试一下"><a href="#3-4-3-测试一下" class="headerlink" title="3.4.3 测试一下"></a>3.4.3 测试一下</h4><p>启动项目，在浏览器中输入：<code>http://localhost:8081/activemq/send/queue</code>，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">收到的消息为：Queue: hello activemq!</span><br></pre></td></tr></table></figure><h3 id="3-5-发布-订阅消息的生产和消费"><a href="#3-5-发布-订阅消息的生产和消费" class="headerlink" title="3.5 发布/订阅消息的生产和消费"></a>3.5 发布/订阅消息的生产和消费</h3><h4 id="3-5-1-发布-订阅消息的生产"><a href="#3-5-1-发布-订阅消息的生产" class="headerlink" title="3.5.1 发布/订阅消息的生产"></a>3.5.1 发布/订阅消息的生产</h4><p>和点对点消息一样，我们注入 topic 并调用 producer 的 <code>sendMessage</code> 方法即可发送订阅消息，如下，不再赘述：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/activemq"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ActiveMqController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MsgProducer producer;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Destination topic;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/send/topic"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendTopicMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"===开始发送订阅消息==="</span>);</span><br><span class="line">        producer.sendMessage(topic, <span class="string">"Topic: hello activemq!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-2-发布-订阅消息的消费"><a href="#3-5-2-发布-订阅消息的消费" class="headerlink" title="3.5.2 发布/订阅消息的消费"></a>3.5.2 发布/订阅消息的消费</h4><p>发布/订阅消息的消费和点对点不同，订阅消息支持多个消费者一起消费。其次，Spring Boot 中默认的时点对点消息，所以在使用 topic 时，会不起作用，我们需要在配置文件 application.yml 中添加一个配置：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jms:</span></span><br><span class="line">    <span class="attr">pub-sub-domain:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>该配置是 false 的话，则为点对点消息，也是 Spring Boot 默认的。这样是可以解决问题，但是如果这样配置的话，上面提到的点对点消息又不能正常消费了。所以二者不可兼得，这并非一个好的解决办法。</p><p>比较好的解决办法是，我们定义一个工厂，<code>@JmsListener</code> 注解默认只接收 queue 消息，如果要接收 topic 消息，需要设置一下 containerFactory。我们还在上面的那个 ActiveMqConfig 配置类中添加：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * activemq的配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JmsListener注解默认只接收queue消息,如果要接收topic消息,需要设置containerFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JmsListenerContainerFactory <span class="title">topicListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 相当于在application.yml中配置：spring.jms.pub-sub-domain=true</span></span><br><span class="line">        factory.setPubSubDomain(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样的配置之后，我们在消费的时候，在 <code>@JmsListener</code> 注解中指定这个容器工厂即可消费 topic 消息。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Topic消息消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收订阅消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = ActiveMqConfig.TOPIC_NAME, containerFactory = <span class="string">"topicListenerContainer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveTopicMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的消息为："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定 containerFactory 属性为上面我们自己配置的 topicListenerContainer 即可。由于 topic 消息可以多个消费，所以该消费的类可以拷贝几个一起测试一下，这里我就不贴代码了，可以参考我的源码测试。</p><h4 id="3-5-3-测试一下"><a href="#3-5-3-测试一下" class="headerlink" title="3.5.3 测试一下"></a>3.5.3 测试一下</h4><p>启动项目，在浏览器中输入：<code>http://localhost:8081/activemq/send/topic</code>，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">收到的消息为：Topic: hello activemq!</span><br><span class="line">收到的消息为：Topic: hello activemq!</span><br></pre></td></tr></table></figure><h2 id="4-总结-7"><a href="#4-总结-7" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本章主要介绍了 jms 和 activemq 的相关概念、activemq 的安装与启动。详细分析了 Spring Boot 中点对点消息和发布/订阅消息两种方式的配置、消息生产和消费方式。ActiveMQ 是能力强劲的开源消息总线，在异步消息的处理上很有用，希望大家好好消化一下。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第16课：Spring-Boot中集成-Shiro"><a href="#第16课：Spring-Boot中集成-Shiro" class="headerlink" title="第16课：Spring Boot中集成 Shiro"></a>第16课：Spring Boot中集成 Shiro</h1><p>Shiro 是一个强大、简单易用的 Java 安全框架，主要用来更便捷的认证，授权，加密，会话管等等，可为任何应用提供安全保障。本课程主要来介绍 Shiro 的认证和授权功能。</p><h2 id="1-Shiro-三大核心组件"><a href="#1-Shiro-三大核心组件" class="headerlink" title="1. Shiro 三大核心组件"></a>1. Shiro 三大核心组件</h2><p>Shiro 有三大核心的组件：<code>Subject</code>、<code>SecurityManager</code> 和 <code>Realm</code>。先来看一下它们之间的关系。</p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/2dd0f5f0-af4a-11e8-a51c-93c39f2785b1"  alt="三大核心组件的关系"></p><ol><li>Subject：认证主体。它包含两个信息：Principals 和 Credentials。看一下这两个信息具体是什么。<blockquote><p>Principals：身份。可以是用户名，邮件，手机号码等等，用来标识一个登录主体身份；<br>Credentials：凭证。常见有密码，数字证书等等。</p></blockquote></li></ol><p>说白了，就是需要认证的东西，最常见的就是用户名密码了，比如用户在登录的时候，Shiro 需要去进行身份认证，就需要 Subject 认证主体。</p><ol start="2"><li><p>SecurityManager：安全管理员。这是 Shiro 架构的核心，它就像 Shiro 内部所有原件的保护伞一样。我们在项目中一般都会配置 SecurityManager，开发人员大部分精力主要是在 Subject 认证主体上面。我们在与 Subject 进行交互的时候，实际上是 SecurityManager 在背后做一些安全操作。</p></li><li><p>Realms：Realms 是一个域，它是连接 Shiro 和具体应用的桥梁，当需要与安全数据交互的时候，比如用户账户、访问控制等，Shiro 就会从一个或多个 Realms 中去查找。我们一般会自己定制 Realm，这在下文会详细说明。</p></li></ol><h2 id="1-Shiro-身份和权限认证"><a href="#1-Shiro-身份和权限认证" class="headerlink" title="1. Shiro 身份和权限认证"></a>1. Shiro 身份和权限认证</h2><h3 id="1-2-Shiro-身份认证"><a href="#1-2-Shiro-身份认证" class="headerlink" title="1.2 Shiro 身份认证"></a>1.2 Shiro 身份认证</h3><p>我们来分析一下 Shiro 身份认证的过程，看一下官方的一个认证图：</p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/f21c53a0-af4f-11e8-a51c-93c39f2785b1"  alt="认证过程"></p><p>Step1：应用程序代码在调用 <code>Subject.login(token)</code> 方法后，传入代表最终用户的身份和凭证的 AuthenticationToken 实例 token。 </p><p>Step2：将 Subject 实例委托给应用程序的 SecurityManager（Shiro的安全管理）来开始实际的认证工作。这里开始真正的认证工作了。 </p><p>Step3，4，5：然后 SecurityManager 就会根据具体的 realm 去进行安全认证了。 从图中可以看出，realm 可以自定义（Custom Realm）。</p><h3 id="1-3-Shiro-权限认证"><a href="#1-3-Shiro-权限认证" class="headerlink" title="1.3 Shiro 权限认证"></a>1.3 Shiro 权限认证</h3><p>权限认证，也就是访问控制，即在应用中控制谁能访问哪些资源。在权限认证中，最核心的三个要素是：权限，角色和用户。</p><blockquote><p>权限（permission）：即操作资源的权利，比如访问某个页面，以及对某个模块的数据的添加，修改，删除，查看的权利；<br>角色（role）：指的是用户担任的的角色，一个角色可以有多个权限；<br>用户（user）：在 Shiro 中，代表访问系统的用户，即上面提到的 Subject 认证主体。</p></blockquote><p>它们之间的的关系可以用下图来表示： </p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/44a68bc0-af75-11e8-85ef-dd986da3511e"  alt="用户、角色和权限的关系"></p><p>一个用户可以有多个角色，而不同的角色可以有不同的权限，也可由有相同的权限。比如说现在有三个角色，1是普通角色，2也是普通角色，3是管理员，角色1只能查看信息，角色2只能添加信息，管理员都可以，而且还可以删除信息，类似于这样。</p><h2 id="2-Spring-Boot-集成-Shiro-过程"><a href="#2-Spring-Boot-集成-Shiro-过程" class="headerlink" title="2. Spring Boot 集成 Shiro 过程"></a>2. Spring Boot 集成 Shiro 过程</h2><h3 id="2-1-依赖导入-2"><a href="#2-1-依赖导入-2" class="headerlink" title="2.1 依赖导入"></a>2.1 依赖导入</h3><p>Spring Boot 2.0.3 集成 Shiro 需要导入如下 starter 依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-数据库表数据初始化"><a href="#2-2-数据库表数据初始化" class="headerlink" title="2.2 数据库表数据初始化"></a>2.2 数据库表数据初始化</h3><p>这里主要涉及到三张表：用户表、角色表和权限表，其实在 demo 中，我们完全可以自己模拟一下，不用建表，但是为了更加接近实际情况，我们还是加入 mybatis，来操作数据库。下面是数据库表的脚本。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`rolename`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色名称'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'用户主键'</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'外键关联role表'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`role_id`</span> (<span class="string">`role_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`t_user_ibfk_1`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`role_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`t_role`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_permission`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`permissionname`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'权限名'</span>,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'外键关联role'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`role_id`</span> (<span class="string">`role_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`t_permission_ibfk_1`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`role_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`t_role`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><p>其中，t_user，t_role 和 t_permission，分别存储用户信息，角色信息和权限信息，表建立好了之后，我们往表里插入一些测试数据。<br>t_user 表：<br>|id|username|password|role_id|<br>|:–:|:–:|:–:|:–:|<br>|1|csdn1|123456|1|<br>|2|csdn2|123456|2|<br>|3|csdn3|123456|3|</p><p>t_role 表：<br>|id|rolename|<br>|:–:|:–:|<br>|1|admin|<br>|2|teacher|<br>|3|student|</p><p>t_permission 表：<br>|id|permissionname|role_id|<br>|:–:|:–:|:–:|<br>|1|<code>user:*</code>|1|<br>|2|<code>student:*</code>|2|</p><p>解释一下这里的权限：<code>user:*</code>表示权限可以是 <code>user:create</code> 或者其他，<code>*</code> 处表示一个占位符，我们可以自己定义，具体的会在下文 Shiro 配置那里说明。</p><h3 id="2-2-自定义-Realm"><a href="#2-2-自定义-Realm" class="headerlink" title="2.2 自定义 Realm"></a>2.2 自定义 Realm</h3><p>有了数据库表和数据之后，我们开始自定义 realm，自定义 realm 需要继承 AuthorizingRealm 类，因为该类封装了很多方法，它也是一步步继承自 Realm 类的，继承了 AuthorizingRealm 类后，需要重写两个方法：</p><blockquote><p><code>doGetAuthenticationInfo()</code> 方法：用来验证当前登录的用户，获取认证信息<br><code>doGetAuthorizationInfo()</code> 方法：用来为当前登陆成功的用户授予权限和角色</p></blockquote><p>具体实现如下，相关的解释我放在代码的注释中，这样更加方便直观：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义realm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取用户名</span></span><br><span class="line">        String username = (String) principalCollection.getPrimaryPrincipal();</span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        <span class="comment">// 给该用户设置角色，角色信息存在t_role表中取</span></span><br><span class="line">        authorizationInfo.setRoles(userService.getRoles(username));</span><br><span class="line">        <span class="comment">// 给该用户设置权限，权限信息存在t_permission表中取</span></span><br><span class="line">        authorizationInfo.setStringPermissions(userService.getPermissions(username));</span><br><span class="line">        <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">// 根据token获取用户名，如果您不知道该该token怎么来的，先可以不管，下文会解释</span></span><br><span class="line">        String username = (String) authenticationToken.getPrincipal();</span><br><span class="line">        <span class="comment">// 根据用户名从数据库中查询该用户</span></span><br><span class="line">        User user = userService.getByUsername(username);</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 把当前用户存到session中</span></span><br><span class="line">            SecurityUtils.getSubject().getSession().setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">            <span class="comment">// 传入用户名和密码进行身份认证，并返回认证信息</span></span><br><span class="line">            AuthenticationInfo authcInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), <span class="string">"myRealm"</span>);</span><br><span class="line">            <span class="keyword">return</span> authcInfo;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面两个方法中可以看出：验证身份的时候是根据用户输入的用户名先从数据库中查出该用户名对应的用户，这时候并没有涉及到密码，也就是说到这一步的时候，即使用户输入的密码不对，也是可以查出来该用户的，然后将该用户的正确信息封装到 authcInfo 中返回给 Shiro，接下来就是Shiro的事了，它会根据这里面的真实信息与用户前台输入的用户名和密码进行校验， 这个时候也要校验密码了，如果校验通过就让用户登录，否则跳转到指定页面。同理，权限验证的时候也是先根据用户名从数据库中获取与该用户名有关的角色和权限，然后封装到 authorizationInfo 中返回给 Shiro。</p><h3 id="2-3-Shiro-配置"><a href="#2-3-Shiro-配置" class="headerlink" title="2.3 Shiro 配置"></a>2.3 Shiro 配置</h3><p>自定义的 realm 写好了，接下来需要对 Shiro 进行配置了。我们主要配置三个东西：自定义 realm、安全管理器 SecurityManager 和 Shiro 过滤器。如下：</p><p>配置自定义 realm：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShiroConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入自定义的realm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> MyRealm</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRealm <span class="title">myAuthRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyRealm myRealm = <span class="keyword">new</span> MyRealm();</span><br><span class="line">        logger.info(<span class="string">"====myRealm注册完成====="</span>);</span><br><span class="line">        <span class="keyword">return</span> myRealm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置安全管理器 SecurityManager：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShiroConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入安全管理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SecurityManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将自定义realm加进来</span></span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(myAuthRealm());</span><br><span class="line">        logger.info(<span class="string">"====securityManager注册完成===="</span>);</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 SecurityManager 时，需要将上面的自定义 realm 添加进来，这样的话 Shiro 才会走到自定义的 realm 中。</p><p>配置 Shiro 过滤器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShiroConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入Shiro过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> securityManager 安全管理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ShiroFilterFactoryBean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilter</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义shiroFactoryBean</span></span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean=<span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置自定义的securityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置默认登录的url，身份认证失败会访问该url</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">"/login"</span>);</span><br><span class="line">        <span class="comment">// 设置成功之后要跳转的链接</span></span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(<span class="string">"/success"</span>);</span><br><span class="line">        <span class="comment">// 设置未授权界面，权限认证失败会访问该url</span></span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">"/unauthorized"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LinkedHashMap是有序的，进行顺序拦截器配置</span></span><br><span class="line">        Map&lt;String,String&gt; filterChainMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon表示放行</span></span><br><span class="line">        filterChainMap.put(<span class="string">"/css/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainMap.put(<span class="string">"/imgs/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainMap.put(<span class="string">"/js/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainMap.put(<span class="string">"/swagger-*/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainMap.put(<span class="string">"/swagger-ui.html/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        <span class="comment">// 登录url 放行</span></span><br><span class="line">        filterChainMap.put(<span class="string">"/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// “/user/admin” 开头的需要身份认证，authc表示要身份认证</span></span><br><span class="line">        filterChainMap.put(<span class="string">"/user/admin*"</span>, <span class="string">"authc"</span>);</span><br><span class="line">        <span class="comment">// “/user/student” 开头的需要角色认证，是“admin”才允许</span></span><br><span class="line">        filterChainMap.put(<span class="string">"/user/student*/**"</span>, <span class="string">"roles[admin]"</span>);</span><br><span class="line">        <span class="comment">// “/user/teacher” 开头的需要权限认证，是“user:create”才允许</span></span><br><span class="line">        filterChainMap.put(<span class="string">"/user/teacher*/**"</span>, <span class="string">"perms[\"user:create\"]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置logout过滤器</span></span><br><span class="line">        filterChainMap.put(<span class="string">"/logout"</span>, <span class="string">"logout"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置shiroFilterFactoryBean的FilterChainDefinitionMap</span></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap);</span><br><span class="line">        logger.info(<span class="string">"====shiroFilterFactoryBean注册完成===="</span>);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 Shiro 过滤器时会传入一个安全管理器，可以看出，这是一环套一环，reaml -&gt; SecurityManager -&gt; filter。在过滤器中，我们需要定义一个 shiroFactoryBean，然后将 SecurityManager 添加进来，结合上面代码可以看出，要配置的东西主要有：</p><blockquote><p>默认登录的 url：身份认证失败会访问该 url<br>认证成功之后要跳转的 url<br>权限认证失败会访问该 url<br>需要拦截或者放行的 url：这些都放在一个 map 中</p></blockquote><p>从上述代码中可以看出，在 map 中，针对不同的 url，有不同的权限要求，这里总结一下常用的几个权限。<br>|Filter|说明|<br>|:–:|:–:|<br>|anon|开放权限，可以理解为匿名用户或游客，可以直接访问的|<br>|authc|需要身份认证的|<br>|logout|注销，执行后会直接跳转到 <code>shiroFilterFactoryBean.setLoginUrl();</code> 设置的 url，即登录页面|<br>|roles[admin]|参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[“admin，user”]，当有多个参数时必须每个参数都通过才算通过|<br>|perms[user]|参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user, admin”]，当有多个参数时必须每个参数都通过才算通过|</p><h3 id="2-4-使用-Shiro-进行认证"><a href="#2-4-使用-Shiro-进行认证" class="headerlink" title="2.4 使用 Shiro 进行认证"></a>2.4 使用 Shiro 进行认证</h3><p>到这里，我们对 Shiro 的准备工作都做完了，接下来开始使用 Shiro 进行认证工作。我们首先来设计几个接口：</p><blockquote><p>接口一： 使用 <code>http://localhost:8080/user/admin</code> 来验证身份认证<br>接口二： 使用 <code>http://localhost:8080/user/student</code> 来验证角色认证<br>接口三： 使用 <code>http://localhost:8080/user/teacher</code> 来验证权限认证<br>接口四： 使用 <code>http://localhost:8080/user/login</code> 来实现用户登录</p></blockquote><p>然后来一下认证的流程：</p><blockquote><p>流程一： 直接访问接口一（此时还未登录），认证失败，跳转到 login.html 页面让用户登录，登录会请求接口四，实现用户登录功能，此时 Shiro 已经保存了用户信息了。<br>流程二： 再次访问接口一（此时用户已经登录），认证成功，跳转到 success.html 页面，展示用户信息。<br>流程三： 访问接口二，测试角色认证是否成功。<br>流程四： 访问接口三，测试权限认证是否成功。</p></blockquote><h4 id="2-4-1-身份、角色、权限认证接口"><a href="#2-4-1-身份、角色、权限认证接口" class="headerlink" title="2.4.1 身份、角色、权限认证接口"></a>2.4.1 身份、角色、权限认证接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份认证测试接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/admin"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">admin</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Object user = request.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 角色认证测试接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/student"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">student</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权限认证测试接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/teacher"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">teacher</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个接口很简单，直接返回到指定页面展示即可，只要认证成功就会正常跳转，如果认证失败，就会跳转到上文 ShrioConfig 中配置的页面进行展示。</p><h4 id="2-4-2-用户登录接口"><a href="#2-4-2-用户登录接口" class="headerlink" title="2.4.2 用户登录接口"></a>2.4.2 用户登录接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户登录接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(User user, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据用户名和密码创建token</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(user.getUsername(), user.getPassword());</span><br><span class="line">        <span class="comment">// 获取subject认证主体</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 开始认证，这一步会跳到我们自定义的realm中</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            request.getSession().setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            request.getSession().setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">            request.setAttribute(<span class="string">"error"</span>, <span class="string">"用户名或密码错误！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点分析一下这个登录接口，首先会根据前端传过来的用户名和密码，创建一个 token，然后使用 SecurityUtils 来创建一个认证主体，接下来开始调用 <code>subject.login(token)</code> 开始进行身份认证了，注意这里传了刚刚创建的 token，就如注释中所述，这一步会跳转到我们自定义的 realm 中，进入 <code>doGetAuthenticationInfo</code> 方法，所以到这里，您就会明白该方法中那个参数 token 了。然后就是上文分析的那样，开始进行身份认证。</p><h4 id="2-4-3-测试一下"><a href="#2-4-3-测试一下" class="headerlink" title="2.4.3 测试一下"></a>2.4.3 测试一下</h4><p>最后，启动项目，测试一下：<br>浏览器请求 <code>http://localhost:8080/user/admin</code> 会进行身份认证，因为此时未登录，所以会跳转到 IndexController 中的 <code>/login</code> 接口，然后跳转到 <code>login.html</code> 页面让我们登录，使用用户名密码为 csdn/123456 登录之后，我们在浏览器中请求 <code>http://localhost:8080/user/student</code> 接口，会进行角色认证，因为数据库中 csdn1 的用户角色是 admin，所以和配置中的吻合，认证通过；我们再请求 <code>http://localhost:8080/user/teacher</code> 接口，会进行权限认证，因为数据库中 csdn1 的用户权限为 <code>user:*</code>，满足配置中的 <code>user:create</code>，所以认证通过。</p><p>接下来，我们点退出，系统会注销重新让我们登录，我们使用 csdn2 这个用户来登录，重复上述操作，当在进行角色认证和权限认证这两步时，就认证不通过了，因为数据库中 csdn2 这个用户存的角色和权限与配置中的不同，所以认证不通过。</p><h2 id="3-总结-2"><a href="#3-总结-2" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本节主要介绍了 Shiro 安全框架与 Spring Boot 的整合。先介绍了 Shiro 的三大核心组件已经它们的作用；然后介绍了 Shiro 的身份认证、角色认证和权限认证；最后结合代码，详细介绍了 Spring Boot 中是如何整合 Shiro 的，并设计了一套测试流程，逐步分析 Shiro 的工作流程和原理，让读者更直观地体会出 Shiro 的整套工作流程。Shiro 使用的很广泛，希望读者将其掌握，并能运用到实际项目中。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第17课：Spring-Boot中集成Lucence"><a href="#第17课：Spring-Boot中集成Lucence" class="headerlink" title="第17课：Spring Boot中集成Lucence"></a>第17课：Spring Boot中集成Lucence</h1><h2 id="1-Lucence-和全文检索"><a href="#1-Lucence-和全文检索" class="headerlink" title="1. Lucence 和全文检索"></a>1. Lucence 和全文检索</h2><p>Lucene 是什么？看一下百度百科：</p><blockquote><p>Lucene是一套用于全文检索和搜寻的开源程式库，由 Apache 软件基金会支持和提供。Lucene 提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言，Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。——《百度百科》</p></blockquote><h3 id="1-1-全文检索"><a href="#1-1-全文检索" class="headerlink" title="1.1 全文检索"></a>1.1 全文检索</h3><p>这里提到了全文检索的概念，我们先来分析一下什么是全文检索，理解了全文检索之后，再理解 Lucene 的原理就非常简单了。  </p><p>何为全文检索？举个例子，比如现在要在一个文件中查找某个字符串，最直接的想法就是从头开始检索，查到了就OK，这种对于小数据量的文件来说，很实用，但是对于大数据量的文件来说，就有点吃力了。或者说找包含某个字符串的文件，也是这样，如果在一个拥有几十个 G 的硬盘中找那效率可想而知，是很低的。   </p><p>文件中的数据是属于非结构化数据，也就是说它没有什么结构可言，要解决上面提到的效率问题，首先我们得将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对这些有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这就叫全文搜索。即先建立索引，再对索引进行搜索的过程。 </p><h3 id="1-2-Lucene-建立索引的方式"><a href="#1-2-Lucene-建立索引的方式" class="headerlink" title="1.2 Lucene 建立索引的方式"></a>1.2 Lucene 建立索引的方式</h3><p>那么 Lucene 中是如何建立索引的呢？假设现在有两篇文章，内容如下：</p><blockquote><p>文章1的内容为：Tom lives in Guangzhou, I live in Guangzhou too.<br>文章2的内容为：He once lived in Shanghai.</p></blockquote><p>首先第一步是将文档传给分词组件（Tokenizer），分词组件会将文档分成一个个单词，并去除标点符号和停词。所谓的停词指的是没有特别意义的词，比如英文中的 a，the，too 等。经过分词后，得到词元（Token） 。如下：</p><blockquote><p>文章1经过分词后的结果：<code>[Tom]</code> <code>[lives]</code> <code>[Guangzhou]</code> <code>[I]</code> <code>[live]</code> <code>[Guangzhou]</code><br>文章2经过分词后的结果：<code>[He]</code> <code>[lives]</code> <code>[Shanghai]</code></p></blockquote><p>然后将词元传给语言处理组件（Linguistic Processor），对于英语，语言处理组件一般会将字母变为小写，将单词缩减为词根形式，如 ”lives” 到 ”live” 等，将单词转变为词根形式，如 ”drove” 到 ”drive” 等。然后得到词（Term）。如下：</p><blockquote><p>文章1经过处理后的结果：<code>[tom]</code> <code>[live]</code> <code>[guangzhou]</code> <code>[i]</code> <code>[live]</code> <code>[guangzhou]</code><br>文章2经过处理后的结果：<code>[he]</code> <code>[live]</code> <code>[shanghai]</code></p></blockquote><p>最后将得到的词传给索引组件（Indexer），索引组件经过处理，得到下面的索引结构：</p><table><thead><tr><th align="center">关键词</th><th align="center">文章号[出现频率]</th><th align="center">出现位置</th></tr></thead><tbody><tr><td align="center">guangzhou</td><td align="center">1[2]</td><td align="center">3,6</td></tr><tr><td align="center">he</td><td align="center">2[1]</td><td align="center">1</td></tr><tr><td align="center">i</td><td align="center">1[1]</td><td align="center">4</td></tr><tr><td align="center">live</td><td align="center">1[2],2[1]</td><td align="center">2,5,2</td></tr><tr><td align="center">shanghai</td><td align="center">2[1]</td><td align="center">3</td></tr><tr><td align="center">tom</td><td align="center">1[1]</td><td align="center">1</td></tr></tbody></table><p>以上就是Lucene 索引结构中最核心的部分。它的关键字是按字符顺序排列的，因此 Lucene 可以用二元搜索算法快速定位关键词。实现时 Lucene 将上面三列分别作为词典文件（Term Dictionary）、频率文件（frequencies）和位置文件（positions）保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。<br>搜索的过程是先对词典二元查找、找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果，然后就可以在具体的文章中根据出现位置找到该词了。所以 Lucene 在第一次建立索引的时候可能会比较慢，但是以后就不需要每次都建立索引了，就快了。</p><p>理解了 Lucene 的分词原理，接下来我们在 Spring Boot 中集成 Lucene 并实现索引和搜索的功能。</p><h2 id="2-Spring-Boot-中集成-Lucence"><a href="#2-Spring-Boot-中集成-Lucence" class="headerlink" title="2. Spring Boot 中集成 Lucence"></a>2. Spring Boot 中集成 Lucence</h2><h3 id="2-1-依赖导入-3"><a href="#2-1-依赖导入-3" class="headerlink" title="2.1 依赖导入"></a>2.1 依赖导入</h3><p>首先需要导入 Lucene 的依赖，它的依赖有好几个，如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Lucence核心包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Lucene查询解析包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-queryparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 常规的分词（英文） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-analyzers-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--支持分词高亮  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-highlighter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--支持中文分词  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-analyzers-smartcn<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后一个依赖是用来支持中文分词的，因为默认是支持英文的。那个高亮的分词依赖是最后我要做一个搜索，然后将搜到的内容高亮显示，模拟当前互联网上的做法，大家可以运用到实际项目中去。</p><h3 id="2-2-快速入门"><a href="#2-2-快速入门" class="headerlink" title="2.2 快速入门"></a>2.2 快速入门</h3><p>根据上文的分析，全文检索有两个步骤，先建立索引，再检索。所以为了测试这个过程，我新建两个 java 类，一个用来建立索引的，另一个用来检索。</p><h4 id="2-2-1-建立索引"><a href="#2-2-1-建立索引" class="headerlink" title="2.2.1 建立索引"></a>2.2.1 建立索引</h4><p>我们自己弄几个文件，放到 <code>D:\lucene\data</code> 目录下，新建一个 Indexer 类来实现建立索引功能。首先在构造方法中初始化标准分词器和写索引实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Indexer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写索引实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IndexWriter writer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，实例化IndexWriter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexDir</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Indexer</span><span class="params">(String indexDir)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Directory dir = FSDirectory.open(Paths.get(indexDir));</span><br><span class="line">        <span class="comment">//标准分词器，会自动去掉空格啊，is a the等单词</span></span><br><span class="line">        Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line">        <span class="comment">//将标准分词器配到写索引的配置中</span></span><br><span class="line">        IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(analyzer);</span><br><span class="line">        <span class="comment">//实例化写索引对象</span></span><br><span class="line">        writer = <span class="keyword">new</span> IndexWriter(dir, config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造放发中传一个存放索引的文件夹路径，然后构建标准分词器（这是英文的），再使用标准分词器来实例化写索引对象。接下来就开始建立索引了，我将解释放到代码注释里，方便大家跟进。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 索引指定目录下的所有文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dataDir</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexAll</span><span class="params">(String dataDir)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取该路径下的所有文件</span></span><br><span class="line">    File[] files = <span class="keyword">new</span> File(dataDir).listFiles();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != files) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">//调用下面的indexFile方法，对每个文件进行索引</span></span><br><span class="line">            indexFile(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回索引的文件数</span></span><br><span class="line">    <span class="keyword">return</span> writer.numDocs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 索引指定的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">indexFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"索引文件的路径："</span> + file.getCanonicalPath());</span><br><span class="line">    <span class="comment">//调用下面的getDocument方法，获取该文件的document</span></span><br><span class="line">    Document doc = getDocument(file);</span><br><span class="line">    <span class="comment">//将doc添加到索引中</span></span><br><span class="line">    writer.addDocument(doc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文档，文档里再设置每个字段，就类似于数据库中的一行记录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Document <span class="title">getDocument</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Document doc = <span class="keyword">new</span> Document();</span><br><span class="line">    <span class="comment">//开始添加字段</span></span><br><span class="line">    <span class="comment">//添加内容</span></span><br><span class="line">    doc.add(<span class="keyword">new</span> TextField(<span class="string">"contents"</span>, <span class="keyword">new</span> FileReader(file)));</span><br><span class="line">    <span class="comment">//添加文件名，并把这个字段存到索引文件里</span></span><br><span class="line">    doc.add(<span class="keyword">new</span> TextField(<span class="string">"fileName"</span>, file.getName(), Field.Store.YES));</span><br><span class="line">    <span class="comment">//添加文件路径</span></span><br><span class="line">    doc.add(<span class="keyword">new</span> TextField(<span class="string">"fullPath"</span>, file.getCanonicalPath(), Field.Store.YES));</span><br><span class="line">    <span class="keyword">return</span> doc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就建立好索引了，我们在该类中写一个 main 方法测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//索引保存到的路径</span></span><br><span class="line">        String indexDir = <span class="string">"D:\\lucene"</span>;</span><br><span class="line">        <span class="comment">//需要索引的文件数据存放的目录</span></span><br><span class="line">        String dataDir = <span class="string">"D:\\lucene\\data"</span>;</span><br><span class="line">        Indexer indexer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> indexedNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录索引开始时间</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始构建索引</span></span><br><span class="line">            indexer = <span class="keyword">new</span> Indexer(indexDir);</span><br><span class="line">            indexedNum = indexer.indexAll(dataDir);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != indexer) &#123;</span><br><span class="line">                    indexer.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录索引结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"索引耗时"</span> + (endTime - startTime) + <span class="string">"毫秒"</span>);</span><br><span class="line">        System.out.println(<span class="string">"共索引了"</span> + indexedNum + <span class="string">"个文件"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我搞了两个 tomcat 相关的文件放到 <code>D:\lucene\data</code> 下了，执行完之后，看到控制台输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">索引文件的路径：D:\lucene\data\catalina.properties</span><br><span class="line">索引文件的路径：D:\lucene\data\logging.properties</span><br><span class="line">索引耗时882毫秒</span><br><span class="line">共索引了2个文件</span><br></pre></td></tr></table></figure><p>然后我们去 <code>D:\lucene\</code> 目录下可以看到一些索引文件，这些文件不能删除，删除了就需要重新构建索引，否则没了索引，就无法去检索内容了。</p><p>####2.2.2 检索内容</p><p>上面把这两个文件的索引建立好了，接下来我们就可以写检索程序了，在这两个文件中查找特定的词。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Searcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(String indexDir, String q)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取要查询的路径，也就是索引所在的位置</span></span><br><span class="line">        Directory dir = FSDirectory.open(Paths.get(indexDir));</span><br><span class="line">        IndexReader reader = DirectoryReader.open(dir);</span><br><span class="line">        <span class="comment">//构建IndexSearcher</span></span><br><span class="line">        IndexSearcher searcher = <span class="keyword">new</span> IndexSearcher(reader);</span><br><span class="line">        <span class="comment">//标准分词器，会自动去掉空格啊，is a the等单词</span></span><br><span class="line">        Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line">        <span class="comment">//查询解析器</span></span><br><span class="line">        QueryParser parser = <span class="keyword">new</span> QueryParser(<span class="string">"contents"</span>, analyzer);</span><br><span class="line">        <span class="comment">//通过解析要查询的String，获取查询对象，q为传进来的待查的字符串</span></span><br><span class="line">        Query query = parser.parse(q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录索引开始时间</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//开始查询，查询前10条数据，将记录保存在docs中</span></span><br><span class="line">        TopDocs docs = searcher.search(query, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//记录索引结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"匹配"</span> + q + <span class="string">"共耗时"</span> + (endTime-startTime) + <span class="string">"毫秒"</span>);</span><br><span class="line">        System.out.println(<span class="string">"查询到"</span> + docs.totalHits + <span class="string">"条记录"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出每条查询结果</span></span><br><span class="line">        <span class="keyword">for</span>(ScoreDoc scoreDoc : docs.scoreDocs) &#123;</span><br><span class="line">            <span class="comment">//scoreDoc.doc相当于docID,根据这个docID来获取文档</span></span><br><span class="line">            Document doc = searcher.doc(scoreDoc.doc);</span><br><span class="line">            <span class="comment">//fullPath是刚刚建立索引的时候我们定义的一个字段，表示路径。也可以取其他的内容，只要我们在建立索引时有定义即可。</span></span><br><span class="line">            System.out.println(doc.get(<span class="string">"fullPath"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，这样我们检索的代码就写完了，每一步解释我写在代码中的注释上了，下面写个 main 方法来测试一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String indexDir = <span class="string">"D:\\lucene"</span>;</span><br><span class="line">    <span class="comment">//查询这个字符串</span></span><br><span class="line">    String q = <span class="string">"security"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        search(indexDir, q);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查一下 <code>security</code> 这个字符串，执行一下看控制台打印的结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">匹配security共耗时23毫秒</span><br><span class="line">查询到1条记录</span><br><span class="line">D:\lucene\data\catalina.properties</span><br></pre></td></tr></table></figure><p>可以看出，耗时了23毫秒在两个文件中找到了 security 这个字符串，并输出了文件的名称。上面的代码我写的很详细，这个代码已经比较全了，可以用在生产环境上。</p><h3 id="2-3-中文分词检索高亮实战"><a href="#2-3-中文分词检索高亮实战" class="headerlink" title="2.3 中文分词检索高亮实战"></a>2.3 中文分词检索高亮实战</h3><p>上文已经写了建立索引和检索的代码，但是在实际项目中，我们往往是结合页面做一些查询结果的展示，比如我要查某个关键字，查到了之后，将相关的信息点展示出来，并将查询的关键字高亮等等。这种需求在实际项目中非常常见，而且大多数网站中都会有这种效果。所以这一小节我们就使用 Lucene 来实现这种效果。</p><h4 id="2-3-1-中文分词"><a href="#2-3-1-中文分词" class="headerlink" title="2.3.1 中文分词"></a>2.3.1 中文分词</h4><p>我们新建一个 ChineseIndexer 类来建立中文索引，建立过程和英文索引一样的，不同的地方在于使用的是中文分词器。除此之外，这里我们不用通过读取文件去建立索引，我们模拟一下用字符串来建立，因为在实际项目中，绝大部分情况是获取到一些文本字符串，然后根据一些关键字去查询相关内容等等。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseIndexer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放索引的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Directory dir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备一下用来测试的数据</span></span><br><span class="line">    <span class="comment">//用来标识文档</span></span><br><span class="line">    <span class="keyword">private</span> Integer ids[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String citys[] = &#123;<span class="string">"上海"</span>, <span class="string">"南京"</span>, <span class="string">"青岛"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String descs[] = &#123;</span><br><span class="line">            <span class="string">"上海是个繁华的城市。"</span>,</span><br><span class="line">            <span class="string">"南京是一个文化的城市南京，简称宁，是江苏省会，地处中国东部地区，长江下游，濒江近海。全市下辖11个区，总面积6597平方公里，2013年建成区面积752.83平方公里，常住人口818.78万，其中城镇人口659.1万人。[1-4] “江南佳丽地，金陵帝王州”，南京拥有着6000多年文明史、近2600年建城史和近500年的建都史，是中国四大古都之一，有“六朝古都”、“十朝都会”之称，是中华文明的重要发祥地，历史上曾数次庇佑华夏之正朔，长期是中国南方的政治、经济、文化中心，拥有厚重的文化底蕴和丰富的历史遗存。[5-7] 南京是国家重要的科教中心，自古以来就是一座崇文重教的城市，有“天下文枢”、“东南第一学”的美誉。截至2013年，南京有高等院校75所，其中211高校8所，仅次于北京上海；国家重点实验室25所、国家重点学科169个、两院院士83人，均居中国第三。[8-10] 。"</span>,</span><br><span class="line">            <span class="string">"青岛是一个美丽的城市。"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> indexDir</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">(String indexDir)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        dir = FSDirectory.open(Paths.get(indexDir));</span><br><span class="line">        <span class="comment">// 先调用 getWriter 获取IndexWriter对象</span></span><br><span class="line">        IndexWriter writer = getWriter();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ids.length; i++) &#123;</span><br><span class="line">            Document doc = <span class="keyword">new</span> Document();</span><br><span class="line">            <span class="comment">// 把上面的数据都生成索引，分别用id、city和desc来标识</span></span><br><span class="line">            doc.add(<span class="keyword">new</span> IntField(<span class="string">"id"</span>, ids[i], Field.Store.YES));</span><br><span class="line">            doc.add(<span class="keyword">new</span> StringField(<span class="string">"city"</span>, citys[i], Field.Store.YES));</span><br><span class="line">            doc.add(<span class="keyword">new</span> TextField(<span class="string">"desc"</span>, descs[i], Field.Store.YES));</span><br><span class="line">            <span class="comment">//添加文档</span></span><br><span class="line">            writer.addDocument(doc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//close了才真正写到文档中</span></span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取IndexWriter实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IndexWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用中文分词器</span></span><br><span class="line">        SmartChineseAnalyzer analyzer = <span class="keyword">new</span> SmartChineseAnalyzer();</span><br><span class="line">        <span class="comment">//将中文分词器配到写索引的配置中</span></span><br><span class="line">        IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(analyzer);</span><br><span class="line">        <span class="comment">//实例化写索引对象</span></span><br><span class="line">        IndexWriter writer = <span class="keyword">new</span> IndexWriter(dir, config);</span><br><span class="line">        <span class="keyword">return</span> writer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChineseIndexer().index(<span class="string">"D:\\lucene2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们用 id、city、desc 分别代表 id、城市名称和城市描述，用他们作为关键字来建立索引，后面我们获取内容的时候，主要来获取城市描述。南京的描述我故意写的长一点，因为下文检索的时候，根据不同的关键字会检索到不同部分的信息，有个权重的概念在里面。<br>然后执行一下 main 方法，将索引保存到 <code>D:\lucene2\</code> 中。 </p><h4 id="2-3-2-中文分词查询"><a href="#2-3-2-中文分词查询" class="headerlink" title="2.3.2 中文分词查询"></a>2.3.2 中文分词查询</h4><p>中文分词查询代码逻辑和默认的查询差不多，有一些区别在于，我们需要将查询出来的关键字标红加粗等需要处理，需要计算出一个得分片段，这是什么意思呢？比如我搜索 “南京文化” 跟搜索 “南京文明”，这两个搜索结果应该根据关键字出现的位置，返回的结果不一样才对，这在下文会测试。我们先看一下代码和注释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChineseSearch<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">search</span><span class="params">(String indexDir, String q)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取要查询的路径，也就是索引所在的位置</span></span><br><span class="line">        Directory dir = FSDirectory.open(Paths.get(indexDir));</span><br><span class="line">        IndexReader reader = DirectoryReader.open(dir);</span><br><span class="line">        IndexSearcher searcher = <span class="keyword">new</span> IndexSearcher(reader);</span><br><span class="line">        <span class="comment">//使用中文分词器</span></span><br><span class="line">        SmartChineseAnalyzer analyzer = <span class="keyword">new</span> SmartChineseAnalyzer();</span><br><span class="line">        <span class="comment">//由中文分词器初始化查询解析器</span></span><br><span class="line">        QueryParser parser = <span class="keyword">new</span> QueryParser(<span class="string">"desc"</span>, analyzer);</span><br><span class="line">        <span class="comment">//通过解析要查询的String，获取查询对象</span></span><br><span class="line">        Query query = parser.parse(q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录索引开始时间</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//开始查询，查询前10条数据，将记录保存在docs中</span></span><br><span class="line">        TopDocs docs = searcher.search(query, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//记录索引结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"匹配&#123;&#125;共耗时&#123;&#125;毫秒"</span>, q, (endTime - startTime));</span><br><span class="line">        logger.info(<span class="string">"查询到&#123;&#125;条记录"</span>, docs.totalHits);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不指定参数的话，默认是加粗，即&lt;b&gt;&lt;b/&gt;</span></span><br><span class="line">        SimpleHTMLFormatter simpleHTMLFormatter = <span class="keyword">new</span> SimpleHTMLFormatter(<span class="string">"&lt;b&gt;&lt;font color=red&gt;"</span>,<span class="string">"&lt;/font&gt;&lt;/b&gt;"</span>);</span><br><span class="line">        <span class="comment">//根据查询对象计算得分，会初始化一个查询结果最高的得分</span></span><br><span class="line">        QueryScorer scorer = <span class="keyword">new</span> QueryScorer(query);</span><br><span class="line">        <span class="comment">//根据这个得分计算出一个片段</span></span><br><span class="line">        Fragmenter fragmenter = <span class="keyword">new</span> SimpleSpanFragmenter(scorer);</span><br><span class="line">        <span class="comment">//将这个片段中的关键字用上面初始化好的高亮格式高亮</span></span><br><span class="line">        Highlighter highlighter = <span class="keyword">new</span> Highlighter(simpleHTMLFormatter, scorer);</span><br><span class="line">        <span class="comment">//设置一下要显示的片段</span></span><br><span class="line">        highlighter.setTextFragmenter(fragmenter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出每条查询结果</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(ScoreDoc scoreDoc : docs.scoreDocs) &#123;</span><br><span class="line">            <span class="comment">//scoreDoc.doc相当于docID,根据这个docID来获取文档</span></span><br><span class="line">            Document doc = searcher.doc(scoreDoc.doc);</span><br><span class="line">            logger.info(<span class="string">"city:&#123;&#125;"</span>, doc.get(<span class="string">"city"</span>));</span><br><span class="line">            logger.info(<span class="string">"desc:&#123;&#125;"</span>, doc.get(<span class="string">"desc"</span>));</span><br><span class="line">            String desc = doc.get(<span class="string">"desc"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//显示高亮</span></span><br><span class="line">            <span class="keyword">if</span>(desc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TokenStream tokenStream = analyzer.tokenStream(<span class="string">"desc"</span>, <span class="keyword">new</span> StringReader(desc));</span><br><span class="line">                String summary = highlighter.getBestFragment(tokenStream, desc);</span><br><span class="line">                logger.info(<span class="string">"高亮后的desc:&#123;&#125;"</span>, summary);</span><br><span class="line">                list.add(summary);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一步的注释我写的很详细，在这就不赘述了。接下来我们来测试一下效果。</p><h4 id="2-3-3-测试一下"><a href="#2-3-3-测试一下" class="headerlink" title="2.3.3 测试一下"></a>2.3.3 测试一下</h4><p>这里我们使用 thymeleaf 来写个简单的页面来展示获取到的数据，并高亮展示。在 controller 中我们指定索引的目录和需要查询的字符串，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/lucene"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引所在的目录</span></span><br><span class="line">        String indexDir = <span class="string">"D:\\lucene2"</span>;</span><br><span class="line">        <span class="comment">// 要查询的字符</span></span><br><span class="line"><span class="comment">//        String q = "南京文明";</span></span><br><span class="line">        String q = <span class="string">"南京文化"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = ChineseSearch.search(indexDir, q);</span><br><span class="line">            model.addAttribute(<span class="string">"list"</span>, list);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"result"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回到 result.html 页面，该页面主要来展示一下 model 中的数据即可。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">"desc : $&#123;list&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:utext</span>=<span class="string">"$&#123;desc&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里注意一下，不能使用 <code>th:test</code>，否则字符串中的 html 标签都会被转义，不会被渲染到页面。下面启动服务，在浏览器中输入 <code>http://localhost:8080/lucene/test</code>，测试一下效果，我们搜索的是 “南京文化”。</p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/83b3f810-b377-11e8-88bf-23cb78d1fb4f"  alt="南京文化"></p><p>再将 controller 中的搜索关键字改成 “南京文明”，看下命中的效果。</p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/8ef8a4a0-b377-11e8-911d-27cc5f059829"  alt="南京文明"></p><p>可以看出，不同的关键词，它会计算一个得分片段，也就是说不同的关键字会命中不同位置的内容，然后将关键字根据我们自己设定的形式高亮显示。从结果中可以看出，Lucene 也可以很智能的将关键字拆分命中，这在实际项目中会很好用。</p><h2 id="3-总结-3"><a href="#3-总结-3" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>本节课首先详细的分析了全文检索的理论规则，然后结合 Lucene，系统的讲述了在 Spring Boot 的集成步骤，首先快速带领大家从直观上感受 Lucene 如何建立索引已经如果检索，其次通过中文检索的具体实例，展示了 Lucene 在全文检索中的广泛应用。Lucene 不难，主要就是步骤比较多，代码不用死记硬背，拿到项目中根据实际情况做对应的修改即可。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="第18课：Spring-Boot搭建实际项目开发中的架构"><a href="#第18课：Spring-Boot搭建实际项目开发中的架构" class="headerlink" title="第18课：Spring Boot搭建实际项目开发中的架构"></a>第18课：Spring Boot搭建实际项目开发中的架构</h1><p>前面的课程中，我主要给大家讲解了 Spring Boot 中常用的一些技术点，这些技术点在实际项目中可能不会全部用得到，因为不同的项目可能使用的技术不同，但是希望大家都能掌握如何使用，并能自己根据实际项目中的需求进行相应的扩展。</p><p>不知道大家了不了解单片机，单片机里有个最小系统，这个最小系统搭建好了之后，就可以在此基础上进行人为的扩展。这节课我们要做的就是搭建一个 “Spring Boot 最小系统架构” 。拿着这个架构，可以在此基础上根据实际需求做相应的扩展。</p><p>从零开始搭建一个环境，主要要考虑几点：统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（本文不写该项，因为现在大部分项目都前后端分离了，但是考虑到也还有非前后端分离的项目，所以我在源代码里也加上了 thymeleaf）、持久层的集成、拦截器（这个也是可选的）和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。</p><p>结合前面的课程和以上的这些点，本节课手把手带领大家搭建一个实际项目开发中可用的 Spring Boot 架构。整个项目工程如下图所示，学习的时候，可以结合我的源码，这样效果会更好。</p><p><img src="/" class="lazyload" data-src="https://images.gitbook.cn/6f23c980-b89e-11e8-87f1-559c9b456754"  alt="工程架构"></p><h2 id="1-统一的数据封装"><a href="#1-统一的数据封装" class="headerlink" title="1. 统一的数据封装"></a>1. 统一的数据封装</h2><p>由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一返回对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">"操作成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若没有数据返回，可以人为指定状态码和提示信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有数据返回时，状态码为0，默认提示信息为：操作成功！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">"操作成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有数据返回，状态码为0，人为指定提示信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(T data, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.code = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用自定义异常作为参数传递状态码和提示信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgEnum</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonResult</span><span class="params">(BusinessMsgEnum msgEnum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = msgEnum.code();</span><br><span class="line">        <span class="keyword">this</span>.msg = msgEnum.msg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省去get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以根据自己项目中所需要的一些东西，合理的修改统一结构中的字段信息。</p><h2 id="2-json的处理"><a href="#2-json的处理" class="headerlink" title="2. json的处理"></a>2. json的处理</h2><p>Json 处理工具很多，比如阿里巴巴的 fastjson，不过 fastjson 对有些未知类型的 null 无法转成空字符串，这可能是 fastjson 自身的缺陷，可扩展性也不是太好，但是使用起来方便，使用的人也蛮多的。这节课里面我们主要集成 Spring Boot 自带的 jackson。主要是对 jackson 做一下对 null 的配置即可，然后就可以在项目中使用了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jacksonConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(ObjectMapper<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ObjectMapper</span> <span class="title">jacksonObjectMapper</span>(<span class="title">Jackson2ObjectMapperBuilder</span> <span class="title">builder</span>) </span>&#123;</span><br><span class="line">        ObjectMapper objectMapper = builder.createXmlMapper(<span class="keyword">false</span>).build();</span><br><span class="line">        objectMapper.getSerializerProvider().setNullValueSerializer(<span class="keyword">new</span> JsonSerializer&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                jsonGenerator.writeString(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先不测试，等下面 swagger2 配置好了之后，我们一起来测试一下。</p><h2 id="3-swagger2在线可调式接口"><a href="#3-swagger2在线可调式接口" class="headerlink" title="3. swagger2在线可调式接口"></a>3. swagger2在线可调式接口</h2><p>有了 swagger，开发人员不需要给其他人员提供接口文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。使用 swagger 需要对其进行配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * swagger配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shengwu ni</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                <span class="comment">// 指定构建api文档的详细信息的方法：apiInfo()</span></span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.itcodai.course18.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建api文档的详细信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                <span class="comment">// 设置页面标题</span></span><br><span class="line">                .title(<span class="string">"Spring Boot搭建实际项目中开发的架构"</span>)</span><br><span class="line">                <span class="comment">// 设置接口描述</span></span><br><span class="line">                .description(<span class="string">"跟武哥一起学Spring Boot第18课"</span>)</span><br><span class="line">                <span class="comment">// 设置联系方式</span></span><br><span class="line">                .contact(<span class="string">"倪升武，"</span> + <span class="string">"微信公众号：程序员私房菜"</span>)</span><br><span class="line">                <span class="comment">// 设置版本</span></span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                <span class="comment">// 构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，可以先测试一下，写一个 Controller，弄一个静态的接口测试一下上面集成的内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api</span>(value = <span class="string">"用户信息接口"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getUser/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"根据用户唯一标识获取用户信息"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult&lt;User&gt; <span class="title">getUserInfo</span><span class="params">(@PathVariable @ApiParam(value = <span class="string">"用户唯一标识"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(id, <span class="string">"倪升武"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult&lt;&gt;(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 即可看到 swagger 接口文档页面，调用一下上面这个接口，即可看到返回的 json 数据。</p><h2 id="4-持久层集成"><a href="#4-持久层集成" class="headerlink" title="4. 持久层集成"></a>4. 持久层集成</h2><p>每个项目中是必须要有持久层的，与数据库交互，这里我们主要来集成 mybatis，集成 mybatis 首先要在 application.yml 中进行配置。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库地址</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">localhost:3306/blog_test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span> <span class="comment"># 数据库配置</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://$&#123;datasource.url&#125;?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">10</span> <span class="comment"># 最大连接池数</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">1770000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># 指定别名设置的包为所有entity</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itcodai.course18.entity</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span> <span class="comment"># 驼峰命名规范</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="comment"># mapper映射文件位置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>配置好了之后，接下来我们来写一下 dao 层，实际中我们使用注解比较多，因为比较方便，当然也可以使用 xml 的方式，甚至两种同时使用都行，这里我们主要使用注解的方式来集成，关于 xml 的方式，大家可以查看前面课程，实际中根据项目情况来定。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"username"</span>, column = <span class="string">"user_name"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"password"</span>, column = <span class="string">"password"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125; and user_name=#&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUserByIdAndName</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Long id, @<span class="title">Param</span><span class="params">(<span class="string">"name"</span>)</span> String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 <code>@MapperScan(&quot;com.itcodai.course18.dao&quot;)</code></p><h2 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5. 拦截器"></a>5. 拦截器</h2><p>拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"执行方法之前执行(Controller方法调用之前)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将自定义的拦截器加入到拦截器配置中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现WebMvcConfigurer不会导致静态资源被拦截</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">                <span class="comment">// 拦截所有url</span></span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                <span class="comment">// 放行swagger</span></span><br><span class="line">                .excludePathPatterns(<span class="string">"/swagger-resources/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源：</p><blockquote><p>classpath:/static<br>classpath:/public<br>classpath:/resources<br>classpath:/META-INF/resources  </p></blockquote><p>上面代码中配置的 <code>/**</code> 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。</p><p>然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。</p><h2 id="6-全局异常处理"><a href="#6-全局异常处理" class="headerlink" title="6. 全局异常处理"></a>6. 全局异常处理</h2><p>全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> BusinessMsgEnum &#123;</span><br><span class="line">    <span class="comment">/** 参数异常 */</span></span><br><span class="line">    PARMETER_EXCEPTION(<span class="string">"102"</span>, <span class="string">"参数异常!"</span>),</span><br><span class="line">    <span class="comment">/** 等待超时 */</span></span><br><span class="line">    SERVICE_TIME_OUT(<span class="string">"103"</span>, <span class="string">"服务调用超时！"</span>),</span><br><span class="line">    <span class="comment">/** 参数过大 */</span></span><br><span class="line">    PARMETER_BIG_EXCEPTION(<span class="string">"102"</span>, <span class="string">"输入的图片数量不能超过50张!"</span>),</span><br><span class="line">    <span class="comment">/** 500 : 发生异常 */</span></span><br><span class="line">    UNEXPECTED_EXCEPTION(<span class="string">"500"</span>, <span class="string">"系统发生异常，请联系管理员！"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BusinessMsgEnum</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截业务异常，返回业务异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BusinessErrorException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleBusinessError</span><span class="params">(BusinessErrorException ex)</span> </span>&#123;</span><br><span class="line">        String code = ex.getCode();</span><br><span class="line">        String message = ex.getMessage();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(code, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空指针异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex NullPointerException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(NullPointerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleTypeMismatchException</span><span class="params">(NullPointerException ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"空指针异常，&#123;&#125;"</span>, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(<span class="string">"500"</span>, <span class="string">"空指针异常了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统异常 预期以外异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">value</span> </span>= HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonResult <span class="title">handleUnexpectedServer</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">"系统异常："</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonResult(BusinessMsgEnum.UNEXPECTED_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。<br>在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>本文主要手把手带领大家快速搭建一个项目中可以使用的 Spring Boot 空架构，主要从统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（代码中体现）、持久层的集成、拦截器和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。</p><p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study" target="_blank" rel="noopener">戳我下载</a></p><blockquote><p>欢迎关注我的为微信公众号：武哥聊编程</p></blockquote><h1 id="附：作者信息"><a href="#附：作者信息" class="headerlink" title="附：作者信息"></a>附：作者信息</h1><p>本课程首发于 CSDN GitChat 达人课，该文档为课程详细笔记<br>作者：倪升武（武哥）<br>微信公众号：武哥聊编程<br>二维码：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/202002150421550.jpg"  alt="武哥聊编程"></p><blockquote><p>版权申明：本课程已经免费，但版权属于 CSDN 和作者，未经允许，不得将该笔记用于商业用途，否则追究法律责任。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解kmp算法</title>
      <link href="/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3kmp%E7%AE%97%E6%B3%95/"/>
      <url>/2020/04/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3kmp%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一、KMP算法是什么？"><a href="#一、KMP算法是什么？" class="headerlink" title="一、KMP算法是什么？"></a>一、KMP算法是什么？</h3><p>kmp算法是用于解决字符串匹配的算法;先来看一道例题<a href="https://www.nowcoder.com/practice/cb27a2cc0e8b41cbbdab7b0ca5c1bc23?tpId=98&tqId=32884&tPage=4&rp=4&ru=/ta/2019test&qru=/ta/2019test/question-ranking" target="_blank" rel="noopener">link</a></p><p><em>本文用约定用 <code>pat</code> 表示模式串，长度为 <code>M</code>，<code>txt</code> 表示文本串，长度为 <code>N</code>。KMP 算法是在 <code>txt</code> 中查找子串 <code>pat</code>，如果存在，返回这个子串的起始索引，否则返回 -1</em></p><p>首先来看一道例题：</p><blockquote><p>题目描述</p><p>字符串旋转:</p><p>给定两字符串A和B，如果能将A从中间某个位置分割为左右两部分字符串（都不为空串），并将左边的字符串移动到右边字符串后面组成新的字符串可以变为字符串B时返回true。</p><p>例如：如果A=‘youzan’，B=‘zanyou’，A按‘you’‘zan’切割换位后得到‘zanyou’和B相同返回true。</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2个不为空的字符串(说明:输入一个字符串以英文分号&quot;;&quot;分割为2个字符串)</span><br><span class="line">例如:youzan;zanyou 即为A&#x3D;‘youzan’，B&#x3D;‘zanyou’</span><br></pre></td></tr></table></figure><p><em>输出描述:</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出true或false(表示是否能按要求匹配两个字符串)</span><br></pre></td></tr></table></figure><p>示例1</p><p><em>输入</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">youzan;zanyou</span><br></pre></td></tr></table></figure><p><em>输出</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure></blockquote><p>这里先给个取巧的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String a = s.nextLine();</span><br><span class="line">        s.close();</span><br><span class="line">        String[] m = a.split(<span class="string">";"</span>);</span><br><span class="line">        <span class="keyword">if</span>(m[<span class="number">0</span>].length()!=m[<span class="number">1</span>].length())&#123;</span><br><span class="line">            System.out.print(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m[<span class="number">0</span>] = m[<span class="number">0</span>]+m[<span class="number">0</span>];</span><br><span class="line">        System.out.print(m[<span class="number">0</span>].contains(m[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、为什么要用KMP算法？"><a href="#二、为什么要用KMP算法？" class="headerlink" title="二、为什么要用KMP算法？"></a>二、为什么要用KMP算法？</h3><p>我们知道从字符串中寻找子串的问题一般可以用暴力遍历来解决，每一次只能往后移动一个位置，且遇到不匹配的字符时，指针需要回溯，时间复杂度为O(n*m)</p><img src="/" class="lazyload" data-src="https://pic4.zhimg.com/v2-817073ca77f6c75d234392f207a3c81b_b.webp"  style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(String pat, String txt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = pat.length;</span><br><span class="line">    <span class="keyword">int</span> N = txt.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - M; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pat[j] != txt[i+j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pat 全都匹配了</span></span><br><span class="line">        <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// txt 中不存在 pat 子串</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP算法具有两个特性：</p><ol><li>仅仅后移模式串</li><li>指针不回溯</li></ol><p>什么意思呢？请看以下两种情况下的kmp算法</p><p>(1)txt = “aaaaaaab” pat = “aaab”</p><img src="/" class="lazyload" data-src="https://pic1.zhimg.com/v2-e66f7a92145c8e3ea8c87b5889fbaf54_b.webp"  style="zoom:67%;" /><p>(2) txt = “aaacaaab” pat = “aaab”：</p><img src="/" class="lazyload" data-src="https://pic1.zhimg.com/v2-f29d822e4faf22542875de6c73fe07d0_b.webp"  style="zoom:67%;" /><p>到此为止大家应该已经理解为什么要用kmp算法代替暴力遍历找子串了</p><h3 id="三、KMP怎么解决问题？"><a href="#三、KMP怎么解决问题？" class="headerlink" title="三、KMP怎么解决问题？"></a>三、KMP怎么解决问题？</h3><p><strong>现在来看看kmp如何实现</strong></p><p>首先我们可以知道显著的区别是遇到失配的情况主串不必再回退到当前的下一个字符开始匹配，而是保持不变，不进行回溯。由子串进行回溯重新匹配，而且回退之后，<strong>回退点之前的元素需要和主串匹配才行</strong>，这样主串才不用回退。那关键就在于子串回退的位置，它该回退多少的问题。</p><p>要保证一个模式串进行移动j位之后，回退点之前的元素仍然和主串匹配，说明模式串的(真)前后缀有一段是相同的。</p><h5 id="步骤1：解决回退几位的问题"><a href="#步骤1：解决回退几位的问题" class="headerlink" title="步骤1：解决回退几位的问题"></a>步骤1：解决回退几位的问题</h5><p>这里引入next[j]表示失配点j，对于字符串aaab它有以下几种情况(这里表示的都是真前后缀)</p><p>next[0]表示失配点在pat[0]=a这个位置，也就是它前面的元素为””，没有前缀与后缀，令next[0] = -1；</p><p>next[1]表示失配点在pat[1]=a这个位置，也就是它前面的元素为a，没有前缀与后缀，故next[0] = 0；</p><p>next[2]表示失配点在pat[2]=a这个位置，也就是它前面的元素为aa，有前缀与后缀a，故next[1] = 1；</p><p>next[3]表示失配点在pat[3]=b这个位置，也就是它前面的元素为aaa，有前缀与后缀aa，故next[2] = 2；</p><p>那就可以得到这串子串的部分匹配表</p><table><thead><tr><th>i</th><th align="right">0</th><th align="center">1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>pat[]</td><td align="right">a</td><td align="center">a</td><td>a</td><td>b</td></tr><tr><td>next[]</td><td align="right">-1</td><td align="center">0</td><td>1</td><td>2</td></tr></tbody></table><p>那现在用这个匹配表验证前面两种主串</p><p>(1)txt = “aaaaaaab” pat = “aaab”</p><img src="/" class="lazyload" data-src="https://pic1.zhimg.com/v2-e66f7a92145c8e3ea8c87b5889fbaf54_b.webp"  style="zoom:67%;" /><p>失配点 j = 3， pat[j] = b， next[j] = 2；也就是说j回退到2的位置，往回走1位， 即pat[2] = a</p><p>(2)txt = “aaacaaab” pat = “aaab”：</p><img src="/" class="lazyload" data-src="https://pic1.zhimg.com/v2-f29d822e4faf22542875de6c73fe07d0_b.webp"  style="zoom:67%;" /><p>图片是经过优化算法得出的步骤，因为知道子串中未出现过c，所以可以直接回退到起点，但算法优化前是按照下面流程走的：</p><p>第一次: 失配点 j = 3， pat[j] = b， next[j] = 2；j回退到2的位置， 即pat[2] = a</p><p>第二次: 失配点 j = 2， pat[j] = a， next[j] = 1；j回退到1的位置， 即pat[1] = a</p><p>第三次: 失配点 j = 1， pat[j] = a， next[j] = 0；j回退到next[j]的位置， 即pat[0] = a</p><p>第四次: 失配点 j = 0， pat[j] = a， next[j] = -1;  j回退到next[j]的位置， 即pat[-1] = “”</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] txt, <span class="keyword">char</span>[] pat)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(pat);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; txt.length &amp;&amp; j &lt; pat.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (txt[i] == pat[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[j] != -<span class="number">1</span>) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// next[j] = -1说明这时已经在头部位置之前了</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == pat.length ? i-j : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2：解决求next数组的问题"><a href="#步骤2：解决求next数组的问题" class="headerlink" title="步骤2：解决求next数组的问题"></a>步骤2：解决求next数组的问题</h5><p>使用双指针遍历该位置前的串中前后缀相同的值，可令next[0] = -1，代表无匹配，回退到该字符串前一位置；</p><p>令next[1] = 0，真前后缀是不包含自身的。</p><p>图片链接：<a href="https://upload-images.jianshu.io/upload_images/11023579-8e5da803cfa21d91.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/11023579-8e5da803cfa21d91.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp</a></p><p>代码如下: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">public class static int[] getNext(char[] pat)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; pat.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pat[i-<span class="number">1</span>] == pat[j])&#123;</span><br><span class="line">                next[i] = j + <span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 首尾匹配，但次前缀和次后缀不匹配；</span></span><br><span class="line">                <span class="comment">// 那该位置的值就等于子串次前缀位置的值</span></span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 首尾不匹配</span></span><br><span class="line">                next[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] txt, <span class="keyword">char</span>[] pat)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(pat);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; txt.length &amp;&amp; j &lt; pat.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (txt[i] == pat[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[j] != -<span class="number">1</span>) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// next[j] = -1说明这时已经在头部位置之前了</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == pat.length ? i-j : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] pat)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pat.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; pat.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pat[i-<span class="number">1</span>] == pat[j])&#123;</span><br><span class="line">                next[i] = j + <span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 首尾匹配，但次前缀和次后缀不匹配；</span></span><br><span class="line">                <span class="comment">// 那该位置的值就等于子串次前缀位置的值</span></span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 首尾不匹配</span></span><br><span class="line">                next[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String s1 = str.split(<span class="string">";"</span>)[<span class="number">0</span>];</span><br><span class="line">        String s2 = str.split(<span class="string">";"</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s1.length() != s2.length()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"false"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转化为判断txt是否包含sub</span></span><br><span class="line">        String txt = s1 + s1;</span><br><span class="line">        String sub = s2;</span><br><span class="line">        System.out.println(</span><br><span class="line">            kmp(txt.toCharArray(), sub.toCharArray())==-<span class="number">1</span>?<span class="keyword">false</span>:<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基本使用命令</title>
      <link href="/2020/02/18/%E5%B7%A5%E5%85%B7/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/02/18/%E5%B7%A5%E5%85%B7/Git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">init</span><span class="comment">#第一步</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git branch<span class="comment">#查看分支，init之后add\commit之后才会出现</span></span><br><span class="line">git branch dev<span class="comment">#创建分支</span></span><br><span class="line">git checkout dev<span class="comment">#切换分支</span></span><br><span class="line">git checkout <span class="literal">-b</span> dev<span class="comment">#快速创建并切换分支</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看文件状态</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#增加</span></span><br><span class="line">git add filename.txt</span><br><span class="line"><span class="comment">#提交</span></span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">"branch dev add filename.txt"</span></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">git rm filename.txt</span><br><span class="line">git commit filename .txt <span class="literal">-m</span> <span class="string">"delete filename"</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git log <span class="comment">#查看日志</span></span><br><span class="line">git log -<span class="literal">-oneline</span> <span class="literal">-2</span><span class="comment">#简洁日志显示最近两条</span></span><br><span class="line">git log -<span class="literal">-oneline</span> -<span class="literal">-graph</span><span class="comment">#图形化显示分支走向</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git reset -<span class="literal">-hard</span> HEAD~<span class="number">2</span><span class="comment">#回退到上两个版本</span></span><br><span class="line">git reset -<span class="literal">-hard</span> <span class="number">4</span>e763k<span class="comment">#回退到上版本4e763k</span></span><br></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><h5 id="工作区撤销"><a href="#工作区撤销" class="headerlink" title="工作区撤销"></a>工作区撤销</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git checkout-<span class="literal">-he1109</span>.txt<span class="comment">#可以撒销到最近一次 git add或 git commit的状态</span></span><br><span class="line"><span class="comment">#即：如果暂存区有此文件，则将暂存区中的文件内容恢复到工作区。</span></span><br><span class="line"><span class="comment">#如果暂存区没有此文件，则将分支中的文件内容恢复到工作区。</span></span><br></pre></td></tr></table></figure><h5 id="暂存区撤销-已经commit"><a href="#暂存区撤销-已经commit" class="headerlink" title="暂存区撤销(已经commit)"></a>暂存区撤销(已经commit)</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果在工作区中修改了文件并发送到暂存区中，但文件中有需要撤销的内容则可以执行：</span></span><br><span class="line">git reset HEAD he1109.txt</span><br><span class="line"><span class="comment">#将hello.txt在暂存区的内容清除然后可执行：</span></span><br><span class="line">git checkout-<span class="literal">-hel1o9</span>.txt回退到上一个版本</span><br></pre></td></tr></table></figure><h3 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:zanghongjiu99/repo<span class="comment">#添加远程库远程库别名库地址</span></span><br><span class="line">git remote<span class="literal">-V</span><span class="comment">#查看关联的所有远程库</span></span><br><span class="line">git remote show origin<span class="comment">#关联远程库后，本地分支和远程分支的对应关系</span></span><br><span class="line">git remote remove origin<span class="comment">#删除关联</span></span><br><span class="line">git remote rename origin origin2<span class="comment">#重命名</span></span><br></pre></td></tr></table></figure><h3 id="push操作"><a href="#push操作" class="headerlink" title="push操作"></a>push操作</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#本地的 master分支上传到与之有跟踪关系的远程分支中，（克隆时就会建立跟踪关系），如果远程分支不存在，则会建立远程分支</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="comment">#本地存在分支dev，上传到远程库 origin的分支dev，如果没有dev，将建立远程分支dev </span></span><br><span class="line">git push origin dev:dev</span><br><span class="line"><span class="comment">#本地库dev：远程库deν本地库dev2：远程库dev2</span></span><br><span class="line">git push origin dev:dev dev2：dev2</span><br></pre></td></tr></table></figure><h3 id="pull-fetch-merge"><a href="#pull-fetch-merge" class="headerlink" title="pull=fetch+merge"></a>pull=fetch+merge</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#git pull&lt;远程主机名&gt;&lt;远程分支名&gt;∷&lt;本地分支名&gt;</span></span><br><span class="line"><span class="comment">#git pull origin master:master</span></span><br><span class="line">git pull origin master<span class="comment">#省略本地分支名= master：当前分支（缺省）</span></span><br><span class="line">git pull origin dev<span class="comment">#省略本地分支名=dev：当前分支</span></span><br></pre></td></tr></table></figure><h3 id="fetch-amp-amp-merge"><a href="#fetch-amp-amp-merge" class="headerlink" title="fetch&amp;&amp;merge"></a>fetch&amp;&amp;merge</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#拉取远程 master分支中本地没有的内容（即其他开发者push的内容）</span></span><br><span class="line">git fetch origin master<span class="comment">#拉取的分支名为" origin/原始分支名“</span></span><br><span class="line">git merge origin/ master<span class="comment">#把拉取下来的 master分支的内容合并到本地库中的分支上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#拉取所有分支的的内容（本地没有的，其他开发者push的内容）（假定有分支：dev2，dev3）</span></span><br><span class="line">git fetch origin git checkout dev2 并 git merge origin/dev2<span class="comment">#切换到dev2分支，并合并拉取下来的内容</span></span><br><span class="line">git checkout dev3 并 git merge origin/dev3</span><br><span class="line">git checkout dev2 并 git diff origin/dev2<span class="comment">#切换到dev2分支，比较拉取的内容中的dev2分支和本地dev2分支的不同</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇入门docker</title>
      <link href="/2019/10/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/%E4%B8%80%E7%AF%87%E5%85%A5%E9%97%A8docker/"/>
      <url>/2019/10/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/%E4%B8%80%E7%AF%87%E5%85%A5%E9%97%A8docker/</url>
      
        <content type="html"><![CDATA[<h1 id="一篇学会Docker"><a href="#一篇学会Docker" class="headerlink" title="一篇学会Docker"></a><strong>一篇学会Docker</strong></h1><blockquote><p>这里给出几个好的学习资源分享给大家一起学习 本文也是参考如下课程编写，转载请注明出处</p><ul><li>docker入门：<a href="https://www.bilibili.com/video/av55377411/" target="_blank" rel="noopener">https://www.bilibili.com/video/av55377411/</a></li><li>docker详细：<a href="https://www.bilibili.com/video/av27122140/" target="_blank" rel="noopener">https://www.bilibili.com/video/av27122140/</a></li></ul></blockquote><h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><h3 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1 什么是Docker"></a>1.1 什么是Docker</h3><pre><code>Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker，就不用担心环境问题。总体来说，Docker的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</code></pre><h3 id="1-2-容器与虚拟机比较"><a href="#1-2-容器与虚拟机比较" class="headerlink" title="1.2 容器与虚拟机比较"></a>1.2 容器与虚拟机比较</h3><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006201837439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="docker与虚拟机区别"><br>        容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。<br>与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。</p><ul><li>启动快：启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</li><li>资源占用少：容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所以资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</li><li>体积小：容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</li></ul><h3 id="1-3-Docker-组件"><a href="#1-3-Docker-组件" class="headerlink" title="1.3 Docker 组件"></a>1.3 Docker 组件</h3><h4 id="1-3-1-Docker镜像与容器、仓库"><a href="#1-3-1-Docker镜像与容器、仓库" class="headerlink" title="1.3.1 Docker镜像与容器、仓库"></a>1.3.1 Docker镜像与容器、仓库</h4><p>镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。</p><p>容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 </p><table><thead><tr><th>docker</th><th>面向对象</th></tr></thead><tbody><tr><td>容器</td><td>对象</td></tr><tr><td>镜像</td><td>类</td></tr></tbody></table><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>镜像(Images)</td><td>Docker 镜像是用于创建 Docker 容器的模板。</td></tr><tr><td>容器(Container)</td><td>容器是独立运行的一个或一组应用。</td></tr><tr><td>仓库(Registry)</td><td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</td></tr></tbody></table><h2 id="Docker安装与启动"><a href="#Docker安装与启动" class="headerlink" title="Docker安装与启动"></a>Docker安装与启动</h2><h3 id="2-1-安装Docker"><a href="#2-1-安装Docker" class="headerlink" title="2.1 安装Docker"></a>2.1 安装Docker</h3><p> Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p><p> <strong>这部分我会单独提供一份基于Ubuntu的Nvidia-docker安装与启动</strong><br> 可以点击这里查看</p><h3 id="2-3-Docker的启动与停止"><a href="#2-3-Docker的启动与停止" class="headerlink" title="2.3 Docker的启动与停止"></a>2.3 Docker的启动与停止</h3><p>systemctl命令是系统服务管理器指令<br>启动docker：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>停止docker：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p>重启docker：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>查看docker状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>开机启动：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>查看docker概要信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>查看docker帮助文档</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="3-1-镜像相关命令"><a href="#3-1-镜像相关命令" class="headerlink" title="3.1 镜像相关命令"></a>3.1 镜像相关命令</h3><h4 id="3-1-1-查看镜像"><a href="#3-1-1-查看镜像" class="headerlink" title="3.1.1 查看镜像"></a>3.1.1 查看镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><ul><li>REPOSITORY：镜像名称</li><li>TAG：镜像标签</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像的创建日期（不是获取该镜像的日期）</li><li>SIZE：镜像大小</li><li>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</li></ul><h4 id="3-1-2-搜索镜像"><a href="#3-1-2-搜索镜像" class="headerlink" title="3.1.2 搜索镜像"></a>3.1.2 搜索镜像</h4><p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure><p>也可以从镜像库中查找： <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a><br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2019100621042190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><ul><li>NAME：仓库名称</li><li>DESCRIPTION：镜像描述</li><li>STARS：用户评价，反应一个镜像的受欢迎程度</li><li>OFFICIAL：是否官方</li><li>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</li></ul><h4 id="3-1-3-拉取镜像"><a href="#3-1-3-拉取镜像" class="headerlink" title="3.1.3 拉取镜像"></a>3.1.3 拉取镜像</h4><p>拉取镜像就是从中央仓库中下载镜像到本地</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名称(默认最新)</span><br></pre></td></tr></table></figure><p>例如，我要下载centos7镜像(指定版本)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull centos:7</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210450936.png"  alt="在这里插入图片描述"></p><h4 id="3-1-4-删除镜像"><a href="#3-1-4-删除镜像" class="headerlink" title="3.1.4 删除镜像"></a>3.1.4 删除镜像</h4><p>按镜像ID删除镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006204413950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>删除所有镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi &#96;docker images -q&#96;</span><br></pre></td></tr></table></figure><ul><li>docker images –q:查询所有镜像的ID，并作为rmi的参数</li></ul><h3 id="3-2-容器相关命令"><a href="#3-2-容器相关命令" class="headerlink" title="3.2 容器相关命令"></a>3.2 容器相关命令</h3><h4 id="3-2-1-查看容器"><a href="#3-2-1-查看容器" class="headerlink" title="3.2.1 查看容器"></a>3.2.1 查看容器</h4><p>查看正在运行的容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps –a</span><br></pre></td></tr></table></figure><p>查看最后一次运行的容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps –l</span><br></pre></td></tr></table></figure><p>查看停止的容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -f status&#x3D;exited</span><br></pre></td></tr></table></figure><h4 id="3-2-2-创建与启动容器"><a href="#3-2-2-创建与启动容器" class="headerlink" title="3.2.2 创建与启动容器"></a>3.2.2 创建与启动容器</h4><p>创建容器常用的参数说明：<br>创建容器命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run</span><br></pre></td></tr></table></figure><ul><li>-i：表示运行容器</li><li>-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</li><li>–name :为创建的容器命名。</li><li>-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</li><li>-d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</li><li>-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</li></ul><p>（1）交互式方式创建容器<br>交互式：前台打开，exit时关机</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name&#x3D;容器名称 镜像名称:标签 &#x2F;bin&#x2F;bash（进入命令行）</span><br></pre></td></tr></table></figure><p> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210645617.png"  alt="在这里插入图片描述"><br>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210716621.png"  alt="在这里插入图片描述"><br>退出当前容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210803525.png"  alt="在这里插入图片描述"><br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210812972.png"  alt="在这里插入图片描述"></p><p>（2）守护式方式创建容器：<br>守护式：后台运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;容器名称 镜像名称:标签</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210843213.png"  alt="在这里插入图片描述"></p><p>登录守护式容器方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名称 (或者容器ID)  &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210911739.png"  alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit不会直接关机而是后台继续运行</span><br></pre></td></tr></table></figure><p> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210937258.png"  alt="在这里插入图片描述"></p><h4 id="3-2-3-停止与启动容器"><a href="#3-2-3-停止与启动容器" class="headerlink" title="3.2.3 停止与启动容器"></a>3.2.3 停止与启动容器</h4><p>停止容器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure><p> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211008937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>启动容器：<br><code>docker start 容器名称（或者容器ID</code>）<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211047856.png"  alt="在这里插入图片描述"></p><h4 id="3-2-4-文件拷贝"><a href="#3-2-4-文件拷贝" class="headerlink" title="3.2.4 文件拷贝"></a>3.2.4 文件拷贝</h4><p>如果我们需要将文件拷贝到容器内可以使用cp命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp 需要拷贝的文件或目录 容器名称:容器目录</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211129718.png"  alt="在这里插入图片描述"><br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2019100621115450.png"  alt="在这里插入图片描述"></p><p>也可以将文件从容器内拷贝出来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211219515.png"  alt="在这里插入图片描述"></p><h4 id="3-2-5-目录挂载（共享目录）"><a href="#3-2-5-目录挂载（共享目录）" class="headerlink" title="3.2.5 目录挂载（共享目录）"></a>3.2.5 目录挂载（共享目录）</h4><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml </span><br><span class="line">--name&#x3D;mycentos3 centos:7</span><br></pre></td></tr></table></figure><ul><li>容器目录：宿主机目录<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211306179.png"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211315877.png"  alt="在这里插入图片描述"></li></ul><h4 id="3-2-6-查看容器IP地址"><a href="#3-2-6-查看容器IP地址" class="headerlink" title="3.2.6 查看容器IP地址"></a>3.2.6 查看容器IP地址</h4><p>我们可以通过以下命令查看容器运行的各种数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名称（容器ID）</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211414785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211500557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>也可以直接执行下面的命令直接输出IP地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; 容器名称（容器ID）</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211551118.png"  alt="在这里插入图片描述"></p><h4 id="3-2-7-删除容器"><a href="#3-2-7-删除容器" class="headerlink" title="3.2.7 删除容器"></a>3.2.7 删除容器</h4><p>删除指定的容器：（需先停止）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 容器名称（容器ID）</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211626508.png"  alt="在这里插入图片描述"></p><h2 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h2><h3 id="4-1-MySQL部署"><a href="#4-1-MySQL部署" class="headerlink" title="4.1 MySQL部署"></a>4.1 MySQL部署</h3><p>（1）拉取mysql镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull centos&#x2F;mysql-57-centos7</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2019100621171462.png"  alt="在这里插入图片描述"></p><p>（2）创建容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 mysql</span><br></pre></td></tr></table></figure><ul><li>-p 代表端口映射，格式为  宿主机映射端口:容器运行端口</li><li>-e 代表添加环境变量  MYSQL_ROOT_PASSWORD 是root用户的登陆密码<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2019100621172622.png"  alt="在这里插入图片描述"></li></ul><p>（3）远程登录mysql<br>连接宿主机的IP ,指定端口为33306 </p><h3 id="4-2-tomcat部署"><a href="#4-2-tomcat部署" class="headerlink" title="4.2 tomcat部署"></a>4.2 tomcat部署</h3><p>（1）拉取镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull tomcat:7-jre7</span><br></pre></td></tr></table></figure><p>（2）创建容器<br>创建容器  -p表示地址映射</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;mytomcat -p 9000:8080 </span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;webapps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps tomcat:7-jre7</span><br></pre></td></tr></table></figure><h3 id="4-3-Nginx部署"><a href="#4-3-Nginx部署" class="headerlink" title="4.3 Nginx部署"></a>4.3 Nginx部署</h3><p>（1）拉取镜像 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><p>（2）创建Nginx容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><h3 id="4-4-Redis部署"><a href="#4-4-Redis部署" class="headerlink" title="4.4 Redis部署"></a>4.4 Redis部署</h3><p>（1）拉取镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><p>（2）创建容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure><h2 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h2><h3 id="5-1-容器保存为镜像"><a href="#5-1-容器保存为镜像" class="headerlink" title="5.1 容器保存为镜像"></a>5.1 容器保存为镜像</h3><p>我们可以通过以下命令将容器保存为镜像<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211832389.png"  alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit mynginx mynginx_i</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211845535.png"  alt="在这里插入图片描述"></p><ul><li>通过保存的mynginx_i镜像创建基于mynginx_i的容器mynginx2<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211857765.png"  alt="在这里插入图片描述"></li></ul><h3 id="5-2-镜像备份"><a href="#5-2-镜像备份" class="headerlink" title="5.2 镜像备份"></a>5.2 镜像备份</h3><p>我们可以通过以下命令将镜像保存为tar 文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker  save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211921783.png"  alt="在这里插入图片描述"></p><h3 id="5-3-镜像恢复与迁移"><a href="#5-3-镜像恢复与迁移" class="headerlink" title="5.3 镜像恢复与迁移"></a>5.3 镜像恢复与迁移</h3><p>首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i mynginx.tar</span><br></pre></td></tr></table></figure><ul><li>-i 输入的文件</li></ul><p>执行后再次查看镜像，可以看到镜像已经恢复<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211958768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="6-1-什么是Dockerfile"><a href="#6-1-什么是Dockerfile" class="headerlink" title="6.1 什么是Dockerfile"></a>6.1 什么是Dockerfile</h3><pre><code>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</code></pre><ol><li>对于开发人员：可以为开发团队提供一个完全一致的开发环境；</li><li>对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；</li><li>对于运维人员：在部署时，可以实现应用的无缝移植。</li></ol><h4 id="6-2-常用命令"><a href="#6-2-常用命令" class="headerlink" title="6.2 常用命令"></a>6.2 常用命令</h4><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212052180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h4 id="6-1-使用脚本创建镜像"><a href="#6-1-使用脚本创建镜像" class="headerlink" title="6.1 使用脚本创建镜像"></a>6.1 使用脚本创建镜像</h4><p>步骤：<br>（1）创建目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir –p &#x2F;usr&#x2F;local&#x2F;dockerjdk8</span><br></pre></td></tr></table></figure><p>（2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212150974.png"  alt="在这里插入图片描述"><br>（3）创建文件Dockerfile </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#依赖镜像名称和ID</span></span><br><span class="line">FROM centos:<span class="number">7</span></span><br><span class="line"><span class="comment">#指定镜像创建者信息</span></span><br><span class="line">MAINTAINER ITCAST</span><br><span class="line"><span class="comment">#切换工作目录</span></span><br><span class="line">WORKDIR /usr</span><br><span class="line">RUN mkdir  /usr/local/java</span><br><span class="line"><span class="comment">#ADD 是相对路径jar,把java添加到容器中</span></span><br><span class="line">ADD jdk<span class="literal">-8u171</span><span class="literal">-linux</span><span class="literal">-x64</span>.tar.gz /usr/local/java/</span><br><span class="line"><span class="comment">#配置java环境变量</span></span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.<span class="number">8.0</span>_171</span><br><span class="line">ENV JRE_HOME <span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JRE_HOME</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line">ENV PATH <span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212240177.png"  alt="在这里插入图片描述"><br>（4）执行命令构建镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t&#x3D;&#39;jdk1.8&#39; .</span><br></pre></td></tr></table></figure><p> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212313416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><ul><li>注意后边的空格和点，不要省略</li></ul><p>（5）查看镜像是否建立完成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2019100621233892.png"  alt="在这里插入图片描述"></p><h2 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h2><h3 id="7-1-私有仓库搭建与配置"><a href="#7-1-私有仓库搭建与配置" class="headerlink" title="7.1 私有仓库搭建与配置"></a>7.1 私有仓库搭建与配置</h3><p>（1）拉取私有仓库镜像（企业仓库）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212700706.png"  alt="在这里插入图片描述"></p><p>（2）启动私有仓库容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;registry -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212717830.png"  alt="在这里插入图片描述"></p><p>（3）打开浏览器 输入地址<a href="http://192.168.184.141:5000/v2/_catalog看到{&quot;repositories&quot;:[]}" target="_blank" rel="noopener">http://192.168.184.141:5000/v2/_catalog看到{&quot;repositories&quot;:[]}</a> 表示私有仓库搭建成功并且内容为空<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212735250.png"  alt="在这里插入图片描述"><br>（4）修改daemon.json</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><p>添加以下内容，保存退出。<br>{“insecure-registries”:[“192.168.184.141:5000”]}<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212638249.png"  alt="在这里插入图片描述"><br>此步用于让 docker信任私有仓库地址<br>（5）重启docker 服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="7-2-镜像上传至私有仓库"><a href="#7-2-镜像上传至私有仓库" class="headerlink" title="7.2 镜像上传至私有仓库"></a>7.2 镜像上传至私有仓库</h3><p>（1）标记此镜像为私有仓库的镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag jdk1.8 192.168.184.141:5000&#x2F;jdk1.8</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212612925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>（2）再次启动私服容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start registry</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212556615.png"  alt="在这里插入图片描述"></p><p>（3）上传标记的镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker push 192.168.184.141:5000&#x2F;jdk1.8</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/201910062125292.png"  alt="在这里插入图片描述"><br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212539343.png"  alt="在这里插入图片描述"></p><p><em>最后，本文也参考了一些文章，因为也是第一次写博客，忘记将之前参考过的文章保存起来，如果大家有看到我引用没有标明的地方，请告知，谢谢！在学习的道路上，与君共勉。</em></p>]]></content>
      
      
      <categories>
          
          <category> 集群 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
