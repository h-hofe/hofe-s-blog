<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一篇入门docker</title>
      <link href="/2020/04/05/%E4%B8%80%E7%AF%87%E5%85%A5%E9%97%A8docker/"/>
      <url>/2020/04/05/%E4%B8%80%E7%AF%87%E5%85%A5%E9%97%A8docker/</url>
      
        <content type="html"><![CDATA[<h1 id="一篇学会Docker"><a href="#一篇学会Docker" class="headerlink" title="一篇学会Docker"></a><strong>一篇学会Docker</strong></h1><blockquote><p>这里给出几个好的学习资源分享给大家一起学习 本文也是参考如下课程编写，转载请注明出处</p><ul><li>docker入门：<a href="https://www.bilibili.com/video/av55377411/" target="_blank" rel="noopener">https://www.bilibili.com/video/av55377411/</a></li><li>docker详细：<a href="https://www.bilibili.com/video/av27122140/" target="_blank" rel="noopener">https://www.bilibili.com/video/av27122140/</a></li></ul></blockquote><h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><h3 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1 什么是Docker"></a>1.1 什么是Docker</h3><pre><code>Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker，就不用担心环境问题。总体来说，Docker的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</code></pre><h3 id="1-2-容器与虚拟机比较"><a href="#1-2-容器与虚拟机比较" class="headerlink" title="1.2 容器与虚拟机比较"></a>1.2 容器与虚拟机比较</h3><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006201837439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="docker与虚拟机区别"><br>        容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。<br>与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。</p><ul><li>启动快：启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</li><li>资源占用少：容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所以资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</li><li>体积小：容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</li></ul><h3 id="1-3-Docker-组件"><a href="#1-3-Docker-组件" class="headerlink" title="1.3 Docker 组件"></a>1.3 Docker 组件</h3><h4 id="1-3-1-Docker镜像与容器、仓库"><a href="#1-3-1-Docker镜像与容器、仓库" class="headerlink" title="1.3.1 Docker镜像与容器、仓库"></a>1.3.1 Docker镜像与容器、仓库</h4><p>镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。</p><p>容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 </p><table><thead><tr><th>docker</th><th>面向对象</th></tr></thead><tbody><tr><td>容器</td><td>对象</td></tr><tr><td>镜像</td><td>类</td></tr></tbody></table><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>镜像(Images)</td><td>Docker 镜像是用于创建 Docker 容器的模板。</td></tr><tr><td>容器(Container)</td><td>容器是独立运行的一个或一组应用。</td></tr><tr><td>仓库(Registry)</td><td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</td></tr></tbody></table><h2 id="Docker安装与启动"><a href="#Docker安装与启动" class="headerlink" title="Docker安装与启动"></a>Docker安装与启动</h2><h3 id="2-1-安装Docker"><a href="#2-1-安装Docker" class="headerlink" title="2.1 安装Docker"></a>2.1 安装Docker</h3><p> Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p><p> <strong>这部分我会单独提供一份基于Ubuntu的Nvidia-docker安装与启动</strong><br> 可以点击这里查看</p><h3 id="2-3-Docker的启动与停止"><a href="#2-3-Docker的启动与停止" class="headerlink" title="2.3 Docker的启动与停止"></a>2.3 Docker的启动与停止</h3><p>systemctl命令是系统服务管理器指令<br>启动docker：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>停止docker：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p>重启docker：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>查看docker状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>开机启动：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>查看docker概要信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>查看docker帮助文档</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="3-1-镜像相关命令"><a href="#3-1-镜像相关命令" class="headerlink" title="3.1 镜像相关命令"></a>3.1 镜像相关命令</h3><h4 id="3-1-1-查看镜像"><a href="#3-1-1-查看镜像" class="headerlink" title="3.1.1 查看镜像"></a>3.1.1 查看镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><ul><li>REPOSITORY：镜像名称</li><li>TAG：镜像标签</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像的创建日期（不是获取该镜像的日期）</li><li>SIZE：镜像大小</li><li>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</li></ul><h4 id="3-1-2-搜索镜像"><a href="#3-1-2-搜索镜像" class="headerlink" title="3.1.2 搜索镜像"></a>3.1.2 搜索镜像</h4><p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure><p>也可以从镜像库中查找： <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a><br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2019100621042190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><ul><li>NAME：仓库名称</li><li>DESCRIPTION：镜像描述</li><li>STARS：用户评价，反应一个镜像的受欢迎程度</li><li>OFFICIAL：是否官方</li><li>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</li></ul><h4 id="3-1-3-拉取镜像"><a href="#3-1-3-拉取镜像" class="headerlink" title="3.1.3 拉取镜像"></a>3.1.3 拉取镜像</h4><p>拉取镜像就是从中央仓库中下载镜像到本地</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名称(默认最新)</span><br></pre></td></tr></table></figure><p>例如，我要下载centos7镜像(指定版本)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull centos:7</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210450936.png"  alt="在这里插入图片描述"></p><h4 id="3-1-4-删除镜像"><a href="#3-1-4-删除镜像" class="headerlink" title="3.1.4 删除镜像"></a>3.1.4 删除镜像</h4><p>按镜像ID删除镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006204413950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>删除所有镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi &#96;docker images -q&#96;</span><br></pre></td></tr></table></figure><ul><li>docker images –q:查询所有镜像的ID，并作为rmi的参数</li></ul><h3 id="3-2-容器相关命令"><a href="#3-2-容器相关命令" class="headerlink" title="3.2 容器相关命令"></a>3.2 容器相关命令</h3><h4 id="3-2-1-查看容器"><a href="#3-2-1-查看容器" class="headerlink" title="3.2.1 查看容器"></a>3.2.1 查看容器</h4><p>查看正在运行的容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps –a</span><br></pre></td></tr></table></figure><p>查看最后一次运行的容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps –l</span><br></pre></td></tr></table></figure><p>查看停止的容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -f status&#x3D;exited</span><br></pre></td></tr></table></figure><h4 id="3-2-2-创建与启动容器"><a href="#3-2-2-创建与启动容器" class="headerlink" title="3.2.2 创建与启动容器"></a>3.2.2 创建与启动容器</h4><p>创建容器常用的参数说明：<br>创建容器命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run</span><br></pre></td></tr></table></figure><ul><li>-i：表示运行容器</li><li>-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</li><li>–name :为创建的容器命名。</li><li>-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</li><li>-d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</li><li>-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</li></ul><p>（1）交互式方式创建容器<br>交互式：前台打开，exit时关机</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name&#x3D;容器名称 镜像名称:标签 &#x2F;bin&#x2F;bash（进入命令行）</span><br></pre></td></tr></table></figure><p> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210645617.png"  alt="在这里插入图片描述"><br>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210716621.png"  alt="在这里插入图片描述"><br>退出当前容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210803525.png"  alt="在这里插入图片描述"><br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210812972.png"  alt="在这里插入图片描述"></p><p>（2）守护式方式创建容器：<br>守护式：后台运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;容器名称 镜像名称:标签</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210843213.png"  alt="在这里插入图片描述"></p><p>登录守护式容器方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名称 (或者容器ID)  &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210911739.png"  alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit不会直接关机而是后台继续运行</span><br></pre></td></tr></table></figure><p> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006210937258.png"  alt="在这里插入图片描述"></p><h4 id="3-2-3-停止与启动容器"><a href="#3-2-3-停止与启动容器" class="headerlink" title="3.2.3 停止与启动容器"></a>3.2.3 停止与启动容器</h4><p>停止容器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure><p> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211008937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>启动容器：<br><code>docker start 容器名称（或者容器ID</code>）<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211047856.png"  alt="在这里插入图片描述"></p><h4 id="3-2-4-文件拷贝"><a href="#3-2-4-文件拷贝" class="headerlink" title="3.2.4 文件拷贝"></a>3.2.4 文件拷贝</h4><p>如果我们需要将文件拷贝到容器内可以使用cp命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp 需要拷贝的文件或目录 容器名称:容器目录</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211129718.png"  alt="在这里插入图片描述"><br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2019100621115450.png"  alt="在这里插入图片描述"></p><p>也可以将文件从容器内拷贝出来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211219515.png"  alt="在这里插入图片描述"></p><h4 id="3-2-5-目录挂载（共享目录）"><a href="#3-2-5-目录挂载（共享目录）" class="headerlink" title="3.2.5 目录挂载（共享目录）"></a>3.2.5 目录挂载（共享目录）</h4><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml </span><br><span class="line">--name&#x3D;mycentos3 centos:7</span><br></pre></td></tr></table></figure><ul><li>容器目录：宿主机目录<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211306179.png"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211315877.png"  alt="在这里插入图片描述"></li></ul><h4 id="3-2-6-查看容器IP地址"><a href="#3-2-6-查看容器IP地址" class="headerlink" title="3.2.6 查看容器IP地址"></a>3.2.6 查看容器IP地址</h4><p>我们可以通过以下命令查看容器运行的各种数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名称（容器ID）</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211414785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211500557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>也可以直接执行下面的命令直接输出IP地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; 容器名称（容器ID）</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211551118.png"  alt="在这里插入图片描述"></p><h4 id="3-2-7-删除容器"><a href="#3-2-7-删除容器" class="headerlink" title="3.2.7 删除容器"></a>3.2.7 删除容器</h4><p>删除指定的容器：（需先停止）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm 容器名称（容器ID）</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211626508.png"  alt="在这里插入图片描述"></p><h2 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h2><h3 id="4-1-MySQL部署"><a href="#4-1-MySQL部署" class="headerlink" title="4.1 MySQL部署"></a>4.1 MySQL部署</h3><p>（1）拉取mysql镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull centos&#x2F;mysql-57-centos7</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2019100621171462.png"  alt="在这里插入图片描述"></p><p>（2）创建容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 mysql</span><br></pre></td></tr></table></figure><ul><li>-p 代表端口映射，格式为  宿主机映射端口:容器运行端口</li><li>-e 代表添加环境变量  MYSQL_ROOT_PASSWORD 是root用户的登陆密码<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2019100621172622.png"  alt="在这里插入图片描述"></li></ul><p>（3）远程登录mysql<br>连接宿主机的IP ,指定端口为33306 </p><h3 id="4-2-tomcat部署"><a href="#4-2-tomcat部署" class="headerlink" title="4.2 tomcat部署"></a>4.2 tomcat部署</h3><p>（1）拉取镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull tomcat:7-jre7</span><br></pre></td></tr></table></figure><p>（2）创建容器<br>创建容器  -p表示地址映射</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;mytomcat -p 9000:8080 </span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;webapps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps tomcat:7-jre7</span><br></pre></td></tr></table></figure><h3 id="4-3-Nginx部署"><a href="#4-3-Nginx部署" class="headerlink" title="4.3 Nginx部署"></a>4.3 Nginx部署</h3><p>（1）拉取镜像 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><p>（2）创建Nginx容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><h3 id="4-4-Redis部署"><a href="#4-4-Redis部署" class="headerlink" title="4.4 Redis部署"></a>4.4 Redis部署</h3><p>（1）拉取镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><p>（2）创建容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure><h2 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h2><h3 id="5-1-容器保存为镜像"><a href="#5-1-容器保存为镜像" class="headerlink" title="5.1 容器保存为镜像"></a>5.1 容器保存为镜像</h3><p>我们可以通过以下命令将容器保存为镜像<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211832389.png"  alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit mynginx mynginx_i</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211845535.png"  alt="在这里插入图片描述"></p><ul><li>通过保存的mynginx_i镜像创建基于mynginx_i的容器mynginx2<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211857765.png"  alt="在这里插入图片描述"></li></ul><h3 id="5-2-镜像备份"><a href="#5-2-镜像备份" class="headerlink" title="5.2 镜像备份"></a>5.2 镜像备份</h3><p>我们可以通过以下命令将镜像保存为tar 文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker  save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211921783.png"  alt="在这里插入图片描述"></p><h3 id="5-3-镜像恢复与迁移"><a href="#5-3-镜像恢复与迁移" class="headerlink" title="5.3 镜像恢复与迁移"></a>5.3 镜像恢复与迁移</h3><p>首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i mynginx.tar</span><br></pre></td></tr></table></figure><ul><li>-i 输入的文件</li></ul><p>执行后再次查看镜像，可以看到镜像已经恢复<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006211958768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="6-1-什么是Dockerfile"><a href="#6-1-什么是Dockerfile" class="headerlink" title="6.1 什么是Dockerfile"></a>6.1 什么是Dockerfile</h3><pre><code>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</code></pre><ol><li>对于开发人员：可以为开发团队提供一个完全一致的开发环境；</li><li>对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；</li><li>对于运维人员：在部署时，可以实现应用的无缝移植。</li></ol><h4 id="6-2-常用命令"><a href="#6-2-常用命令" class="headerlink" title="6.2 常用命令"></a>6.2 常用命令</h4><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212052180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h4 id="6-1-使用脚本创建镜像"><a href="#6-1-使用脚本创建镜像" class="headerlink" title="6.1 使用脚本创建镜像"></a>6.1 使用脚本创建镜像</h4><p>步骤：<br>（1）创建目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir –p &#x2F;usr&#x2F;local&#x2F;dockerjdk8</span><br></pre></td></tr></table></figure><p>（2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212150974.png"  alt="在这里插入图片描述"><br>（3）创建文件Dockerfile </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi Dockerfile</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#依赖镜像名称和ID</span></span><br><span class="line">FROM centos:<span class="number">7</span></span><br><span class="line"><span class="comment">#指定镜像创建者信息</span></span><br><span class="line">MAINTAINER ITCAST</span><br><span class="line"><span class="comment">#切换工作目录</span></span><br><span class="line">WORKDIR /usr</span><br><span class="line">RUN mkdir  /usr/local/java</span><br><span class="line"><span class="comment">#ADD 是相对路径jar,把java添加到容器中</span></span><br><span class="line">ADD jdk<span class="literal">-8u171</span><span class="literal">-linux</span><span class="literal">-x64</span>.tar.gz /usr/local/java/</span><br><span class="line"><span class="comment">#配置java环境变量</span></span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.<span class="number">8.0</span>_171</span><br><span class="line">ENV JRE_HOME <span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JRE_HOME</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line">ENV PATH <span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212240177.png"  alt="在这里插入图片描述"><br>（4）执行命令构建镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t&#x3D;&#39;jdk1.8&#39; .</span><br></pre></td></tr></table></figure><p> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212313416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><ul><li>注意后边的空格和点，不要省略</li></ul><p>（5）查看镜像是否建立完成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2019100621233892.png"  alt="在这里插入图片描述"></p><h2 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h2><h3 id="7-1-私有仓库搭建与配置"><a href="#7-1-私有仓库搭建与配置" class="headerlink" title="7.1 私有仓库搭建与配置"></a>7.1 私有仓库搭建与配置</h3><p>（1）拉取私有仓库镜像（企业仓库）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212700706.png"  alt="在这里插入图片描述"></p><p>（2）启动私有仓库容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name&#x3D;registry -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212717830.png"  alt="在这里插入图片描述"></p><p>（3）打开浏览器 输入地址<a href="http://192.168.184.141:5000/v2/_catalog看到{&quot;repositories&quot;:[]}" target="_blank" rel="noopener">http://192.168.184.141:5000/v2/_catalog看到{&quot;repositories&quot;:[]}</a> 表示私有仓库搭建成功并且内容为空<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212735250.png"  alt="在这里插入图片描述"><br>（4）修改daemon.json</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><p>添加以下内容，保存退出。<br>{“insecure-registries”:[“192.168.184.141:5000”]}<br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212638249.png"  alt="在这里插入图片描述"><br>此步用于让 docker信任私有仓库地址<br>（5）重启docker 服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="7-2-镜像上传至私有仓库"><a href="#7-2-镜像上传至私有仓库" class="headerlink" title="7.2 镜像上传至私有仓库"></a>7.2 镜像上传至私有仓库</h3><p>（1）标记此镜像为私有仓库的镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag jdk1.8 192.168.184.141:5000&#x2F;jdk1.8</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212612925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>（2）再次启动私服容器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start registry</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212556615.png"  alt="在这里插入图片描述"></p><p>（3）上传标记的镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker push 192.168.184.141:5000&#x2F;jdk1.8</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/201910062125292.png"  alt="在这里插入图片描述"><br> <img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191006212539343.png"  alt="在这里插入图片描述"></p><p><em>最后，本文也参考了一些文章，因为也是第一次写博客，忘记将之前参考过的文章保存起来，如果大家有看到我引用没有标明的地方，请告知，谢谢！在学习的道路上，与君共勉。</em></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文读懂kmp算法</title>
      <link href="/2020/04/05/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82kmp%E7%AE%97%E6%B3%95/"/>
      <url>/2020/04/05/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82kmp%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="一、KMP算法是什么？"><a href="#一、KMP算法是什么？" class="headerlink" title="一、KMP算法是什么？"></a>一、KMP算法是什么？</h3><p>kmp算法是用于解决字符串匹配的算法;先来看一道例题<a href="https://www.nowcoder.com/practice/cb27a2cc0e8b41cbbdab7b0ca5c1bc23?tpId=98&tqId=32884&tPage=4&rp=4&ru=/ta/2019test&qru=/ta/2019test/question-ranking" target="_blank" rel="noopener">link</a></p><p><em>本文用约定用 <code>pat</code> 表示模式串，长度为 <code>M</code>，<code>txt</code> 表示文本串，长度为 <code>N</code>。KMP 算法是在 <code>txt</code> 中查找子串 <code>pat</code>，如果存在，返回这个子串的起始索引，否则返回 -1</em></p><p>首先来看一道例题：</p><blockquote><p>题目描述</p><p>字符串旋转:</p><p>给定两字符串A和B，如果能将A从中间某个位置分割为左右两部分字符串（都不为空串），并将左边的字符串移动到右边字符串后面组成新的字符串可以变为字符串B时返回true。</p><p>例如：如果A=‘youzan’，B=‘zanyou’，A按‘you’‘zan’切割换位后得到‘zanyou’和B相同返回true。</p><p>输入描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2个不为空的字符串(说明:输入一个字符串以英文分号&quot;;&quot;分割为2个字符串)</span><br><span class="line">例如:youzan;zanyou 即为A&#x3D;‘youzan’，B&#x3D;‘zanyou’</span><br></pre></td></tr></table></figure><p><em>输出描述:</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出true或false(表示是否能按要求匹配两个字符串)</span><br></pre></td></tr></table></figure><p>示例1</p><p><em>输入</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">youzan;zanyou</span><br></pre></td></tr></table></figure><p><em>输出</em></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure></blockquote><p>这里先给个取巧的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String a = s.nextLine();</span><br><span class="line">        s.close();</span><br><span class="line">        String[] m = a.split(<span class="string">";"</span>);</span><br><span class="line">        <span class="keyword">if</span>(m[<span class="number">0</span>].length()!=m[<span class="number">1</span>].length())&#123;</span><br><span class="line">            System.out.print(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m[<span class="number">0</span>] = m[<span class="number">0</span>]+m[<span class="number">0</span>];</span><br><span class="line">        System.out.print(m[<span class="number">0</span>].contains(m[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、为什么要用KMP算法？"><a href="#二、为什么要用KMP算法？" class="headerlink" title="二、为什么要用KMP算法？"></a>二、为什么要用KMP算法？</h3><p>我们知道从字符串中寻找子串的问题一般可以用暴力遍历来解决，每一次只能往后移动一个位置，且遇到不匹配的字符时，指针需要回溯，时间复杂度为O(n*m)</p><img src="/" class="lazyload" data-src="https://pic4.zhimg.com/v2-817073ca77f6c75d234392f207a3c81b_b.webp"  style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(String pat, String txt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = pat.length;</span><br><span class="line">    <span class="keyword">int</span> N = txt.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - M; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pat[j] != txt[i+j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pat 全都匹配了</span></span><br><span class="line">        <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// txt 中不存在 pat 子串</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP算法具有两个特性：</p><ol><li>仅仅后移模式串</li><li>指针不回溯</li></ol><p>什么意思呢？请看以下两种情况下的kmp算法</p><p>(1)txt = “aaaaaaab” pat = “aaab”</p><img src="/" class="lazyload" data-src="https://pic1.zhimg.com/v2-e66f7a92145c8e3ea8c87b5889fbaf54_b.webp"  style="zoom:67%;" /><p>(2) txt = “aaacaaab” pat = “aaab”：</p><img src="/" class="lazyload" data-src="https://pic1.zhimg.com/v2-f29d822e4faf22542875de6c73fe07d0_b.webp"  style="zoom:67%;" /><p>到此为止大家应该已经理解为什么要用kmp算法代替暴力遍历找子串了</p><h3 id="三、KMP怎么解决问题？"><a href="#三、KMP怎么解决问题？" class="headerlink" title="三、KMP怎么解决问题？"></a>三、KMP怎么解决问题？</h3><p><strong>现在来看看kmp如何实现</strong></p><p>首先我们可以知道显著的区别是遇到失配的情况主串不必再回退到当前的下一个字符开始匹配，而是保持不变，不进行回溯。由子串进行回溯重新匹配，而且回退之后，<strong>回退点之前的元素需要和主串匹配才行</strong>，这样主串才不用回退。那关键就在于子串回退的位置，它该回退多少的问题。</p><p>要保证一个模式串进行移动j位之后，回退点之前的元素仍然和主串匹配，说明模式串的(真)前后缀有一段是相同的。</p><h5 id="步骤1：解决回退几位的问题"><a href="#步骤1：解决回退几位的问题" class="headerlink" title="步骤1：解决回退几位的问题"></a>步骤1：解决回退几位的问题</h5><p>这里引入next[j]表示失配点j，对于字符串aaab它有以下几种情况(这里表示的都是真前后缀)</p><p>next[0]表示失配点在pat[0]=a这个位置，也就是它前面的元素为””，没有前缀与后缀，令next[0] = -1；</p><p>next[1]表示失配点在pat[1]=a这个位置，也就是它前面的元素为a，没有前缀与后缀，故next[0] = 0；</p><p>next[2]表示失配点在pat[2]=a这个位置，也就是它前面的元素为aa，有前缀与后缀a，故next[1] = 1；</p><p>next[3]表示失配点在pat[3]=b这个位置，也就是它前面的元素为aaa，有前缀与后缀aa，故next[2] = 2；</p><p>那就可以得到这串子串的部分匹配表</p><table><thead><tr><th>i</th><th align="right">0</th><th align="center">1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>pat[]</td><td align="right">a</td><td align="center">a</td><td>a</td><td>b</td></tr><tr><td>next[]</td><td align="right">-1</td><td align="center">0</td><td>1</td><td>2</td></tr></tbody></table><p>那现在用这个匹配表验证前面两种主串</p><p>(1)txt = “aaaaaaab” pat = “aaab”</p><img src="/" class="lazyload" data-src="https://pic1.zhimg.com/v2-e66f7a92145c8e3ea8c87b5889fbaf54_b.webp"  style="zoom:67%;" /><p>失配点 j = 3， pat[j] = b， next[j] = 2；也就是说j回退到2的位置，往回走1位， 即pat[2] = a</p><p>(2)txt = “aaacaaab” pat = “aaab”：</p><img src="/" class="lazyload" data-src="https://pic1.zhimg.com/v2-f29d822e4faf22542875de6c73fe07d0_b.webp"  style="zoom:67%;" /><p>图片是经过优化算法得出的步骤，因为知道子串中未出现过c，所以可以直接回退到起点，但算法优化前是按照下面流程走的：</p><p>第一次: 失配点 j = 3， pat[j] = b， next[j] = 2；j回退到2的位置， 即pat[2] = a</p><p>第二次: 失配点 j = 2， pat[j] = a， next[j] = 1；j回退到1的位置， 即pat[1] = a</p><p>第三次: 失配点 j = 1， pat[j] = a， next[j] = 0；j回退到next[j]的位置， 即pat[0] = a</p><p>第四次: 失配点 j = 0， pat[j] = a， next[j] = -1;  j回退到next[j]的位置， 即pat[-1] = “”</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] txt, <span class="keyword">char</span>[] pat)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(pat);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; txt.length &amp;&amp; j &lt; pat.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (txt[i] == pat[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[j] != -<span class="number">1</span>) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// next[j] = -1说明这时已经在头部位置之前了</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == pat.length ? i-j : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="步骤2：解决求next数组的问题"><a href="#步骤2：解决求next数组的问题" class="headerlink" title="步骤2：解决求next数组的问题"></a>步骤2：解决求next数组的问题</h5><p>使用双指针遍历该位置前的串中前后缀相同的值，可令next[0] = -1，代表无匹配，回退到该字符串前一位置；</p><p>令next[1] = 0，真前后缀是不包含自身的。</p><p>图片链接：<a href="https://upload-images.jianshu.io/upload_images/11023579-8e5da803cfa21d91.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/11023579-8e5da803cfa21d91.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp</a></p><p>代码如下: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">public class static int[] getNext(char[] pat)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; pat.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pat[i-<span class="number">1</span>] == pat[j])&#123;</span><br><span class="line">                next[i] = j + <span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 首尾匹配，但次前缀和次后缀不匹配；</span></span><br><span class="line">                <span class="comment">// 那该位置的值就等于子串次前缀位置的值</span></span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 首尾不匹配</span></span><br><span class="line">                next[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] txt, <span class="keyword">char</span>[] pat)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = getNext(pat);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; txt.length &amp;&amp; j &lt; pat.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (txt[i] == pat[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[j] != -<span class="number">1</span>) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// next[j] = -1说明这时已经在头部位置之前了</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == pat.length ? i-j : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] pat)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pat.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; pat.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pat[i-<span class="number">1</span>] == pat[j])&#123;</span><br><span class="line">                next[i] = j + <span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 首尾匹配，但次前缀和次后缀不匹配；</span></span><br><span class="line">                <span class="comment">// 那该位置的值就等于子串次前缀位置的值</span></span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 首尾不匹配</span></span><br><span class="line">                next[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String s1 = str.split(<span class="string">";"</span>)[<span class="number">0</span>];</span><br><span class="line">        String s2 = str.split(<span class="string">";"</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s1.length() != s2.length()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"false"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转化为判断txt是否包含sub</span></span><br><span class="line">        String txt = s1 + s1;</span><br><span class="line">        String sub = s2;</span><br><span class="line">        System.out.println(</span><br><span class="line">            kmp(txt.toCharArray(), sub.toCharArray())==-<span class="number">1</span>?<span class="keyword">false</span>:<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> kmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文讲懂RPC</title>
      <link href="/2020/04/04/%E4%B8%80%E6%96%87%E8%AE%B2%E6%87%82RPC/"/>
      <url>/2020/04/04/%E4%B8%80%E6%96%87%E8%AE%B2%E6%87%82RPC/</url>
      
        <content type="html"><![CDATA[<h2 id="一文讲懂RPC"><a href="#一文讲懂RPC" class="headerlink" title="一文讲懂RPC"></a>一文讲懂RPC</h2><h3 id="一、什么是RPC？"><a href="#一、什么是RPC？" class="headerlink" title="一、什么是RPC？"></a>一、什么是RPC？</h3><p>简而言之：远程调用函数</p><p>本地调用函数:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">int</span> <span class="title">Multiply</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="keyword">int</span> y = l * r;</span><br><span class="line"><span class="number">3</span>    <span class="keyword">return</span> y;</span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="number">6</span> <span class="keyword">int</span> lvalue = <span class="number">10</span>;</span><br><span class="line"><span class="number">7</span> <span class="keyword">int</span> rvalue = <span class="number">20</span>;</span><br><span class="line"><span class="number">8</span> <span class="keyword">int</span> l_times_r = Multiply(lvalue, rvalue);</span><br></pre></td></tr></table></figure><p>远程调用存在的问题</p><ol><li><strong>Call ID映射</strong>。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 &lt;–&gt; Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</li><li><strong>序列化和反序列化</strong>。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</li><li><strong>网络传输</strong>。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo的基本配置--相册</title>
      <link href="/2020/04/03/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE-%E7%9B%B8%E5%86%8C/"/>
      <url>/2020/04/03/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE-%E7%9B%B8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><h2 id="生成目录配置"><a href="#生成目录配置" class="headerlink" title="生成目录配置"></a>生成目录配置</h2><h2 id="相簿配置"><a href="#相簿配置" class="headerlink" title="相簿配置"></a>相簿配置</h2><p>在自己博客主目录下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page album</span><br></pre></td></tr></table></figure><p>会在source目录下生成source\album\index.md<br>生成的index.md即是相册模块的配置文件, 在这个文件中添加以下代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 相册</span><br><span class="line">date: 2020-04-03 17:45:19</span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br><span class="line">&lt;div class=<span class="string">"gallery-group-main"</span>&gt;</span><br><span class="line">&#123;% galleryGroup <span class="string">'相册1'</span> <span class="string">'做过的一些项目'</span> <span class="string">'/album/相册1'</span> https://xxx[存放图片的途径] %&#125;</span><br><span class="line">&#123;% galleryGroup <span class="string">'相册2'</span> <span class="string">'看见过的好设计'</span> <span class="string">'/album/相册2'</span> https://i.loli.net/2020/04/03/S42oQ9tvH6GEPqV.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup <span class="string">'生活'</span> <span class="string">'关于生活'</span> <span class="string">'/album/life'</span> https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %&#125;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="相册配置"><a href="#相册配置" class="headerlink" title="相册配置"></a>相册配置</h2><p>完成上面的配置后会发现少了 <code>/album/相册1</code> 这样的目录，故需自己创建; 在album下再创建相册1文件夹.<br>里面同样需要上面的配置文件index.md, 包含以下代码; 主要就是自己的图片链接, 推荐图床 <a href="https://sm.ms/" target="_blank" rel="noopener">https://sm.ms/</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 生活</span><br><span class="line">date: 2020-04-03 20:44:55</span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](https://gratisography.com/wp-content/uploads/2019/10/gratisography-scary-pumpkin-hand-900x600.jpg)</span><br><span class="line">![](https://gratisography.com/wp-content/uploads/2019/10/gratisography-fresh-fish-dinner-900x600.jpg)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>这样就搞定啦</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/13/hello-world/"/>
      <url>/2020/03/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
