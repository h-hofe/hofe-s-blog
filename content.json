{"meta":{"title":"hofe's blog","subtitle":"","description":"","author":"hofe","url":"http://hofe.work","root":"/"},"pages":[{"title":"关于","date":"2020-04-03T09:41:12.000Z","updated":"2020-04-04T12:01:03.157Z","comments":false,"path":"about/index.html","permalink":"http://hofe.work/about/index.html","excerpt":"","text":"Hofe 我 想 用 砂 砾 和 泥 土 堆 出 山 川 立志要用自己的方式推动社会进步的青年。摸索、实现的过程可能很漫长，最后也可能会无疾而终，但一定要时刻激励自己朝着这个目标前进。 联系方式 Weibo: hofe_H Instagram: hofe_h Email: hhf.work@foxmail.com Github: https://github.com/hhf443 CSDN: https://blog.csdn.net/qq_41011723 技能 掌握HTML、CSS及JavaScript等前端开发技术，能使用Vue、React框架搭建网站 掌握Java语言，熟悉Spring、Hibernate、Mybatis、Springboot等常用后端框架，了解装饰、单例、代理等常用设计模式 熟悉TCP/IP协议，HTTP协议 了解MySQL数据库的应用开发与管理，具备MySQL索引优化、查询优化的能力 了解Linux操作系统，包括服务器配置及环境搭建 熟悉Idea，Git，Maven等开发工具、项目管理和项目构建工具 技术栈 HTML+CSS+JSVue React Spring springbootMybatis HibernateDubbo+zookeeper SpringCloud Flask Django爬虫 数据分析 深度学习"},{"title":"相册","date":"2020-04-03T09:45:19.000Z","updated":"2020-04-04T08:31:35.402Z","comments":false,"path":"album/index.html","permalink":"http://hofe.work/album/index.html","excerpt":"","text":"作品 做过的一些项目 设计 看见过的好设计 生活 关于生活 旅行 遇见世界 美图 收藏图片 摄影 记录美好"},{"title":"分类","date":"2020-04-02T05:02:28.000Z","updated":"2020-04-04T12:01:21.745Z","comments":false,"path":"categories/index.html","permalink":"http://hofe.work/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-04-03T09:44:21.000Z","updated":"2020-04-04T12:01:39.163Z","comments":true,"path":"messageboard/index.html","permalink":"http://hofe.work/messageboard/index.html","excerpt":"","text":"有什么问题可以留言~14 14.不一定会回就是了^_^"},{"title":"标签","date":"2020-04-02T05:01:27.000Z","updated":"2020-04-04T12:00:56.106Z","comments":false,"path":"tags/index.html","permalink":"http://hofe.work/tags/index.html","excerpt":"","text":""},{"title":"??","date":"2020-04-03T12:44:55.000Z","updated":"2020-04-04T08:16:29.275Z","comments":false,"path":"album/design/index.html","permalink":"http://hofe.work/album/design/index.html","excerpt":"","text":""},{"title":"生活","date":"2020-04-03T12:44:55.000Z","updated":"2020-04-04T08:16:56.872Z","comments":false,"path":"album/life/index.html","permalink":"http://hofe.work/album/life/index.html","excerpt":"","text":""},{"title":"摄影","date":"2020-04-03T12:44:55.000Z","updated":"2020-04-04T08:17:51.530Z","comments":false,"path":"album/photograph/index.html","permalink":"http://hofe.work/album/photograph/index.html","excerpt":"","text":""},{"title":"美图","date":"2020-04-03T12:44:55.000Z","updated":"2020-04-04T08:27:56.452Z","comments":false,"path":"album/wallpaper/index.html","permalink":"http://hofe.work/album/wallpaper/index.html","excerpt":"","text":""},{"title":"作品","date":"2020-04-03T12:44:55.000Z","updated":"2020-04-04T08:28:01.998Z","comments":false,"path":"album/works/index.html","permalink":"http://hofe.work/album/works/index.html","excerpt":"","text":""},{"title":"旅行","date":"2020-04-03T12:44:55.000Z","updated":"2020-04-04T08:28:00.578Z","comments":false,"path":"album/travel/index.html","permalink":"http://hofe.work/album/travel/index.html","excerpt":"","text":""}],"posts":[{"title":"一文读懂kmp算法","slug":"一文读懂kmp算法","date":"2020-04-05T08:28:00.000Z","updated":"2020-04-05T09:19:52.288Z","comments":true,"path":"2020/04/05/一文读懂kmp算法/","link":"","permalink":"http://hofe.work/2020/04/05/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82kmp%E7%AE%97%E6%B3%95/","excerpt":"","text":"一、KMP算法是什么？kmp算法是用于解决字符串匹配的算法;先来看一道例题link 本文用约定用 pat 表示模式串，长度为 M，txt 表示文本串，长度为 N。KMP 算法是在 txt 中查找子串 pat，如果存在，返回这个子串的起始索引，否则返回 -1 首先来看一道例题： 题目描述 字符串旋转: 给定两字符串A和B，如果能将A从中间某个位置分割为左右两部分字符串（都不为空串），并将左边的字符串移动到右边字符串后面组成新的字符串可以变为字符串B时返回true。 例如：如果A=‘youzan’，B=‘zanyou’，A按‘you’‘zan’切割换位后得到‘zanyou’和B相同返回true。 输入描述: 2个不为空的字符串(说明:输入一个字符串以英文分号&quot;;&quot;分割为2个字符串)例如:youzan;zanyou 即为A&#x3D;‘youzan’，B&#x3D;‘zanyou’ 输出描述: 输出true或false(表示是否能按要求匹配两个字符串) 示例1 输入 youzan;zanyou 输出 true 这里先给个取巧的方法 import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner s = new Scanner(System.in); String a = s.nextLine(); s.close(); String[] m = a.split(\";\"); if(m[0].length()!=m[1].length())&#123; System.out.print(false); return; &#125; m[0] = m[0]+m[0]; System.out.print(m[0].contains(m[1])); &#125;&#125; 二、为什么要用KMP算法？我们知道从字符串中寻找子串的问题一般可以用暴力遍历来解决，每一次只能往后移动一个位置，且遇到不匹配的字符时，指针需要回溯，时间复杂度为O(n*m) int search(String pat, String txt) &#123; int M = pat.length; int N = txt.length; for (int i = 0; i &lt; N - M; i++) &#123; int j; for (j = 0; j &lt; M; j++) &#123; if (pat[j] != txt[i+j]) break; &#125; // pat 全都匹配了 if (j == M) return i; &#125; // txt 中不存在 pat 子串 return -1;&#125; KMP算法具有两个特性： 仅仅后移模式串 指针不回溯 什么意思呢？请看以下两种情况下的kmp算法 (1)txt = “aaaaaaab” pat = “aaab” (2) txt = “aaacaaab” pat = “aaab”： 到此为止大家应该已经理解为什么要用kmp算法代替暴力遍历找子串了 三、KMP怎么解决问题？现在来看看kmp如何实现 首先我们可以知道显著的区别是遇到失配的情况主串不必再回退到当前的下一个字符开始匹配，而是保持不变，不进行回溯。由子串进行回溯重新匹配，而且回退之后，回退点之前的元素需要和主串匹配才行，这样主串才不用回退。那关键就在于子串回退的位置，它该回退多少的问题。 要保证一个模式串进行移动j位之后，回退点之前的元素仍然和主串匹配，说明模式串的(真)前后缀有一段是相同的。 步骤1：解决回退几位的问题这里引入next[j]表示失配点j，对于字符串aaab它有以下几种情况(这里表示的都是真前后缀) next[0]表示失配点在pat[0]=a这个位置，也就是它前面的元素为””，没有前缀与后缀，令next[0] = -1； next[1]表示失配点在pat[1]=a这个位置，也就是它前面的元素为a，没有前缀与后缀，故next[0] = 0； next[2]表示失配点在pat[2]=a这个位置，也就是它前面的元素为aa，有前缀与后缀a，故next[1] = 1； next[3]表示失配点在pat[3]=b这个位置，也就是它前面的元素为aaa，有前缀与后缀aa，故next[2] = 2； 那就可以得到这串子串的部分匹配表 i 0 1 2 3 pat[] a a a b next[] -1 0 1 2 那现在用这个匹配表验证前面两种主串 (1)txt = “aaaaaaab” pat = “aaab” 失配点 j = 3， pat[j] = b， next[j] = 2；也就是说j回退到2的位置，往回走1位， 即pat[2] = a (2)txt = “aaacaaab” pat = “aaab”： 图片是经过优化算法得出的步骤，因为知道子串中未出现过c，所以可以直接回退到起点，但算法优化前是按照下面流程走的： 第一次: 失配点 j = 3， pat[j] = b， next[j] = 2；j回退到2的位置， 即pat[2] = a 第二次: 失配点 j = 2， pat[j] = a， next[j] = 1；j回退到1的位置， 即pat[1] = a 第三次: 失配点 j = 1， pat[j] = a， next[j] = 0；j回退到next[j]的位置， 即pat[0] = a 第四次: 失配点 j = 0， pat[j] = a， next[j] = -1; j回退到next[j]的位置， 即pat[-1] = “” 代码如下： public static int kmp(char[] txt, char[] pat)&#123; int[] next = getNext(pat); int i = 0, j = 0; while (i &lt; txt.length &amp;&amp; j &lt; pat.length) &#123; if (txt[i] == pat[j]) &#123; i++; j++; &#125; else if (next[j] != -1) &#123; j = next[j]; &#125; else &#123; // next[j] = -1说明这时已经在头部位置之前了 i++; &#125; &#125; return j == pat.length ? i-j : -1; &#125; 步骤2：解决求next数组的问题使用双指针遍历该位置前的串中前后缀相同的值，可令next[0] = -1，代表无匹配，回退到该字符串前一位置； 令next[1] = 0，真前后缀是不包含自身的。 图片链接：https://upload-images.jianshu.io/upload_images/11023579-8e5da803cfa21d91.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp 代码如下: public class static int[] getNext(char[] pat)&#123; int[] next = new int[arr.length]; next[0] = -1; next[1] = 0; int i = 2; int j = 0; while(i &lt; pat.length)&#123; if(pat[i-1] == pat[j])&#123; next[i] = j + 1; i++; j++; &#125;else if(j &gt; 0)&#123; // 首尾匹配，但次前缀和次后缀不匹配； // 那该位置的值就等于子串次前缀位置的值 j = next[j]; &#125;else&#123; // 首尾不匹配 next[i] = 0; i++; &#125; &#125; return next; &#125; 完整代码： import java.util.*;public class Main&#123; public static int kmp(char[] txt, char[] pat)&#123; int[] next = getNext(pat); int i = 0, j = 0; while (i &lt; txt.length &amp;&amp; j &lt; pat.length) &#123; if (txt[i] == pat[j]) &#123; i++; j++; &#125; else if (next[j] != -1) &#123; j = next[j]; &#125; else &#123; // next[j] = -1说明这时已经在头部位置之前了 i++; &#125; &#125; return j == pat.length ? i-j : -1; &#125; public static int[] getNext(char[] pat)&#123; int[] next = new int[pat.length]; next[0] = -1; next[1] = 0; int i = 2; int j = 0; while(i &lt; pat.length)&#123; if(pat[i-1] == pat[j])&#123; next[i] = j + 1; i++; j++; &#125;else if(j &gt; 0)&#123; // 首尾匹配，但次前缀和次后缀不匹配； // 那该位置的值就等于子串次前缀位置的值 j = next[j]; &#125;else&#123; // 首尾不匹配 next[i] = 0; i++; &#125; &#125; return next; &#125; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String s1 = str.split(\";\")[0]; String s2 = str.split(\";\")[1]; if (s1.length() != s2.length()) &#123; System.out.println(\"false\"); return; &#125; // 转化为判断txt是否包含sub String txt = s1 + s1; String sub = s2; System.out.println( kmp(txt.toCharArray(), sub.toCharArray())==-1?false:true); &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://hofe.work/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hofe.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"kmp","slug":"kmp","permalink":"http://hofe.work/tags/kmp/"}]},{"title":"一文讲懂RPC","slug":"一文讲懂RPC","date":"2020-04-04T13:56:22.581Z","updated":"2020-04-04T14:08:15.353Z","comments":true,"path":"2020/04/04/一文讲懂RPC/","link":"","permalink":"http://hofe.work/2020/04/04/%E4%B8%80%E6%96%87%E8%AE%B2%E6%87%82RPC/","excerpt":"","text":"一文讲懂RPC一、什么是RPC？简而言之：远程调用函数 本地调用函数: 1 int Multiply(int l, int r) &#123;2 int y = l * r;3 return y;4 &#125;5 6 int lvalue = 10;7 int rvalue = 20;8 int l_times_r = Multiply(lvalue, rvalue); 远程调用存在的问题 Call ID映射。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 &lt;–&gt; Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。 序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。 网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。","categories":[],"tags":[]},{"title":"hexo的基本配置--相册","slug":"hexo的基本配置-相册","date":"2020-04-03T13:22:20.000Z","updated":"2020-04-03T13:38:19.441Z","comments":true,"path":"2020/04/03/hexo的基本配置-相册/","link":"","permalink":"http://hofe.work/2020/04/03/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE-%E7%9B%B8%E5%86%8C/","excerpt":"","text":"效果展示生成目录配置相簿配置在自己博客主目录下 hexo new page album 会在source目录下生成source\\album\\index.md生成的index.md即是相册模块的配置文件, 在这个文件中添加以下代码 ---title: 相册date: 2020-04-03 17:45:19comments: false---&lt;div class=\"gallery-group-main\"&gt;&#123;% galleryGroup '相册1' '做过的一些项目' '/album/相册1' https://xxx[存放图片的途径] %&#125;&#123;% galleryGroup '相册2' '看见过的好设计' '/album/相册2' https://i.loli.net/2020/04/03/S42oQ9tvH6GEPqV.jpg %&#125;&#123;% galleryGroup '生活' '关于生活' '/album/life' https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %&#125;&lt;/div&gt; 相册配置完成上面的配置后会发现少了 /album/相册1 这样的目录，故需自己创建; 在album下再创建相册1文件夹.里面同样需要上面的配置文件index.md, 包含以下代码; 主要就是自己的图片链接, 推荐图床 https://sm.ms/ ---title: 生活date: 2020-04-03 20:44:55comments: false---&#123;% gallery %&#125;![](https://gratisography.com/wp-content/uploads/2019/10/gratisography-scary-pumpkin-hand-900x600.jpg)![](https://gratisography.com/wp-content/uploads/2019/10/gratisography-fresh-fish-dinner-900x600.jpg)&#123;% endgallery %&#125; 这样就搞定啦","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://hofe.work/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-12T16:00:00.000Z","updated":"2020-04-05T08:27:24.897Z","comments":true,"path":"2020/03/13/hello-world/","link":"","permalink":"http://hofe.work/2020/03/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://hofe.work/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://hofe.work/tags/hexo/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://hofe.work/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"hexo","slug":"hexo","permalink":"http://hofe.work/categories/hexo/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hofe.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"kmp","slug":"kmp","permalink":"http://hofe.work/tags/kmp/"},{"name":"hexo","slug":"hexo","permalink":"http://hofe.work/tags/hexo/"}]}