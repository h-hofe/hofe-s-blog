{"meta":{"title":"hofe's blog","subtitle":"","description":"","author":"hofe","url":"http://hofe.work","root":"/"},"pages":[{"title":"关于","date":"2020-04-03T09:41:12.000Z","updated":"2020-04-04T12:01:03.157Z","comments":false,"path":"about/index.html","permalink":"http://hofe.work/about/index.html","excerpt":"","text":"Hofe 我 想 用 砂 砾 和 泥 土 堆 出 山 川 立志要用自己的方式推动社会进步的青年。摸索、实现的过程可能很漫长，最后也可能会无疾而终，但一定要时刻激励自己朝着这个目标前进。 联系方式 Weibo: hofe_H Instagram: hofe_h Email: hhf.work@foxmail.com Github: https://github.com/hhf443 CSDN: https://blog.csdn.net/qq_41011723 技能 掌握HTML、CSS及JavaScript等前端开发技术，能使用Vue、React框架搭建网站 掌握Java语言，熟悉Spring、Hibernate、Mybatis、Springboot等常用后端框架，了解装饰、单例、代理等常用设计模式 熟悉TCP/IP协议，HTTP协议 了解MySQL数据库的应用开发与管理，具备MySQL索引优化、查询优化的能力 了解Linux操作系统，包括服务器配置及环境搭建 熟悉Idea，Git，Maven等开发工具、项目管理和项目构建工具 技术栈 HTML+CSS+JSVue React Spring springbootMybatis HibernateDubbo+zookeeper SpringCloud Flask Django爬虫 数据分析 深度学习"},{"title":"相册","date":"2020-04-03T09:45:19.000Z","updated":"2020-04-04T08:31:35.402Z","comments":false,"path":"album/index.html","permalink":"http://hofe.work/album/index.html","excerpt":"","text":"作品 做过的一些项目 设计 看见过的好设计 生活 关于生活 旅行 遇见世界 美图 收藏图片 摄影 记录美好"},{"title":"分类","date":"2020-04-02T05:02:28.000Z","updated":"2020-04-04T12:01:21.745Z","comments":false,"path":"categories/index.html","permalink":"http://hofe.work/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-02T05:01:27.000Z","updated":"2020-04-04T12:00:56.106Z","comments":false,"path":"tags/index.html","permalink":"http://hofe.work/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-04-03T09:44:21.000Z","updated":"2020-04-04T12:01:39.163Z","comments":true,"path":"messageboard/index.html","permalink":"http://hofe.work/messageboard/index.html","excerpt":"","text":"有什么问题可以留言~14 14.不一定会回就是了^_^"},{"title":"??","date":"2020-04-03T12:44:55.000Z","updated":"2020-04-04T08:16:29.275Z","comments":false,"path":"album/design/index.html","permalink":"http://hofe.work/album/design/index.html","excerpt":"","text":""},{"title":"摄影","date":"2020-04-03T12:44:55.000Z","updated":"2020-04-04T08:17:51.530Z","comments":false,"path":"album/photograph/index.html","permalink":"http://hofe.work/album/photograph/index.html","excerpt":"","text":""},{"title":"生活","date":"2020-04-03T12:44:55.000Z","updated":"2020-04-04T08:16:56.872Z","comments":false,"path":"album/life/index.html","permalink":"http://hofe.work/album/life/index.html","excerpt":"","text":""},{"title":"旅行","date":"2020-04-03T12:44:55.000Z","updated":"2020-04-04T08:28:00.578Z","comments":false,"path":"album/travel/index.html","permalink":"http://hofe.work/album/travel/index.html","excerpt":"","text":""},{"title":"美图","date":"2020-04-03T12:44:55.000Z","updated":"2020-04-04T08:27:56.452Z","comments":false,"path":"album/wallpaper/index.html","permalink":"http://hofe.work/album/wallpaper/index.html","excerpt":"","text":""},{"title":"作品","date":"2020-04-03T12:44:55.000Z","updated":"2020-04-04T08:28:01.998Z","comments":false,"path":"album/works/index.html","permalink":"http://hofe.work/album/works/index.html","excerpt":"","text":""}],"posts":[{"title":"一篇入门docker","slug":"一篇入门docker","date":"2020-04-05T13:17:57.000Z","updated":"2020-04-05T13:21:45.315Z","comments":true,"path":"2020/04/05/一篇入门docker/","link":"","permalink":"http://hofe.work/2020/04/05/%E4%B8%80%E7%AF%87%E5%85%A5%E9%97%A8docker/","excerpt":"","text":"一篇学会Docker 这里给出几个好的学习资源分享给大家一起学习 本文也是参考如下课程编写，转载请注明出处 docker入门：https://www.bilibili.com/video/av55377411/ docker详细：https://www.bilibili.com/video/av27122140/ Docker简介1.1 什么是DockerDocker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker，就不用担心环境问题。 总体来说，Docker的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。1.2 容器与虚拟机比较下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 启动快：启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。 资源占用少：容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所以资源。另外，多个容器可以共享资源，虚拟机都是独享资源。 体积小：容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。 1.3 Docker 组件1.3.1 Docker镜像与容器、仓库镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。 容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 docker 面向对象 容器 对象 镜像 类 概念 解释 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板。 容器(Container) 容器是独立运行的一个或一组应用。 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。 Docker安装与启动2.1 安装Docker Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 这部分我会单独提供一份基于Ubuntu的Nvidia-docker安装与启动 可以点击这里查看 2.3 Docker的启动与停止systemctl命令是系统服务管理器指令启动docker： systemctl start docker 停止docker： systemctl stop docker 重启docker： systemctl restart docker 查看docker状态： systemctl status docker 开机启动： systemctl enable docker 查看docker概要信息 docker info 查看docker帮助文档 docker --help 常用命令3.1 镜像相关命令3.1.1 查看镜像docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 3.1.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 docker search 镜像名称 也可以从镜像库中查找： https://hub.docker.com/ NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 3.1.3 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 docker pull 镜像名称(默认最新) 例如，我要下载centos7镜像(指定版本) docker pull centos:7 3.1.4 删除镜像按镜像ID删除镜像 docker rmi 镜像ID 删除所有镜像 docker rmi &#96;docker images -q&#96; docker images –q:查询所有镜像的ID，并作为rmi的参数 3.2 容器相关命令3.2.1 查看容器查看正在运行的容器 docker ps 查看所有容器 docker ps –a 查看最后一次运行的容器 docker ps –l 查看停止的容器 docker ps -f status&#x3D;exited 3.2.2 创建与启动容器创建容器常用的参数说明：创建容器命令： docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器交互式：前台打开，exit时关机 docker run -it --name&#x3D;容器名称 镜像名称:标签 &#x2F;bin&#x2F;bash（进入命令行） 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 exit （2）守护式方式创建容器：守护式：后台运行 docker run -di --name&#x3D;容器名称 镜像名称:标签 登录守护式容器方式： docker exec -it 容器名称 (或者容器ID) &#x2F;bin&#x2F;bash exit不会直接关机而是后台继续运行 3.2.3 停止与启动容器停止容器： docker stop 容器名称（或者容器ID） 启动容器：docker start 容器名称（或者容器ID） 3.2.4 文件拷贝如果我们需要将文件拷贝到容器内可以使用cp命令 docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 docker cp 容器名称:容器目录 需要拷贝的文件或目录 3.2.5 目录挂载（共享目录）我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： docker run -di -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml --name&#x3D;mycentos3 centos:7 容器目录：宿主机目录 3.2.6 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; 容器名称（容器ID） 3.2.7 删除容器删除指定的容器：（需先停止） docker rm 容器名称（容器ID） 应用部署4.1 MySQL部署（1）拉取mysql镜像 docker pull centos&#x2F;mysql-57-centos7 （2）创建容器 docker run -di --name&#x3D;tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql连接宿主机的IP ,指定端口为33306 4.2 tomcat部署（1）拉取镜像 docker pull tomcat:7-jre7 （2）创建容器创建容器 -p表示地址映射 docker run -di --name&#x3D;mytomcat -p 9000:8080 -v &#x2F;usr&#x2F;local&#x2F;webapps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps tomcat:7-jre7 4.3 Nginx部署（1）拉取镜像 docker pull nginx （2）创建Nginx容器 docker run -di --name&#x3D;mynginx -p 80:80 nginx 4.4 Redis部署（1）拉取镜像 docker pull redis （2）创建容器 docker run -di --name&#x3D;myredis -p 6379:6379 redis 迁移与备份5.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 docker commit mynginx mynginx_i 通过保存的mynginx_i镜像创建基于mynginx_i的容器mynginx2 5.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 docker save -o mynginx.tar mynginx_i 5.3 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 Dockerfile6.1 什么是DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 对于开发人员：可以为开发团队提供一个完全一致的开发环境； 对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了； 对于运维人员：在部署时，可以实现应用的无缝移植。 6.2 常用命令 6.1 使用脚本创建镜像步骤：（1）创建目录 mkdir –p &#x2F;usr&#x2F;local&#x2F;dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile #依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 docker build -t&#x3D;&#39;jdk1.8&#39; . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 docker images Docker私有仓库7.1 私有仓库搭建与配置（1）拉取私有仓库镜像（企业仓库） docker pull registry （2）启动私有仓库容器 docker run -di --name&#x3D;registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到{&quot;repositories&quot;:[]} 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json vi &#x2F;etc&#x2F;docker&#x2F;daemon.json 添加以下内容，保存退出。{“insecure-registries”:[“192.168.184.141:5000”]} 此步用于让 docker信任私有仓库地址（5）重启docker 服务 systemctl restart docker 7.2 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 docker tag jdk1.8 192.168.184.141:5000&#x2F;jdk1.8 （2）再次启动私服容器 docker start registry （3）上传标记的镜像 docker push 192.168.184.141:5000&#x2F;jdk1.8 最后，本文也参考了一些文章，因为也是第一次写博客，忘记将之前参考过的文章保存起来，如果大家有看到我引用没有标明的地方，请告知，谢谢！在学习的道路上，与君共勉。","categories":[{"name":"docker","slug":"docker","permalink":"http://hofe.work/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://hofe.work/tags/docker/"}]},{"title":"一文读懂kmp算法","slug":"一文读懂kmp算法","date":"2020-04-05T08:28:00.000Z","updated":"2020-04-05T09:19:52.288Z","comments":true,"path":"2020/04/05/一文读懂kmp算法/","link":"","permalink":"http://hofe.work/2020/04/05/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82kmp%E7%AE%97%E6%B3%95/","excerpt":"","text":"一、KMP算法是什么？kmp算法是用于解决字符串匹配的算法;先来看一道例题link 本文用约定用 pat 表示模式串，长度为 M，txt 表示文本串，长度为 N。KMP 算法是在 txt 中查找子串 pat，如果存在，返回这个子串的起始索引，否则返回 -1 首先来看一道例题： 题目描述 字符串旋转: 给定两字符串A和B，如果能将A从中间某个位置分割为左右两部分字符串（都不为空串），并将左边的字符串移动到右边字符串后面组成新的字符串可以变为字符串B时返回true。 例如：如果A=‘youzan’，B=‘zanyou’，A按‘you’‘zan’切割换位后得到‘zanyou’和B相同返回true。 输入描述: 2个不为空的字符串(说明:输入一个字符串以英文分号&quot;;&quot;分割为2个字符串)例如:youzan;zanyou 即为A&#x3D;‘youzan’，B&#x3D;‘zanyou’ 输出描述: 输出true或false(表示是否能按要求匹配两个字符串) 示例1 输入 youzan;zanyou 输出 true 这里先给个取巧的方法 import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner s = new Scanner(System.in); String a = s.nextLine(); s.close(); String[] m = a.split(\";\"); if(m[0].length()!=m[1].length())&#123; System.out.print(false); return; &#125; m[0] = m[0]+m[0]; System.out.print(m[0].contains(m[1])); &#125;&#125; 二、为什么要用KMP算法？我们知道从字符串中寻找子串的问题一般可以用暴力遍历来解决，每一次只能往后移动一个位置，且遇到不匹配的字符时，指针需要回溯，时间复杂度为O(n*m) int search(String pat, String txt) &#123; int M = pat.length; int N = txt.length; for (int i = 0; i &lt; N - M; i++) &#123; int j; for (j = 0; j &lt; M; j++) &#123; if (pat[j] != txt[i+j]) break; &#125; // pat 全都匹配了 if (j == M) return i; &#125; // txt 中不存在 pat 子串 return -1;&#125; KMP算法具有两个特性： 仅仅后移模式串 指针不回溯 什么意思呢？请看以下两种情况下的kmp算法 (1)txt = “aaaaaaab” pat = “aaab” (2) txt = “aaacaaab” pat = “aaab”： 到此为止大家应该已经理解为什么要用kmp算法代替暴力遍历找子串了 三、KMP怎么解决问题？现在来看看kmp如何实现 首先我们可以知道显著的区别是遇到失配的情况主串不必再回退到当前的下一个字符开始匹配，而是保持不变，不进行回溯。由子串进行回溯重新匹配，而且回退之后，回退点之前的元素需要和主串匹配才行，这样主串才不用回退。那关键就在于子串回退的位置，它该回退多少的问题。 要保证一个模式串进行移动j位之后，回退点之前的元素仍然和主串匹配，说明模式串的(真)前后缀有一段是相同的。 步骤1：解决回退几位的问题这里引入next[j]表示失配点j，对于字符串aaab它有以下几种情况(这里表示的都是真前后缀) next[0]表示失配点在pat[0]=a这个位置，也就是它前面的元素为””，没有前缀与后缀，令next[0] = -1； next[1]表示失配点在pat[1]=a这个位置，也就是它前面的元素为a，没有前缀与后缀，故next[0] = 0； next[2]表示失配点在pat[2]=a这个位置，也就是它前面的元素为aa，有前缀与后缀a，故next[1] = 1； next[3]表示失配点在pat[3]=b这个位置，也就是它前面的元素为aaa，有前缀与后缀aa，故next[2] = 2； 那就可以得到这串子串的部分匹配表 i 0 1 2 3 pat[] a a a b next[] -1 0 1 2 那现在用这个匹配表验证前面两种主串 (1)txt = “aaaaaaab” pat = “aaab” 失配点 j = 3， pat[j] = b， next[j] = 2；也就是说j回退到2的位置，往回走1位， 即pat[2] = a (2)txt = “aaacaaab” pat = “aaab”： 图片是经过优化算法得出的步骤，因为知道子串中未出现过c，所以可以直接回退到起点，但算法优化前是按照下面流程走的： 第一次: 失配点 j = 3， pat[j] = b， next[j] = 2；j回退到2的位置， 即pat[2] = a 第二次: 失配点 j = 2， pat[j] = a， next[j] = 1；j回退到1的位置， 即pat[1] = a 第三次: 失配点 j = 1， pat[j] = a， next[j] = 0；j回退到next[j]的位置， 即pat[0] = a 第四次: 失配点 j = 0， pat[j] = a， next[j] = -1; j回退到next[j]的位置， 即pat[-1] = “” 代码如下： public static int kmp(char[] txt, char[] pat)&#123; int[] next = getNext(pat); int i = 0, j = 0; while (i &lt; txt.length &amp;&amp; j &lt; pat.length) &#123; if (txt[i] == pat[j]) &#123; i++; j++; &#125; else if (next[j] != -1) &#123; j = next[j]; &#125; else &#123; // next[j] = -1说明这时已经在头部位置之前了 i++; &#125; &#125; return j == pat.length ? i-j : -1; &#125; 步骤2：解决求next数组的问题使用双指针遍历该位置前的串中前后缀相同的值，可令next[0] = -1，代表无匹配，回退到该字符串前一位置； 令next[1] = 0，真前后缀是不包含自身的。 图片链接：https://upload-images.jianshu.io/upload_images/11023579-8e5da803cfa21d91.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp 代码如下: public class static int[] getNext(char[] pat)&#123; int[] next = new int[arr.length]; next[0] = -1; next[1] = 0; int i = 2; int j = 0; while(i &lt; pat.length)&#123; if(pat[i-1] == pat[j])&#123; next[i] = j + 1; i++; j++; &#125;else if(j &gt; 0)&#123; // 首尾匹配，但次前缀和次后缀不匹配； // 那该位置的值就等于子串次前缀位置的值 j = next[j]; &#125;else&#123; // 首尾不匹配 next[i] = 0; i++; &#125; &#125; return next; &#125; 完整代码： import java.util.*;public class Main&#123; public static int kmp(char[] txt, char[] pat)&#123; int[] next = getNext(pat); int i = 0, j = 0; while (i &lt; txt.length &amp;&amp; j &lt; pat.length) &#123; if (txt[i] == pat[j]) &#123; i++; j++; &#125; else if (next[j] != -1) &#123; j = next[j]; &#125; else &#123; // next[j] = -1说明这时已经在头部位置之前了 i++; &#125; &#125; return j == pat.length ? i-j : -1; &#125; public static int[] getNext(char[] pat)&#123; int[] next = new int[pat.length]; next[0] = -1; next[1] = 0; int i = 2; int j = 0; while(i &lt; pat.length)&#123; if(pat[i-1] == pat[j])&#123; next[i] = j + 1; i++; j++; &#125;else if(j &gt; 0)&#123; // 首尾匹配，但次前缀和次后缀不匹配； // 那该位置的值就等于子串次前缀位置的值 j = next[j]; &#125;else&#123; // 首尾不匹配 next[i] = 0; i++; &#125; &#125; return next; &#125; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String s1 = str.split(\";\")[0]; String s2 = str.split(\";\")[1]; if (s1.length() != s2.length()) &#123; System.out.println(\"false\"); return; &#125; // 转化为判断txt是否包含sub String txt = s1 + s1; String sub = s2; System.out.println( kmp(txt.toCharArray(), sub.toCharArray())==-1?false:true); &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://hofe.work/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://hofe.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"kmp","slug":"kmp","permalink":"http://hofe.work/tags/kmp/"}]},{"title":"一文讲懂RPC","slug":"一文讲懂RPC","date":"2020-04-04T13:56:22.581Z","updated":"2020-04-04T14:08:15.353Z","comments":true,"path":"2020/04/04/一文讲懂RPC/","link":"","permalink":"http://hofe.work/2020/04/04/%E4%B8%80%E6%96%87%E8%AE%B2%E6%87%82RPC/","excerpt":"","text":"一文讲懂RPC一、什么是RPC？简而言之：远程调用函数 本地调用函数: 1 int Multiply(int l, int r) &#123;2 int y = l * r;3 return y;4 &#125;5 6 int lvalue = 10;7 int rvalue = 20;8 int l_times_r = Multiply(lvalue, rvalue); 远程调用存在的问题 Call ID映射。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 &lt;–&gt; Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。 序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。 网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。","categories":[],"tags":[]},{"title":"hexo的基本配置--相册","slug":"hexo的基本配置-相册","date":"2020-04-03T13:22:20.000Z","updated":"2020-04-03T13:38:19.441Z","comments":true,"path":"2020/04/03/hexo的基本配置-相册/","link":"","permalink":"http://hofe.work/2020/04/03/hexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE-%E7%9B%B8%E5%86%8C/","excerpt":"","text":"效果展示生成目录配置相簿配置在自己博客主目录下 hexo new page album 会在source目录下生成source\\album\\index.md生成的index.md即是相册模块的配置文件, 在这个文件中添加以下代码 ---title: 相册date: 2020-04-03 17:45:19comments: false---&lt;div class=\"gallery-group-main\"&gt;&#123;% galleryGroup '相册1' '做过的一些项目' '/album/相册1' https://xxx[存放图片的途径] %&#125;&#123;% galleryGroup '相册2' '看见过的好设计' '/album/相册2' https://i.loli.net/2020/04/03/S42oQ9tvH6GEPqV.jpg %&#125;&#123;% galleryGroup '生活' '关于生活' '/album/life' https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %&#125;&lt;/div&gt; 相册配置完成上面的配置后会发现少了 /album/相册1 这样的目录，故需自己创建; 在album下再创建相册1文件夹.里面同样需要上面的配置文件index.md, 包含以下代码; 主要就是自己的图片链接, 推荐图床 https://sm.ms/ ---title: 生活date: 2020-04-03 20:44:55comments: false---&#123;% gallery %&#125;![](https://gratisography.com/wp-content/uploads/2019/10/gratisography-scary-pumpkin-hand-900x600.jpg)![](https://gratisography.com/wp-content/uploads/2019/10/gratisography-fresh-fish-dinner-900x600.jpg)&#123;% endgallery %&#125; 这样就搞定啦","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://hofe.work/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-12T16:00:00.000Z","updated":"2020-04-05T08:27:24.897Z","comments":true,"path":"2020/03/13/hello-world/","link":"","permalink":"http://hofe.work/2020/03/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://hofe.work/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://hofe.work/tags/hexo/"}]}],"categories":[{"name":"docker","slug":"docker","permalink":"http://hofe.work/categories/docker/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://hofe.work/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"hexo","slug":"hexo","permalink":"http://hofe.work/categories/hexo/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://hofe.work/tags/docker/"},{"name":"算法","slug":"算法","permalink":"http://hofe.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"kmp","slug":"kmp","permalink":"http://hofe.work/tags/kmp/"},{"name":"hexo","slug":"hexo","permalink":"http://hofe.work/tags/hexo/"}]}