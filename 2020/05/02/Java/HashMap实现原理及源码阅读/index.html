<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>HashMap实现原理及源码阅读 | Hofe's blog</title><meta name="description" content="HashMap实现原理及源码阅读"><meta name="keywords" content="HashMap"><meta name="author" content="hofe"><meta name="copyright" content="hofe"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="http://ta.qq.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="JoP76yOkd4"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="HashMap实现原理及源码阅读"><meta name="twitter:description" content="HashMap实现原理及源码阅读"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502153305.png"><meta property="og:type" content="article"><meta property="og:title" content="HashMap实现原理及源码阅读"><meta property="og:url" content="http://hofe.work/2020/05/02/Java/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><meta property="og:site_name" content="Hofe's blog"><meta property="og:description" content="HashMap实现原理及源码阅读"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502153305.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://hofe.work/2020/05/02/Java/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><link rel="prev" title="ConcurrentHashMap实现原理及源码阅读" href="http://hofe.work/2020/05/03/Java/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><link rel="next" title="一文详解排序算法" href="http://hofe.work/2020/05/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-4088686103083456',
  enable_page_level_ads: 'true'
});</script><script src="https://tajs.qq.com/stats?sId=66539762" charset="UTF-8"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://hofe.work","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">54</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">55</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">39</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-clock-o"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments-o"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fa fa-camera"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-info-circle"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#重点概念"><span class="toc-text">重点概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一、底层数据结构"><span class="toc-text">一、底层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-构造函数"><span class="toc-text">1.1 构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、存取机制"><span class="toc-text">二、存取机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-put-K-key-V-value"><span class="toc-text">2.1 put(K key, V value)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-hash-方法与hashcode-方法"><span class="toc-text">2.1.1 hash()方法与hashcode()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Fail-Fast-机制"><span class="toc-text">2.1.2 Fail-Fast 机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-get-key"><span class="toc-text">2.2 get(key)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-面试题"><span class="toc-text">2.3 面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-hashcode-与equals-区别"><span class="toc-text">2.3.1 hashcode()与equals()区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-为什么要重写equals-方法？"><span class="toc-text">2.3.2 为什么要重写equals()方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-为什么改写了equals-，也需要改写hashcode"><span class="toc-text">2.3.3 为什么改写了equals()，也需要改写hashcode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-为什么改写了hashcode-，也需要改写equals"><span class="toc-text">2.3.4 为什么改写了hashcode()，也需要改写equals()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、扩容机制"><span class="toc-text">三、扩容机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-resize"><span class="toc-text">3.1 resize()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、面试题"><span class="toc-text">四、面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-扩容为什么是2倍？"><span class="toc-text">4.1 扩容为什么是2倍？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-为什么String-Interger这样的wrapper类适合作为键？"><span class="toc-text">4.2 为什么String, Interger这样的wrapper类适合作为键？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-线程不安全的原因"><span class="toc-text">4.3 线程不安全的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-你了解重新调整HashMap大小存在什么问题吗？"><span class="toc-text">4.4 你了解重新调整HashMap大小存在什么问题吗？</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502153305.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hofe's blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-clock-o"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments-o"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fa fa-camera"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-info-circle"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">HashMap实现原理及源码阅读</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-02 10:47:38"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-02</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-30 14:45:28"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-30</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/Map/">Map</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">6.1k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 24 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/05/02/Java/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/05/02/Java/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><blockquote>
<p>可访问<a href="hofe.work">个人网站</a>进行阅读最新版本，精力有限无法多网站同步更新，更新只会在个人网站进行</p>
</blockquote>
<h2 id="重点概念"><a href="#重点概念" class="headerlink" title="重点概念"></a>重点概念</h2><ul>
<li>底层数据结构</li>
<li>hash冲突解决</li>
<li>1.7和1.8区别</li>
<li>扩容机制（为什么是2倍）</li>
<li>rehash过程</li>
<li>红黑树的左右旋</li>
</ul>
<h2 id="一、底层数据结构"><a href="#一、底层数据结构" class="headerlink" title="一、底层数据结构"></a>一、底层数据结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 初始容量16  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">//最大容量  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;<span class="comment">//填充比，占满0.75进行resize</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; 	<span class="comment">// 链表长度达到8时将链表转换为红黑树 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;   <span class="comment">// 树大小为6，就转回链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;  </span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;<span class="comment">//存储元素的数组  </span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;  </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;<span class="comment">//存放元素的个数  </span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;<span class="comment">//被修改的次数fast-fail机制  </span></span><br><span class="line">    <span class="keyword">int</span> threshold;<span class="comment">//临界值 当实际大小(容量*填充比)超过临界值时，会进行扩容   </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;<span class="comment">//填充比</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.位桶数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;k,v&gt;[] table;<span class="comment">//存储（位桶）的数组&lt;/k,v&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.数组元素Node&lt;K,V&gt;实现了Entry接口</span></span><br><span class="line"><span class="comment">//Node是单向链表，它实现了Map.Entry接口  </span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  </span><br><span class="line">    <span class="keyword">final</span> K key;  </span><br><span class="line">    V value;  </span><br><span class="line">    Node&lt;k,v&gt; next;  </span><br><span class="line">    <span class="comment">//构造函数Hash值 键 值 下一个节点  </span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;k,v&gt; next) &#123;  </span><br><span class="line">        <span class="keyword">this</span>.hash = hash;  </span><br><span class="line">        <span class="keyword">this</span>.key = key;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">        <span class="keyword">this</span>.next = next;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + = + value; &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;  </span><br><span class="line">        V oldValue = value;  </span><br><span class="line">        value = newValue;  </span><br><span class="line">        <span class="keyword">return</span> oldValue;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;  </span><br><span class="line">            Map.Entry&lt;!--?,?--&gt; e = (Map.Entry&lt;!--?,?--&gt;)o;  </span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;  </span><br><span class="line">                Objects.equals(value, e.getValue()))  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">k</span>,<span class="title">v</span>&gt; </span>&#123;  </span><br><span class="line">    TreeNode&lt;k,v&gt; parent;  <span class="comment">// 父节点  </span></span><br><span class="line">    TreeNode&lt;k,v&gt; left; <span class="comment">//左子树  </span></span><br><span class="line">    TreeNode&lt;k,v&gt; right;<span class="comment">//右子树  </span></span><br><span class="line">    TreeNode&lt;k,v&gt; prev;    <span class="comment">// needed to unlink next upon deletion  </span></span><br><span class="line">    <span class="keyword">boolean</span> red;    <span class="comment">//颜色属性  </span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;k,v&gt; next) &#123;  </span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//返回当前节点的根节点  </span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;k,v&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;k,v&gt; r = <span class="keyword">this</span>, p;;) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)  </span><br><span class="line">                <span class="keyword">return</span> r;  </span><br><span class="line">            r = p;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200320130148608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200320130253116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<p>总结：1.7的hashmap是由位桶数组+链表组成，1.8之后的hashmap由位桶数组+链表+红黑树组成。其中数组指bucket数组，数组中的元素是实现了map.Entry&lt;k,v&gt;接口的Node&lt;k,v&gt;，每个Node&lt;k,v&gt;包含key，value，next指针，hash值。当put元素时会调用hashcode计算hash值，相同key而value不同的元素会发生哈希碰撞，采用拉链拉解决，将该元素插入到链表中。当<code>TREEIFY_THRESHOLD</code>&gt;8时，会转化成红黑树。</p>
<h3 id="1-1-构造函数"><a href="#1-1-构造函数" class="headerlink" title="1.1 构造函数"></a>1.1 构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数1  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//指定的初始容量非负  </span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Illegal initial capacity:  +  </span><br><span class="line">                                           initialCapacity);  </span><br><span class="line">    <span class="comment">//如果指定的初始容量大于最大容量,置为最大容量  </span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)  </span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;  </span><br><span class="line">    <span class="comment">//填充比为正  </span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Illegal load factor:  +  </span><br><span class="line">                                           loadFactor);  </span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;  </span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//新的扩容临界值  </span></span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="comment">//构造函数2  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="comment">//构造函数3  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted  </span></span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="comment">//构造函数4用m的元素初始化散列映射  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;!--? extends K, ? extends V--&gt; m)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;  </span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="二、存取机制"><a href="#二、存取机制" class="headerlink" title="二、存取机制"></a>二、存取机制</h2><p>在明白它是怎么取之前需要先明白是怎么存的</p>
<h3 id="2-1-put-K-key-V-value"><a href="#2-1-put-K-key-V-value" class="headerlink" title="2.1 put(K key, V value)"></a>2.1 put(K key, V value)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value 元素已经存在，是否改变现值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode. 区别通过put添加还是创建时初始化数据的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,  </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] tab;   </span><br><span class="line">    Node&lt;K,V&gt; p;   </span><br><span class="line">    <span class="keyword">int</span> n, i;  </span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)	<span class="comment">// 空表，需要初始化</span></span><br><span class="line">            n = (tab = resize()).length; <span class="comment">// resize()不仅用来调整大小，还用来进行初始化配置 </span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">/*如果table的在（n-1）&amp;hash的值是空，就新建一个节点插入在该位置*/</span> </span><br><span class="line">    	<span class="comment">// （n-1）&amp;hash相当于hash%(n-1)</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)  </span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);  </span><br><span class="line">    	<span class="comment">/*表示有冲突,该位置已存值，开始处理冲突，采用拉链法或是红黑树*/</span>  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            Node&lt;K,V&gt; e;   </span><br><span class="line">        	K k;  </span><br><span class="line">    		<span class="comment">/*检查第一个Node，p是不是要找的值*/</span>  </span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">                e = p;  <span class="comment">//已存在就替换新值</span></span><br><span class="line">            <span class="comment">/*如果不是，判断第一个元素是链表元素还是红黑树头结点*/</span>  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  <span class="comment">//按红黑树方式插入</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);  </span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">// 遍历链表插入链尾</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;  </span><br><span class="line">        			<span class="comment">/*指针为空就挂在后面*/</span>  </span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);  </span><br><span class="line">             		<span class="comment">//如果冲突的节点数已经达到8个，看是否需要改变冲突节点的存储结构，  </span></span><br><span class="line">　　　　　　　　　　　　<span class="comment">//treeifyBin首先判断当前hashMap的长度，如果不足64，只进行  </span></span><br><span class="line">                        <span class="comment">//resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树  </span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                            treeifyBin(tab, hash);  </span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">        			<span class="comment">/*找到了对应元素，就可以停止*/</span>  </span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                    <span class="comment">// 继续向后</span></span><br><span class="line">                    p = e;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">    		<span class="comment">/*就是链表上有相同的key值，修改元素值*/</span>  </span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key，就是key的Value存在  </span></span><br><span class="line">                V oldValue = e.value;  </span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)  </span><br><span class="line">                    e.value = value;  </span><br><span class="line">                afterNodeAccess(e);  </span><br><span class="line">                <span class="keyword">return</span> oldValue;<span class="comment">//返回存在的Value值  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ++modCount;  <span class="comment">// 修改次数+1</span></span><br><span class="line">     	<span class="comment">/*如果当前大小大于门限，门限原本是初始容量*0.75*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)  </span><br><span class="line">            resize();<span class="comment">//扩容两倍  </span></span><br><span class="line">        afterNodeInsertion(evict);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面简单说下添加键值对put(key,value)的过程：</p>
<ol>
<li><p>判断位桶数组是否为空数组，是则通过resize初始化</p>
</li>
<li><p>通过hash(key)计算hash值判断该Node&lt;k,v&gt;应该插入的位置(不同的key可能有相同的hashcode)</p>
</li>
<li><p>如果该位置还没插入值，则直接插入；如果已存在值</p>
<ul>
<li>判断key是否相同，是：则用e记录该结点；</li>
<li>否：则判断table[i]是否为树结点，<ul>
<li>是：则以红黑树的方式插入，用e记录；</li>
<li>否：则遍历链表插入到链尾（如果长度&gt;8转成红黑树)；遇到已存该元素的情况下，用e记录，并退出</li>
</ul>
</li>
</ul>
</li>
<li><p>在上述步骤中，都有用e记录了数组中或链表或红黑树已存在该元素的信息。通过修改e来覆盖原值</p>
</li>
<li><p>判断加入结点后是否超过门限值，是否需要扩容</p>
</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://img2018.cnblogs.com/blog/1677914/201907/1677914-20190708102644222-1828130118.png"  alt=""></p>
<h4 id="2-1-1-hash-方法与hashcode-方法"><a href="#2-1-1-hash-方法与hashcode-方法" class="headerlink" title="2.1.1 hash()方法与hashcode()方法"></a>2.1.1 hash()方法与hashcode()方法</h4><p>我们通过hash方法计算索引，得到数组中保存的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以看到HashMap中的hash算法是<strong>通过key的hashcode值与其hashcode右移16位后得到的值进行异或运算</strong>得到的，那么为什么不直接使用key.hashCode()，而要进行异或操作？我们知道hash的目的是为了得到进行索引，而hash是有可能冲突的，也就是不同的key得到了同样的hash值，这样就很容易产业碰撞，如何减少这种情况的发生呢，就通过上述的hash(Object key)算法将hashcode 与 hashcode的低16位做异或运算，混合了高位和低位得出的最终hash值，冲突的概率就小多了</p>
<h4 id="2-1-2-Fail-Fast-机制"><a href="#2-1-2-Fail-Fast-机制" class="headerlink" title="2.1.2 Fail-Fast 机制"></a>2.1.2 Fail-Fast 机制</h4><p>我们知道 java.util.HashMap 不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过 modCount 域，modCount 顾名思义就是修改次数，对HashMap 内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的 expectedModCount。在迭代过程中，判断 modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了 Map：注意到 modCount 声明为 volatile，保证线程之间修改的可见性。</p>
<p>所以在这里和大家建议，当大家遍历那些非线程安全的数据结构时，尽量使用迭代器</p>
<h3 id="2-2-get-key"><a href="#2-2-get-key" class="headerlink" title="2.2 get(key)"></a>2.2 get(key)</h3><p>通过put过程，我们已经知道Node(k,v)是怎么保存到map中的，现在来看看怎么取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">    Node&lt;K,V&gt; e;  </span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 该key的hash值和key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] tab;<span class="comment">//Entry对象数组  </span></span><br><span class="line">    Node&lt;K,V&gt; first,e; <span class="comment">//在tab数组中经过散列的第一个位置  </span></span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    K k;  </span><br><span class="line">    <span class="comment">/*找到插入的第一个Node，方法是hash值和n-1相与，tab[(n - 1) &amp; hash]*/</span>  </span><br><span class="line">    <span class="comment">//也就是说在一条链上的hash值相同的  </span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="comment">/*检查第一个Node是不是要找的Node*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node  </span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))<span class="comment">//判断条件是hash值要相同，key值要相同  </span></span><br><span class="line">            <span class="keyword">return</span> first;  </span><br><span class="line">        <span class="comment">/*检查first后面的node*/</span>  </span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)  </span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);  </span><br><span class="line">            <span class="comment">/*遍历后面的链表，找到key值和hash值都相同的Node*/</span>  </span><br><span class="line">            <span class="keyword">do</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">                    <span class="keyword">return</span> e;  </span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过hash(key)找到bucket数组中该hash值的位置，判断该位置的元素也就是first的key是否与要找的这个key相同<ul>
<li>是：则返回该first元素</li>
<li>否：判断first是否是树节点<ul>
<li>是：则通过红黑树的方式进行查找</li>
<li>否：遍历链表查找到key相同的Node并返回</li>
</ul>
</li>
</ul>
</li>
<li>如果没找到，则返回null</li>
</ol>
<h3 id="2-3-面试题"><a href="#2-3-面试题" class="headerlink" title="2.3 面试题"></a>2.3 面试题</h3><h4 id="2-3-1-hashcode-与equals-区别"><a href="#2-3-1-hashcode-与equals-区别" class="headerlink" title="2.3.1 hashcode()与equals()区别"></a>2.3.1 hashcode()与equals()区别</h4><p>get()查找元素的过程：计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>
<p>Object的equals()是基于比较内存地址实现的，hashcode()是比较内存地址的hash值</p>
<p>在map中，hashcode(实际是hash方法，封装了hashcode和低16位异或运算)用来计算key应该放在数组中的哪个位置，equals是用在有多个hashcode相同的情况下查找需要的key。</p>
<h4 id="2-3-2-为什么要重写equals-方法？"><a href="#2-3-2-为什么要重写equals-方法？" class="headerlink" title="2.3.2 为什么要重写equals()方法？"></a>2.3.2 为什么要重写equals()方法？</h4><p>因为object中的equals()方法比较的是对象的引用地址是否相等，如何你需要判断对象里的内容是否相等，则需要重写equals()方法。</p>
<h4 id="2-3-3-为什么改写了equals-，也需要改写hashcode"><a href="#2-3-3-为什么改写了equals-，也需要改写hashcode" class="headerlink" title="2.3.3 为什么改写了equals()，也需要改写hashcode()"></a>2.3.3 为什么改写了equals()，也需要改写hashcode()</h4><p>如果你重载了equals，比如说是基于对象的内容实现的，而保留hashCode的实现（基于内存地址的hash值）不变，那么在添加进map中时需要比对hashcode，很可能某两个对象明明是“相等”，而hashCode却不一样。</p>
<h4 id="2-3-4-为什么改写了hashcode-，也需要改写equals"><a href="#2-3-4-为什么改写了hashcode-，也需要改写equals" class="headerlink" title="2.3.4 为什么改写了hashcode()，也需要改写equals()"></a>2.3.4 为什么改写了hashcode()，也需要改写equals()</h4><p>Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写。</p>
<p>在改写equals方法的时候，需要满足以下三点：<br>(1) 自反性：就是说a.equals(a)必须为true。<br>(2) 对称性：就是说a.equals(b)=true的话，b.equals(a)也必须为true。<br>(3) 传递性：就是说a.equals(b)=true，并且b.equals(c)=true的话，a.equals(c)也必须为true。<br>通过改写key对象的equals和hashcode方法，我们可以将任意的业务对象作为map的key(前提是你确实有这样的需要)。</p>
<h2 id="三、扩容机制"><a href="#三、扩容机制" class="headerlink" title="三、扩容机制"></a>三、扩容机制</h2><p>当hashmap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16\</em>0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大为原来2倍，然后重新调用hash方法找到新的bucket位置。</p>
<h3 id="3-1-resize"><a href="#3-1-resize" class="headerlink" title="3.1 resize()"></a>3.1 resize()</h3><p><strong>jdk1.7的源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建一个新的 Hash Table</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将 Old Hash Table 上的数据迁移到 New Hash Table 上</span></span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迁移数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//下面这段代码的意思是：</span></span><br><span class="line">    <span class="comment">//  从OldTable里摘一个元素出来，然后放到NewTable中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迁移过程：</p>
<p><strong>单线程</strong>下的迁移：在扩容之后，重新计算hash定位到新数组中，相同hash值的元素照样连接成链表，只是链表相对位置进行了反转。</p>
<p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/7557373-04a86c08537518e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/623/format/webp"  alt=""></p>
<p><strong>多线程</strong>下的迁移：</p>
<p>线程1在获取next结点之后被挂起，Thread 1 的 e 指向了 key(3)，而 next 指向了 key(7)。线程2顺利完成rehash过程，链表反转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; next = e.next; <span class="comment">//  假设线程一执行到这里就被调度挂起了</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">    e.next = newTable[i];</span><br><span class="line">    newTable[i] = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/7557373-11c54ec1d172a3b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/616/format/webp"  alt=""></p>
<p>线程1继续执行，仍会把线程二的新表当成原始的hash表，将原来e指向的key(3)节点当成是线程二中的key(3)，放在自己所建newTable[3]的头节点，线程1的next仍然指向key(7)，此时key(3)的next已经是null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e.next = newTable[i];	<span class="comment">// key(3)的 next 指向了线程1的新 Hash 表，因为新 Hash 表为空，所以e.next = null</span></span><br><span class="line">newTable[i] = e;	<span class="comment">// 线程1的新 Hash 表第一个元素指向了线程2新 Hash 表的 key(3)。e 处理完毕</span></span><br><span class="line">e = next;			<span class="comment">// 将 e 指向 next，所以新的 e 是 key(7)</span></span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/7557373-b0fa15a9e28d9040.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/591/format/webp"  alt=""></p>
<p>线程1的e指向了上一次循环的next，也就是key(7)，此时key(7)的next已经是key(3)。将key(7)插入到table[0]的头节点，并且将key(7)的next设置为key(3), e 和next继续往下移。此时仍然没有问题。</p>
<p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/7557373-b1cf3d84815cecf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/627/format/webp"  alt=""></p>
<p>继续下一次循环，e.next = newTable[i] 导致 key(3).next 指向了 key(7)，但此时的 key(7).next 已经指向了 key(3)， 环形链表就这样出现了。</p>
<p><img src="/" class="lazyload" data-src="https://upload-images.jianshu.io/upload_images/7557373-6917fd770bbb5a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/623/format/webp"  alt=""></p>
<p><strong>jdk1.8的源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//以前的容量大于0，也就是hashMap中已经有元素了，或者new对象的时候设置了初始容量</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果以前的容量大于限制的最大容量1&lt;&lt;30,则设置临界值为int的最大值2^31-1</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果以前容量的2倍小于限制的最大容量，同时大于或等于默认的容量16，则设置临界值为以前临界值的2</span></span><br><span class="line"><span class="comment">         * 倍，因为threshold = loadFactor*capacity，capacity扩大了2倍，loadFactor不变，</span></span><br><span class="line"><span class="comment">         * threshold自然也扩大2倍。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在HashMap构造器Hash(int initialCapacity, float loadFactor)中有一句代码，this.threshold  	</span></span><br><span class="line"><span class="comment">     * = tableSizeFor(initialCapacity)， 表示在调用构造器时，默认是将初始容量暂时赋值给了</span></span><br><span class="line"><span class="comment">     * threshold临界值，因此此处相当于将上一次的初始容量赋值给了新的容量。什么情况下会执行到这句？当调用 	 </span></span><br><span class="line"><span class="comment">     * 了HashMap(int initialCapacity)构造器，还没有添加元素时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用了默认构造器，初始容量没有设置，因此使用默认容量DEFAULT_INITIAL_CAPACITY（16），临界值</span></span><br><span class="line"><span class="comment">     * 就是16*0.75</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对临界值做判断，确保其不为0，因为在上面第二种情况(oldThr &gt; 0)，并没有计算newThr</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">/**构造新表，初始化表中数据*/</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//将刚创建的新表赋值给table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历将原来table中的数据放到扩容后的新表中来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//没有链表Node节点，直接放到新的table中下标为[e.hash &amp; (newCap - 1)]位置即可</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果是treeNode节点，则树上的节点放到newTab中</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//如果e后面还有链表节点，则遍历e所在的链表，</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 保证顺序</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">//记录下一个节点</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * newTab的容量是以前旧表容量的两倍,因为数组table下标并不是根据循环逐步递增</span></span><br><span class="line"><span class="comment">                         * 的，而是通过（table.length-1）&amp; hash计算得到，因此扩容后，存放的位置就</span></span><br><span class="line"><span class="comment">                         * 可能发生变化，那么到底发生怎样的变化呢，就是由下面的算法得到.</span></span><br><span class="line"><span class="comment">                         *</span></span><br><span class="line"><span class="comment">                         * 通过e.hash &amp; oldCap来判断节点位置通过再次hash算法后，是否会发生改变，如</span></span><br><span class="line"><span class="comment">                         * 果为0表示不会发生改变，如果为1表示会发生改变。到底怎么理解呢，举个例子：</span></span><br><span class="line"><span class="comment">                         * e.hash = 13 二进制：0000 1101</span></span><br><span class="line"><span class="comment">                         * oldCap = 32 二进制：0001 0000</span></span><br><span class="line"><span class="comment">                         *  &amp;运算：  0  二进制：0000 0000</span></span><br><span class="line"><span class="comment">                         * 结论：元素位置在扩容后不会发生改变</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * e.hash = 18 二进制：0001 0010</span></span><br><span class="line"><span class="comment">                         * oldCap = 32 二进制：0001 0000</span></span><br><span class="line"><span class="comment">                         * &amp;运算：  32 二进制：0001 0000</span></span><br><span class="line"><span class="comment">                         * 结论：元素位置在扩容后会发生改变，那么如何改变呢？</span></span><br><span class="line"><span class="comment">                         * newCap = 64 二进制：0010 0000</span></span><br><span class="line"><span class="comment">                         * 通过(newCap-1)&amp;hash</span></span><br><span class="line"><span class="comment">                         * 即0001 1111 &amp; 0001 0010 得0001 0010，32+2 = 34</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 若(e.hash &amp; oldCap) == 0，下标不变，将原表某个下标的元素放到扩容表同样</span></span><br><span class="line"><span class="comment">                         * 下标的位置上</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 若(e.hash &amp; oldCap) != 0，将原表某个下标的元素放到扩容表中</span></span><br><span class="line"><span class="comment">                         * [下标+增加的扩容量]的位置上</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><p>如果table == null, 则为HashMap的初始化, 生成空table返回即可;</p>
</li>
<li><p>如果table不为空, 需要重新计算table的长度, newLength = oldLength &lt;&lt; 1(注, 如果原oldLength已经到了上限, 则newLength = oldLength);</p>
</li>
<li><p>遍历oldTable，oldTable[i]为空，遍历下一个</p>
<ul>
<li>否：判断oldTable[i].next是否为空<ul>
<li>是：存放到newTable中newTab[<code>e.hash &amp; (newCap - 1</code>)]</li>
<li>否：判断是否红黑树<ul>
<li>是：走红黑树的重定位</li>
<li>否：JAVA7时还需要重新计算hash位, 但是JAVA8做了优化, 通过<code>(e.hash &amp; oldCap)</code>== 0来判断节点位置通过再次hash算法后，是否会发生改变<ul>
<li>是：移动到当前hash槽位 + oldCap的位置</li>
<li>否：移动到新表中原下标的位置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>注：newCap/oldCap为容量</strong></p>
<h2 id="四、面试题"><a href="#四、面试题" class="headerlink" title="四、面试题"></a>四、面试题</h2><h3 id="4-1-扩容为什么是2倍？"><a href="#4-1-扩容为什么是2倍？" class="headerlink" title="4.1 扩容为什么是2倍？"></a>4.1 扩容为什么是2倍？</h3><p>主要与HashMap计算添加元素的位置时，使用的位运算有关，这是特别高效的运算；HashMap的初始容量是2的n次幂，扩容也是2倍的形式进行扩容，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低。</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502144909.png"  alt=""></p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502145124.png"  alt=""></p>
<h3 id="4-2-为什么String-Interger这样的wrapper类适合作为键？"><a href="#4-2-为什么String-Interger这样的wrapper类适合作为键？" class="headerlink" title="4.2 为什么String, Interger这样的wrapper类适合作为键？"></a>4.2 为什么String, Interger这样的wrapper类适合作为键？</h3><p>如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能，也就适合做Hashmap的键。因为获取对象的时候要用到equals()和hashCode()方法，键对象正确的重写这两个方法是非常重要的。<br>因此，String，Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。<strong>不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象</strong></p>
<h3 id="4-3-线程不安全的原因"><a href="#4-3-线程不安全的原因" class="headerlink" title="4.3 线程不安全的原因"></a>4.3 线程不安全的原因</h3><p>HashMap在并发场景下可能存在以下问题：</p>
<p><strong>死循环</strong>：在jdk1.7中，resize过程中，从旧数组重新迁移至新数组的过程中，仍可能会发生hash冲突，形成链表，链表的相对位置发生了反转，那么在并发环境下，容易出现多线程同时resize的情况，那么就有可能在迁移过程中发生闭环，一旦发生闭环，进行get()操作的时候就会陷入死循环。在jdk1.8中，用 head 和 tail 来保证链表的顺序和之前一样，因此不会出现发生闭环的情况。</p>
<p><strong>数据丢失</strong>：</p>
<ol>
<li><p>如果多个线程同时使用 put 方法添加元素，而且假设正好存在两个 put 的 key 发生了碰撞（根据 hash 值计算的 bucket 一样），那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程 put 的数据被覆盖</p>
</li>
<li><p>如果多个线程同时检测到元素个数超过数组大小 * loadFactor，这样就会发生多个线程同时对 Node 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失</p>
</li>
</ol>
<h3 id="4-4-你了解重新调整HashMap大小存在什么问题吗？"><a href="#4-4-你了解重新调整HashMap大小存在什么问题吗？" class="headerlink" title="4.4 你了解重新调整HashMap大小存在什么问题吗？"></a>4.4 你了解重新调整HashMap大小存在什么问题吗？</h3><p>Jdk1.7 当多线程的情况下，可能产生条件竞争(race condition)。</p>
<p>当重新调整HashMap大小的时候，如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调 整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部， 这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。</p>
<p><strong>注：尾部遍历（避免尾部遍历是为了避免在新列表插入数据时，遍历队尾的位置。因为，直接插入的效率更高。）</strong></p>
<p><strong>死循环的发生</strong></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">hofe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hofe.work/2020/05/02/Java/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">http://hofe.work/2020/05/02/Java/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hofe.work" target="_blank">Hofe's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/HashMap/">HashMap</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502153305.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/03/Java/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502153305.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ConcurrentHashMap实现原理及源码阅读</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">一文详解排序算法</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'b5cpWE77l9G2Um3MSdyvAmh6-gzGzoHsz',
  appKey: 'LCxOgpdF1CrQ1Xb4dnNrg6OH',
  placeholder: '留下你的足迹吧',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'en',
  recordIP: true,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By hofe</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="http://hofe.work/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = false;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script></body></html>