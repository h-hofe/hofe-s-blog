<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ConcurrentHashMap实现原理之源码阅读 | Hofe's blog</title><meta name="description" content="ConcurrentHashMap实现原理之源码阅读"><meta name="keywords" content="ConcurrentHashMap"><meta name="author" content="hofe"><meta name="copyright" content="hofe"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="http://ta.qq.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="JoP76yOkd4"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="ConcurrentHashMap实现原理之源码阅读"><meta name="twitter:description" content="ConcurrentHashMap实现原理之源码阅读"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502153305.png"><meta property="og:type" content="article"><meta property="og:title" content="ConcurrentHashMap实现原理之源码阅读"><meta property="og:url" content="http://hofe.work/2020/05/02/Java/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><meta property="og:site_name" content="Hofe's blog"><meta property="og:description" content="ConcurrentHashMap实现原理之源码阅读"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502153305.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://hofe.work/2020/05/02/Java/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><link rel="next" title="HashMap实现原理之源码阅读" href="http://hofe.work/2020/05/02/Java/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-4088686103083456',
  enable_page_level_ads: 'true'
});</script><script src="https://tajs.qq.com/stats?sId=66539762" charset="UTF-8"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://hofe.work","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">19</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-clock-o"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments-o"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fa fa-camera"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-info-circle"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题"><span class="toc-text">面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一、了解Hashtable"><span class="toc-text">一、了解Hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Hashtable与ConcurrentHashMap区别："><span class="toc-text">1.1 Hashtable与ConcurrentHashMap区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、底层数据结构"><span class="toc-text">二、底层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-构造方法"><span class="toc-text">2.1 构造方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、存取机制"><span class="toc-text">三、存取机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-put方法"><span class="toc-text">3.1 put方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-get方法"><span class="toc-text">3.2 get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-remove方法"><span class="toc-text">3.3 remove方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-initTable初始化方法"><span class="toc-text">3.4 initTable初始化方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、扩容机制"><span class="toc-text">四、扩容机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-transfer扩容方法"><span class="toc-text">3.5 transfer扩容方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、HashMap、Hashtable、ConcurrentHashMap三者对比"><span class="toc-text">四、HashMap、Hashtable、ConcurrentHashMap三者对比</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502153305.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hofe's blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-clock-o"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments-o"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fa fa-camera"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-info-circle"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">ConcurrentHashMap实现原理之源码阅读</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-02 10:47:53"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-02</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-02 20:49:18"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-02</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7.8k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 30 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/05/02/Java/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/05/02/Java/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><blockquote>
<p>可访问<a href="https://juejin.im/post/5c8276216fb9a049d51a4cd6" target="_blank" rel="noopener">个人网站</a>进行阅读最新版本，精力有限无法多网站同步更新，更新只会在个人网站进行</p>
<p>参考自</p>
<ul>
<li><a href="https://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/" target="_blank" rel="noopener">https://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/</a></li>
<li><a href="https://juejin.im/post/5c8276216fb9a049d51a4cd6" target="_blank" rel="noopener">https://juejin.im/post/5c8276216fb9a049d51a4cd6</a></li>
</ul>
</blockquote>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>并发安全机制<br>分段锁机制<br>synchronized + CAS<br>内部数据结构</p>
<p>问实现原理是我最烦的一点，不知道从哪讲起，所以就按这篇文章的组织架构来吧</p>
<p>底层数据结构–&gt;存取机制-&gt;扩容机制-&gt;线程安全</p>
<h2 id="一、了解Hashtable"><a href="#一、了解Hashtable" class="headerlink" title="一、了解Hashtable"></a>一、了解Hashtable</h2><blockquote>
<p>在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
</blockquote>
<p>在讲ConcurrentHashMap之前，先讲下Hashtable，它使用 synchronized 关键字实现线程安全，比如 get 方法和 put 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>注意到，synchronized 关键字加在非静态方法上，说明同步锁对象即是 Hashtable 对象本身，只有一个锁。</p>
<h3 id="1-1-Hashtable与ConcurrentHashMap区别："><a href="#1-1-Hashtable与ConcurrentHashMap区别：" class="headerlink" title="1.1 Hashtable与ConcurrentHashMap区别："></a>1.1 Hashtable与ConcurrentHashMap区别：</h3><p><strong>线程安全的实现</strong>：<code>Hashtable</code>采用<strong>对象锁</strong>(synchronized修饰对象方法)来保证线程安全，也就是一个<code>Hashtable</code>对象只有一把锁，如果线程1拿了对象A的锁进行有<code>synchronized</code>修饰的<code>put</code>方法，其他线程是无法操作对象A中有<code>synchronized</code>修饰的方法的(如<code>get</code>方法、<code>remove</code>方法等)，竞争激烈所以效率低下。而<code>ConcurrentHashMap</code>采用<code>CAS</code> + <code>synchronized</code>来保证并发安全性，且<code>synchronized</code>关键字不是用在方法上而是用在了具体的对象上，实现了更小粒度的锁，等会源码分析的时候在细说这个SUN大师们的鬼斧神工</p>
<p>数据结构的实现：<code>Hashtable</code>采用的是<strong>数组 + 链表</strong>，当链表过长会影响查询效率，而<code>ConcurrentHashMap</code>采用<strong>数组 + 链表 + 红黑树</strong>，当链表长度超过某一个值，则将链表转成红黑树，提高查询效率。</p>
<h2 id="二、底层数据结构"><a href="#二、底层数据结构" class="headerlink" title="二、底层数据结构"></a>二、底层数据结构</h2><p>ConcurrentHashMap 使用了锁分段技术</p>
<blockquote>
<p>假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个Segment都是一个ReentrantLock锁，同时它内部保存着一个HashEntry数组</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets next field with volatile write semantics.  (See above</span></span><br><span class="line"><span class="comment">     * about use of putOrderedObject.)</span></span><br><span class="line"><span class="comment">     * 设置next，注意unsafe的使用，ConcurrentHashMap中很多这种操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(HashEntry&lt;K,V&gt; n)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class k = HashEntry<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            <span class="comment">//计算 nextOffset ，以使用设置next</span></span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>jdk1.7</strong></p>
<p>在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，主要实现原理是实现了<strong>锁分离</strong>的思路解决了多线程的安全问题，如下图所示：</p>
<p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MDMxMzcxLTM3NTMzMDU4NWEzZTE4NjkucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMDAwL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png"  alt=""></p>
<p><strong>jdk1.8</strong></p>
<p>JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本。</p>
<p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MDMxMzcxLTViYTg0NTRkMWJjNmYzZTcucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMDAwL2Zvcm1hdC93ZWJw?x-oss-process=image/format,png"  alt=""></p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment继承可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。</p>
<p>一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 每个Segment元素 里包含一个HashEntry数组，每个HashEntry元素是一个链表结构的元素， 每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<h3 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造函数，什么也不做，table的初始化放在了第一次插入数据时，默认容量大小是16和HashMap的一样，默认sizeCtl为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入容量大小的构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果传入的容量大小小于0 则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果传入的容量大小大于允许的最大容量值 则cap取允许的容量最大值 否则cap =</span></span><br><span class="line">    <span class="comment">//((传入的容量大小 + 传入的容量大小无符号右移1位 + 1)的结果向上取最近的2幂次方)，</span></span><br><span class="line">    <span class="comment">//即如果传入的容量大小是12 则 cap = 32(12 + (12 &gt;&gt;&gt; 1) + 1=19</span></span><br><span class="line">    <span class="comment">//向上取2的幂次方即32)，这里为啥一定要是2的幂次方，原因和HashMap的threshold一样，都是为</span></span><br><span class="line">    <span class="comment">//了让位运算和取模运算的结果一样。</span></span><br><span class="line">    <span class="comment">//MAXIMUM_CAPACITY即允许的最大容量值 为2^30。</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               <span class="comment">//tableSizeFor这个函数即实现了将一个整数取2的幂次方。</span></span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//将上面计算出的cap 赋值给sizeCtl，注意此时sizeCtl为正数，代表进行扩容的容量大小。</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含指定Map的构造函数。</span></span><br><span class="line"><span class="comment">//置sizeCtl为默认容量大小 即16。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入容量大小和负载因子的构造函数。</span></span><br><span class="line"><span class="comment">//默认并发数大小是1。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入容量大小、负载因子和并发数大小的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果传入的容量大小 小于 传入的并发数大小，</span></span><br><span class="line">    <span class="comment">//则容量大小取并发数大小，这样做的原因是确保每一个Node只会分配给一个线程，而一个线程则</span></span><br><span class="line">    <span class="comment">//可以分配到多个Node，比如当容量大小为64，并发数大</span></span><br><span class="line">    <span class="comment">//小为16时，则每个线程分配到4个Node。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">//size = 1.0 + (long)initialCapacity / loadFactor 这里计算方法和上面的构造函数不一样。</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">//如果size大于允许的最大容量值则 sizeCtl = 允许的最大容量值 否则 sizeCtl =</span></span><br><span class="line">    <span class="comment">//size取2的幂次方。</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConcurrentHashMap</code>的构造函数有5个，从数量上看就和<code>HashMap</code>、<code>Hashtable</code>(4个)的不同，多出的那个构造函数是<code>public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)</code>，即除了传入容量大小、负载因子之外还多传入了一个整型的<code>concurrencyLevel</code>，这个整型是我们预先估计的并发量，比如我们估计并发是<code>30</code>，那么就可以传入<code>30</code>。<br> 其他的4个构造函数的参数和<code>HashMap</code>的一样，而具体的初始化过程却又不相同，<code>HashMap</code>和<code>Hashtable</code>传入的容量大小和负载因子都是为了计算出<strong>初始阈值</strong>(threshold)，而<code>ConcurrentHashMap</code>传入的容量大小和负载因子是为了计算出<strong>sizeCtl</strong>用于初始化<code>table</code>，这个sizeCtl即table数组的大小，不同的构造函数计算sizeCtl方法都不一样。</p>
<h2 id="三、存取机制"><a href="#三、存取机制" class="headerlink" title="三、存取机制"></a>三、存取机制</h2><h3 id="3-1-put方法"><a href="#3-1-put方法" class="headerlink" title="3.1 put方法"></a>3.1 put方法</h3><p>put()能将对应的key与value保存到map中。在ConcurrentHashMap中，key与value都不能为空，否则会抛出NullPointerException异常。如果put()时，key已经存在，则会返回put()前该key对应的value。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不允许键值为null，这点与线程安全的Hashtable保持一致，和HashMap不同。</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//取键key的hashCode()和HashMap、Hashtable都一样，然后再执行spread()方法计算得到哈希地</span></span><br><span class="line">    <span class="comment">//址，这个spread()方法和HashMap的hash()方法一样，都是将hashCode()做无符号右移16位，只不</span></span><br><span class="line">    <span class="comment">//过spread()加多了 &amp;0x7fffffff，让结果为正数。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果table数组为空或者长度为0(未初始化)，则调用initTable()初始化table，初始化函数</span></span><br><span class="line">        <span class="comment">//下面介绍。</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//调用实现了CAS原子性操作的tabAt方法</span></span><br><span class="line">        <span class="comment">//tabAt方法的第一个参数是Node数组的引用，第二个参数在Node数组的下标，实现的是在Nod</span></span><br><span class="line">        <span class="comment">//e数组中查找指定下标的Node，如果找到则返回该Node节点(链表头节点)，否则返回null，</span></span><br><span class="line">        <span class="comment">//这里的i = (n - 1)&amp;hash即是计算待插入的节点在table的下标，即table容量-1的结果和哈</span></span><br><span class="line">        <span class="comment">//希地址做与运算，和HashMap的算法一样。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果该下标上并没有节点(即链表为空)，则直接调用实现了CAS原子性操作的</span></span><br><span class="line">            <span class="comment">//casTable()方法，</span></span><br><span class="line">            <span class="comment">//casTable()方法的第一个参数是Node数组的引用，第二个参数是待操作的下标，第三</span></span><br><span class="line">            <span class="comment">//个参数是期望值，第四个参数是待操作的Node节点，实现的是将Node数组下标为参数二</span></span><br><span class="line">            <span class="comment">//的节点替换成参数四的节点，如果期望值和实际值不符返回false，否则参数四的节点成</span></span><br><span class="line">            <span class="comment">//功替换上去，返回ture，即插入成功。注意这里：如果插入成功了则跳出for循环，插入</span></span><br><span class="line">            <span class="comment">//失败的话(其他线程抢先插入了)，那么会执行到下面的代码。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该下标上的节点的哈希地址为-1(即链表的头节点为ForwardingNode节点)，则表示</span></span><br><span class="line">        <span class="comment">//table需要扩容，值得注意的是ConcurrentHashMap初始化和扩容不是用同一个方法，而</span></span><br><span class="line">        <span class="comment">//HashMap和Hashtable都是用同一个方法，当前线程会去协助扩容，扩容过程后面介绍。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//如果该下标上的节点既不是空也不是需要扩容，则表示这个链表可以插入值，将进入到链表</span></span><br><span class="line">        <span class="comment">//中，将新节点插入或者覆盖旧值。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//通过关键字synchroized对该下标上的节点加锁(相当于锁住锁住</span></span><br><span class="line">            <span class="comment">//该下标上的链表)，其他下标上的节点并没有加锁，所以其他线程</span></span><br><span class="line">            <span class="comment">//可以安全的获得其他下标上的链表进行操作，也正是因为这个所</span></span><br><span class="line">            <span class="comment">//以提高了ConcurrentHashMap的效率，提高了并发度。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//如果该下标上的节点的哈希地址大于等于0，则表示这是</span></span><br><span class="line">                    <span class="comment">//个链表。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//如果哈希地址、键key相同 或者 键key不为空</span></span><br><span class="line">                            <span class="comment">//且键key相同，则表示存在键key和待插入的键</span></span><br><span class="line">                            <span class="comment">//key相同，则执行更新值value的操作。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//如果找到了链表的最后一个节点都没有找到相</span></span><br><span class="line">                            <span class="comment">//同键Key的，则是插入操作，将插入的键值新建</span></span><br><span class="line">                            <span class="comment">//个节点并且添加到链表尾部，这个和HashMap一</span></span><br><span class="line">                            <span class="comment">//样都是插入到尾部。</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果该下标上的节点的哈希地址小于0 且为树节点</span></span><br><span class="line">                    <span class="comment">//则将带插入键值新增到红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//如果插入的结果不为null，则表示为替换</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash,</span><br><span class="line">                        key,value)) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断链表的长度是否大于等于链表的阈值(8)，大于则将链表转成</span></span><br><span class="line">            <span class="comment">//红黑树，提高效率。这点和HashMap一样。</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结流程：</p>
<ol>
<li>判断键值是否为<code>null</code>，为<code>null</code>抛出异常。</li>
<li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址，这个HashMap相似。</li>
<li>如果当前table为空，则初始化table，需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong>尝试</strong>初始化table，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程。</li>
<li>使用 <strong>容量大小-1 &amp; 哈希地址</strong> 计算出待插入键值的下标，如果该下标上的bucket为<code>null</code>，则直接调用实现<code>CAS</code>原子性操作的<code>casTabAt()</code>方法将节点插入到table中，如果插入成功则完成put操作，结束返回。插入失败(被别的线程抢先插入了)则继续往下执行。</li>
<li>如果该下标上的节点(头节点)的哈希地址为-1，代表需要扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li>
<li>如果该下标上的bucket不为空，且又不需要扩容，则进入到bucket中，同时<strong>锁住这个bucket</strong>，注意只是锁住该下标上的bucket而已，其他的bucket并未加锁，其他线程仍然可以操作其他未上锁的bucket，这个就是ConcurrentHashMap为什么高效的原因之一。</li>
<li>进入到bucket里面，首先判断这个bucket存储的是红黑树(哈希地址小于0，原因后面分析)还是链表。</li>
<li>如果是<strong>链表</strong>，则遍历链表看看是否有哈希地址和键key相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点<strong>插入到链表尾部</strong>。如果是<strong>红黑树</strong>，则将节点插入。到这里<strong>结束加锁</strong>。</li>
<li>最后判断该bucket上的链表长度是否大于<strong>链表转红黑树的阈值(8)</strong>，大于则调用<code>treeifyBin()</code>方法将链表转成红黑树，以免链表过长影响效率。</li>
<li>调用<code>addCount()</code>方法，作用是将ConcurrentHashMap的键值对数量+1，还有另一个作用是检查ConcurrentHashMap是否需要扩容。</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502185635.png"  alt=""></p>
<p><strong>为什么ConcurrentHashMap中，key与value都不能为空</strong></p>
<p>ConcurrentHashMap的使用场景为多线程，如果有A、B两个线程，线程A调用concurrentHashMap.get(key)方法,返回为null，我们还是不知道这个null是没有映射的null还是存的值就是null。虽然可以用concurrentHashMap.containsKey(key)来判断，但是多线程下，如果A调用concurrentHashMap.get(key)方法之后，containsKey方法之前，有一个线程B执行了concurrentHashMap.put(key,null)的操作。那么我们调用containsKey方法返回的就是true了。这就与我们的假设的真实情况不符合了。也就是上面说的二义性。</p>
<p><strong>spread()具体干了什么？有什么意义？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算hash值</span></span><br><span class="line"><span class="comment">// 让高16位 亦或 低16位，再把高的16位置为0</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;        <span class="comment">// &amp; HASH_BITS用于把hash值转化为正数</span></span><br><span class="line">        <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里我也实在是迷惑了，和hashmap的hash()方法实现好像差不多，知识多了个HASH_BITS=0x7fffffff</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-get方法"><a href="#3-2-get方法" class="headerlink" title="3.2 get方法"></a>3.2 get方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//运用键key的hashCode()计算出哈希地址</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//如果table不为空 且 table长度大于0 且 计算出的下标上bucket不为空，</span></span><br><span class="line">    <span class="comment">//则代表这个bucket存在，进入到bucket中查找，</span></span><br><span class="line">    <span class="comment">//其中(n - 1) &amp; h为计算出键key相对应的数组下标的算法。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果哈希地址、键key相同则表示查找到，返回value，这里查找到的是头节点。</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果bucket头节点的哈希地址小于0，则代表bucket为红黑树，在红黑树中查找。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果bucket头节点的哈希地址不小于0，则代表bucket为链表，遍历链表，在链表中查找。</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结流程：</p>
<ol>
<li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址。</li>
<li>计算出键key所在的下标，算法是(n - 1) &amp; h，如果table不为空，且下标上的bucket不为空，则到bucket中查找。</li>
<li>如果bucket的头节点的哈希地址小于0，则代表这个bucket存储的是红黑树，否则是链表。</li>
<li>到红黑树或者链表中查找，找到则返回该键key的值，找不到则返回null。</li>
</ol>
<h3 id="3-3-remove方法"><a href="#3-3-remove方法" class="headerlink" title="3.3 remove方法"></a>3.3 remove方法</h3><p>总结流程</p>
<ol>
<li>调用<code>spread()</code>方法计算出键key的哈希地址。</li>
<li>计算出键key所在的数组下标，如果table为空或者bucket为空，则返回<code>null</code>。</li>
<li>判断当前table是否正在扩容，如果在扩容则调用helpTransfer方法协助扩容。</li>
<li>如果table和bucket都不为空，table也不处于在扩容状态，则<strong>锁住当前bucket</strong>，对bucket进行操作。</li>
<li>根据bucket的头结点判断bucket是链表还是红黑树。</li>
<li>在链表或者红黑树中移除哈希地址、键key相同的节点。</li>
<li>调用<code>addCount</code>方法，将当前table存储的键值对数量-1。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算需要移除的键key的哈希地址。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//遍历table。</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//table为空，或者键key所在的bucket为空，则跳出循环返回。</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//如果当前table正在扩容，则调用helpTransfer方法，去协助扩容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//将键key所在的bucket加锁。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//bucket头节点的哈希地址大于等于0，为链表。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//遍历链表。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//找到哈希地址、键key相同的节点，进行移除。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果bucket的头节点小于0，即为红黑树。</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        <span class="comment">//找到节点，并且移除。</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用addCount方法，将当前ConcurrentHashMap存储的键值对数量-1。</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-initTable初始化方法"><a href="#3-4-initTable初始化方法" class="headerlink" title="3.4 initTable初始化方法"></a>3.4 initTable初始化方法</h3><p><code>table</code>的初始化主要由initTable()方法实现的，initTable()方法初始化一个合适大小的数组，然后设置sizeCtl。 我们知道<code>ConcurrentHashMap</code>是线程安全的，即支持多线程的，那么一开始很多个线程同时执行<code>put()</code>方法，而<code>table</code>又没初始化，那么就会很多个线程会去执行initTable()方法尝试初始化table，而<code>put</code>方法和<code>initTable</code>方法都是没有加锁的(synchronize)，那SUN的大师们是怎么保证线程安全的呢？ 通过源码可以看得出，table的初始化只能由一个线程完成，但是每个线程都可以争抢去初始化table。</p>
<ol>
<li>判断table是否为<code>null</code>，即需不需要首次初始化，如果某个线程进到这个方法后，其他线程已经将table初始化好了，那么该线程结束该方法返回。</li>
<li>如果table为<code>null</code>，进入到while循环，如果<code>sizeCtl</code>小于0(其他线程正在对table初始化)，那么该线程调用<code>Thread.yield()</code>挂起该线程，让出CPU时间，该线程也从运行态转成就绪态，等该线程从就绪态转成运行态的时候，别的线程已经table初始化好了，那么该线程结束while循环，结束初始化方法返回。如果从就绪态转成运行态后，table仍然为<code>null</code>，则继续while循环。</li>
<li>如果table为<code>null</code>且<code>sizeCtl</code>不小于0，则调用实现<code>CAS</code>原子性操作的<code>compareAndSwap()</code>方法将sizeCtl设置成-1，告诉别的线程我正在初始化table，这样别的线程无法对table进行初始化。如果设置成功，则再次判断table是否为空，不为空则初始化table，容量大小为默认的容量大小(16)，或者为sizeCtl。其中sizeCtl的初始化是在构造函数中进行的，sizeCtl = ((传入的容量大小 + 传入的容量大小无符号右移1位 + 1)的结果向上取最近的2幂次方)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    &#x2F;&#x2F;如果table为null或者长度为0， &#x2F;&#x2F;则一直循环试图初始化table(如果某一时刻别的线程将table初始化好了，那table不为null，该&#x2F;&#x2F;线程就结束while循环)。</span><br><span class="line">    while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果sizeCtl小于0，</span><br><span class="line">        &#x2F;&#x2F;即有其他线程正在初始化或者扩容，执行Thread.yield()将当前线程挂起，让出CPU时间，</span><br><span class="line">        &#x2F;&#x2F;该线程从运行态转成就绪态。</span><br><span class="line">        &#x2F;&#x2F;如果该线程从就绪态转成运行态了，此时table可能已被别的线程初始化完成，table不为</span><br><span class="line">        &#x2F;&#x2F;null，该线程结束while循环。</span><br><span class="line">        if ((sc &#x3D; sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">        &#x2F;&#x2F;如果此时sizeCtl不小于0，即没有别的线程在做table初始化和扩容操作，</span><br><span class="line">        &#x2F;&#x2F;那么该线程就会调用Unsafe的CAS操作compareAndSwapInt尝试将sizeCtl的值修改成</span><br><span class="line">        &#x2F;&#x2F;-1(sizeCtl&#x3D;-1表示table正在初始化，别的线程如果也进入了initTable方法则会执行</span><br><span class="line">        &#x2F;&#x2F;Thread.yield()将它的线程挂起 让出CPU时间)，</span><br><span class="line">        &#x2F;&#x2F;如果compareAndSwapInt将sizeCtl&#x3D;-1设置成功 则进入if里面，否则继续while循环。</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;再次确认当前table为null即还未初始化，这个判断不能少。</span><br><span class="line">                if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果sc(sizeCtl)大于0，则n&#x3D;sc，否则n&#x3D;默认的容量大</span><br><span class="line">                    小16，</span><br><span class="line">                    &#x2F;&#x2F;这里的sc&#x3D;sizeCtl&#x3D;0，即如果在构造函数没有指定容量</span><br><span class="line">                    大小，</span><br><span class="line">                    &#x2F;&#x2F;否则使用了有参数的构造函数，sc&#x3D;sizeCtl&#x3D;指定的容量大小。</span><br><span class="line">                    int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    &#x2F;&#x2F;创建指定容量的Node数组(table)。</span><br><span class="line">                    Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    table &#x3D; tab &#x3D; nt;</span><br><span class="line">                    &#x2F;&#x2F;计算阈值，n - (n &gt;&gt;&gt; 2) &#x3D; 0.75n当ConcurrentHashMap储存的键值对数量</span><br><span class="line">                    &#x2F;&#x2F;大于这个阈值，就会发生扩容。</span><br><span class="line">                    &#x2F;&#x2F;这里的0.75相当于HashMap的默认负载因子，可以发现HashMap、Hashtable如果</span><br><span class="line">                    &#x2F;&#x2F;使用传入了负载因子的构造函数初始化的话，那么每次扩容，新阈值都是&#x3D;新容</span><br><span class="line">                    &#x2F;&#x2F;量 * 负载因子，而ConcurrentHashMap不管使用的哪一种构造函数初始化，</span><br><span class="line">                    &#x2F;&#x2F;新阈值都是&#x3D;新容量 * 0.75。</span><br><span class="line">                    sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl &#x3D; sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、扩容机制"><a href="#四、扩容机制" class="headerlink" title="四、扩容机制"></a>四、扩容机制</h2><h3 id="3-5-transfer扩容方法"><a href="#3-5-transfer扩容方法" class="headerlink" title="3.5 transfer扩容方法"></a>3.5 transfer扩容方法</h3><p><code>transfer()</code>方法为<code>ConcurrentHashMap</code>扩容操作的核心方法。由于<code>ConcurrentHashMap</code>支持多线程扩容，而且也没有进行加锁，所以实现会变得有点儿复杂。整个扩容操作分为两步：</p>
<ol>
<li>构建一个nextTable，其大小为原来大小的<strong>两倍</strong>，这个步骤是在单线程环境下完成的</li>
<li>将原来table里面的内容复制到nextTable中，这个步骤是允许<strong>多线程</strong>操作的，所以性能得到提升，减少了扩容的时间消耗</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//协助扩容方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//如果当前table不为null 且 f为ForwardingNode节点 且 //新的table即nextTable存在的情况下才能协助扩容，该方法的作用是让线程参与扩容的复制。</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//更新sizeCtl的值，+1，代表新增一个线程参与扩容</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//扩容的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//根据服务器CPU数量来决定每个线程负责的bucket数量，避免因为扩容的线程过多反而影响性能。</span></span><br><span class="line">    <span class="comment">//如果CPU数量为1，则stride=1，否则将需要迁移的bucket数量(table大小)除以CPU数量，平分给</span></span><br><span class="line">    <span class="comment">//各个线程，但是如果每个线程负责的bucket数量小于限制的最小是(16)的话，则强制给每个线程</span></span><br><span class="line">    <span class="comment">//分配16个bucket数。</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">//如果nextTable还未初始化，则初始化nextTable，这个初始化和iniTable初始化一样，只能由</span></span><br><span class="line">    <span class="comment">//一个线程完成。</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">//分配任务和控制当前线程的任务进度，这部分是transfer()的核心逻辑，描述了如何与其他线</span></span><br><span class="line">    <span class="comment">//程协同工作。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">//迁移过程（对当前指向的bucket），这部分的逻辑与HashMap类似，拿旧数组的容量当做一</span></span><br><span class="line">        <span class="comment">//个掩码，然后与节点的hash进行与操作，可以得出该节点的新增有效位，如果新增有效位为</span></span><br><span class="line">        <span class="comment">//0就放入一个链表A，如果为1就放入另一个链表B，链表A在新数组中的位置不变（跟在旧数</span></span><br><span class="line">        <span class="comment">//组的索引一致），链表B在新数组中的位置为原索引加上旧数组容量。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、HashMap、Hashtable、ConcurrentHashMap三者对比"><a href="#四、HashMap、Hashtable、ConcurrentHashMap三者对比" class="headerlink" title="四、HashMap、Hashtable、ConcurrentHashMap三者对比"></a>四、HashMap、Hashtable、ConcurrentHashMap三者对比</h2><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"><strong>HashMap</strong></th>
<th align="left"><strong>Hashtable</strong></th>
<th align="left"><strong>ConcurrentHashMap</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">是否线程安全</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">线程安全采用的方式</td>
<td align="left"></td>
<td align="left">采用<code>synchronized</code>类锁，效率低</td>
<td align="left">采用<code>CAS</code> + <code>synchronized</code>，锁住的只有当前操作的<strong>bucket</strong>，不影响其他线程对其他bucket的操作，效率高</td>
</tr>
<tr>
<td align="left">数据结构</td>
<td align="left">数组+链表+红黑树(链表长度超过8则转红黑树)</td>
<td align="left">数组+链表</td>
<td align="left">数组+链表+红黑树(链表长度超过8则转红黑树)</td>
</tr>
<tr>
<td align="left">是否允许<code>null</code>键值</td>
<td align="left">是</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">哈希地址算法</td>
<td align="left">(key的hashCode)^(key的hashCode无符号右移16位)</td>
<td align="left">key的hashCode</td>
<td align="left">( (key的hashCode)^(key的hashCode无符号右移16位) )&amp;0x7fffffff</td>
</tr>
<tr>
<td align="left">定位算法</td>
<td align="left">哈希地址&amp;(容量大小-1)</td>
<td align="left">(哈希地址&amp;0x7fffffff)%容量大小</td>
<td align="left">哈希地址&amp;(容量大小-1)</td>
</tr>
<tr>
<td align="left">扩容算法</td>
<td align="left">当键值对数量大于阈值，则容量扩容到原来的2倍</td>
<td align="left">当键值对数量大于等于阈值，则容量扩容到原来的2倍+1</td>
<td align="left">当键值对数量大于等于sizeCtl，<strong>单线程创建新哈希表，多线程复制bucket到新哈希表</strong>，容量扩容到原来的2倍</td>
</tr>
<tr>
<td align="left">链表插入</td>
<td align="left">将新节点插入到链表<strong>尾部</strong></td>
<td align="left">将新节点插入到链表<strong>头部</strong></td>
<td align="left">将新节点插入到链表<strong>尾部</strong></td>
</tr>
<tr>
<td align="left">继承的类</td>
<td align="left">继承<code>abstractMap</code>抽象类</td>
<td align="left">继承<code>Dictionary</code>抽象类</td>
<td align="left">继承<code>abstractMap</code>抽象类</td>
</tr>
<tr>
<td align="left">实现的接口</td>
<td align="left">实现<code>Map</code>接口</td>
<td align="left">实现<code>Map</code>接口</td>
<td align="left">实现<code>ConcurrentMap</code>接口</td>
</tr>
<tr>
<td align="left">默认容量大小</td>
<td align="left">16</td>
<td align="left">11</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">默认负载因子</td>
<td align="left">0.75</td>
<td align="left">0.75</td>
<td align="left">0.75</td>
</tr>
<tr>
<td align="left">统计size方式</td>
<td align="left">直接返回成员变量<code>size</code></td>
<td align="left">直接返回成员变量<code>count</code></td>
<td align="left">遍历<code>CounterCell</code>数组的值进行累加，最后加上<code>baseCount</code>的值即为<code>size</code></td>
</tr>
</tbody></table>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">hofe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hofe.work/2020/05/02/Java/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">http://hofe.work/2020/05/02/Java/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hofe.work" target="_blank">Hofe's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502153305.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/05/02/Java/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200502153305.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HashMap实现原理之源码阅读</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'b5cpWE77l9G2Um3MSdyvAmh6-gzGzoHsz',
  appKey: 'LCxOgpdF1CrQ1Xb4dnNrg6OH',
  placeholder: '留下你的足迹吧',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'en',
  recordIP: true,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By hofe</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="http://hofe.work/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = false;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script></body></html>