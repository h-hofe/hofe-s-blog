<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>通过面试题学Java多线程 | Hofe's blog</title><meta name="description" content="通过面试题学Java多线程"><meta name="keywords" content="多线程"><meta name="author" content="hofe"><meta name="copyright" content="hofe"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="http://ta.qq.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="JoP76yOkd4"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="通过面试题学Java多线程"><meta name="twitter:description" content="通过面试题学Java多线程"><meta name="twitter:image" content="http://hofe.work/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="通过面试题学Java多线程"><meta property="og:url" content="http://hofe.work/2020/04/27/Java/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><meta property="og:site_name" content="Hofe's blog"><meta property="og:description" content="通过面试题学Java多线程"><meta property="og:image" content="http://hofe.work/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://hofe.work/2020/04/27/Java/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><link rel="prev" title="Http协议详解" href="http://hofe.work/2020/04/28/%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"><link rel="next" title="项目开发记录" href="http://hofe.work/2020/04/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/Dubbo%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-4088686103083456',
  enable_page_level_ads: 'true'
});</script><script src="https://tajs.qq.com/stats?sId=66539762" charset="UTF-8"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://hofe.work","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">24</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">22</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-clock-o"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments-o"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fa fa-camera"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-info-circle"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、什么是多线程"><span class="toc-text">一、什么是多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-进程与线程"><span class="toc-text">1.1 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-定义"><span class="toc-text">1.1.1 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-区别"><span class="toc-text">1.1.2 区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#线程计数器为什么是私有的"><span class="toc-text">线程计数器为什么是私有的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#虚拟机栈和本地方法栈为什么是私有的"><span class="toc-text">虚拟机栈和本地方法栈为什么是私有的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#共享堆和方法区"><span class="toc-text">共享堆和方法区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-并行与并发"><span class="toc-text">1.2 并行与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-并发编程3大特性"><span class="toc-text">1.2.1 并发编程3大特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-为什么要使用多线程"><span class="toc-text">1.3 为什么要使用多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-使用多线程带来的问题"><span class="toc-text">1.4 使用多线程带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-线程生命周期和状态"><span class="toc-text">1.5 线程生命周期和状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-上下文切换"><span class="toc-text">1.6 上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-线程死锁以及避免"><span class="toc-text">1.7 线程死锁以及避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-sleep-方法和wait-方法区别和共同点？"><span class="toc-text">1.8 sleep()方法和wait()方法区别和共同点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-为什么我们调用-start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><span class="toc-text">1.9 为什么我们调用 start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-多线程实现的三种方式"><span class="toc-text">1.10 多线程实现的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-1-继承Thread，重写run方法"><span class="toc-text">1.10.1 继承Thread，重写run方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-2-实现Runnable接口，重写run方法"><span class="toc-text">1.10.2 实现Runnable接口，重写run方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-3-实现Callable接口，重写run方法"><span class="toc-text">1.10.3 实现Callable接口，重写run方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-4-实现接口-与继承-Thread区别"><span class="toc-text">1.10.4 实现接口 与继承 Thread区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、线程池"><span class="toc-text">二、线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-线程池分类"><span class="toc-text">2.1 线程池分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-通过构造方法实现"><span class="toc-text">2.1.1 通过构造方法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-通过Excutor工具类"><span class="toc-text">2.1.2 通过Excutor工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-text">newCachedThreadPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-text">newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#弊端"><span class="toc-text">弊端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-ThreadPoolExecutor详解"><span class="toc-text">2.2 ThreadPoolExecutor详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-构造参数"><span class="toc-text">2.2.1 构造参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-参数要点"><span class="toc-text">2.2.2 参数要点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-execute执行方法"><span class="toc-text">2.3 execute执行方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-实现-Runnable接口和-Callable接口的区别"><span class="toc-text">2.3.1 实现 Runnable接口和 Callable接口的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-execute-和submit方法区别"><span class="toc-text">2.3.2 execute()和submit方法区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Java锁"><span class="toc-text">三、Java锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-锁的分类"><span class="toc-text">3.1 锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-同步锁与死锁"><span class="toc-text">3.1.1 同步锁与死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-乐观锁"><span class="toc-text">3.1.2 乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-悲观锁"><span class="toc-text">3.1.3 悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-独占锁"><span class="toc-text">3.1.4 独占锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-共享锁"><span class="toc-text">3.1.5 共享锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-6-公平锁与非公平锁"><span class="toc-text">3.1.6 公平锁与非公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-7-可重入锁"><span class="toc-text">3.1.7 可重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-8-分段锁"><span class="toc-text">3.1.8 分段锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-锁的实现"><span class="toc-text">3.2 锁的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-Volatile关键字"><span class="toc-text">3.2.1 Volatile关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-Synchronized"><span class="toc-text">3.2.2 Synchronized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-RetreenLock"><span class="toc-text">3.2.3 RetreenLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-ReentrantLock与synchronized区别"><span class="toc-text">3.2.4 ReentrantLock与synchronized区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-ReentrantReadWriteLock"><span class="toc-text">3.2.5 ReentrantReadWriteLock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-锁优化"><span class="toc-text">3.3 锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-减少锁持有时间"><span class="toc-text">3.3.1 减少锁持有时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-减小锁粒度"><span class="toc-text">3.3.2 减小锁粒度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-锁分离"><span class="toc-text">3.3.3 锁分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-自旋锁"><span class="toc-text">3.3.4 自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-锁消除"><span class="toc-text">3.3.5 锁消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-6-锁粗化"><span class="toc-text">3.3.6 锁粗化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-四种锁状态"><span class="toc-text">3.4 四种锁状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-重量级锁"><span class="toc-text">3.4.1 重量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-轻量级锁"><span class="toc-text">3.4.2 轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-偏向锁"><span class="toc-text">3.4.3 偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-无锁"><span class="toc-text">3.4.4 无锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、CAS（比较并交换）"><span class="toc-text">四、CAS（比较并交换）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-CAS失败的两种情况"><span class="toc-text">4.1 CAS失败的两种情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-原子包Atomic（CAS的应用）"><span class="toc-text">4.2 原子包Atomic（CAS的应用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-ABA问题"><span class="toc-text">4.3 ABA问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、AQS（抽象队列同步器）"><span class="toc-text">五、AQS（抽象队列同步器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-原理"><span class="toc-text">5.1 原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、同步工具类"><span class="toc-text">六、同步工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-CountDownLatch"><span class="toc-text">6.1 CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-CyclicBarrier"><span class="toc-text">6.2 CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Semaphore"><span class="toc-text">6.3 Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-总结"><span class="toc-text">6.4 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、ThreadLocal"><span class="toc-text">七、ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-实现原理"><span class="toc-text">7.1 实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-内存泄漏问题"><span class="toc-text">7.2 内存泄漏问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-总结"><span class="toc-text">7.3 总结</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hofe's blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-clock-o"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments-o"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fa fa-camera"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-info-circle"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">通过面试题学Java多线程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-27 14:36:27"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-27</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-01 14:23:36"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-01</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">13.4k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 43 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/04/27/Java/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/04/27/Java/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><blockquote>
<p>复习多线程时候做的一些笔记，算是比较全的，考察重点比如Synchronized、RetreenLock、CAS都做了一些介绍，不过这些源码更重要，这篇没给出。<br>也尝试过只看面试题，但如果不会原理的话，其实还挺难记住的，需要面试题可以看我的另一篇《Java面试题锦集》那篇博客。<br>这篇博客借鉴了Java3y和JavaGuide的文章，特此感谢，欢迎大家关注他们的公众号，干货多多。</p>
</blockquote>
<h2 id="一、什么是多线程"><a href="#一、什么是多线程" class="headerlink" title="一、什么是多线程"></a>一、什么是多线程</h2><h3 id="1-1-进程与线程"><a href="#1-1-进程与线程" class="headerlink" title="1.1 进程与线程"></a>1.1 进程与线程</h3><h4 id="1-1-1-定义"><a href="#1-1-1-定义" class="headerlink" title="1.1.1 定义"></a>1.1.1 定义</h4><p><strong>进程</strong><br>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程</p>
<p><strong>线程</strong><br>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<h4 id="1-1-2-区别"><a href="#1-1-2-区别" class="headerlink" title="1.1.2 区别"></a>1.1.2 区别</h4><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200427134403354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区DK18之后的元空间）资源，但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</p>
<p>总结：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反</p>
<h5 id="线程计数器为什么是私有的"><a href="#线程计数器为什么是私有的" class="headerlink" title="线程计数器为什么是私有的"></a>线程计数器为什么是私有的</h5><ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了需要注意的是，如果执行的是 native方法，那么程序计数器记录的是 undefined地址，只有执行的是Java代码时程序计数器记录的才是下一条指令的地址。</li>
</ol>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h5 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的"></a>虚拟机栈和本地方法栈为什么是私有的</h5><p><strong>虚拟机栈</strong>：每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在Java虚拟机栈中入栈和出栈的过程</p>
<p><strong>本地方法栈</strong>：和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native方法服务。在 HotSpot虚拟机中和Java虚拟机栈合二为所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</p>
<h5 id="共享堆和方法区"><a href="#共享堆和方法区" class="headerlink" title="共享堆和方法区"></a>共享堆和方法区</h5><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象（所有对象都在这里分配内存），方法区主要用于存放已被加载的类信息常量、静态变量、即时编译器编译后的代码等数据。</p>
<h3 id="1-2-并行与并发"><a href="#1-2-并行与并发" class="headerlink" title="1.2 并行与并发"></a>1.2 并行与并发</h3><p>并行：</p>
<ul>
<li>并行性是指同一时刻内发生两个或多个事件。</li>
<li>并行是在不同实体上的多个事件</li>
</ul>
<p>并发：</p>
<ul>
<li>并发性是指同一时间间隔内发生两个或多个事件。</li>
<li>并发是在同一实体上的多个事件</li>
</ul>
<p>由此可见：并行是针对进程的，并发是针对线程的。</p>
<h4 id="1-2-1-并发编程3大特性"><a href="#1-2-1-并发编程3大特性" class="headerlink" title="1.2.1 并发编程3大特性"></a>1.2.1 并发编程3大特性</h4><p><strong>原子性</strong></p>
<p>对于成员变量a来说，如果线程A执行以下操作：</p>
<p>a++;</p>
<p>此时需要分三步执行：</p>
<ol>
<li><p>读取a的值</p>
</li>
<li><p>将a的值加1</p>
</li>
<li><p>将加1后的值赋给a</p>
</li>
</ol>
<p>在执行以上三步过程中，如果另一个线程B对a进行了操作，那么就不能保证原子性了。</p>
<p>要保证原子性，可以加锁，如<code>synchronized</code></p>
<p><strong>可见性</strong></p>
<p>要理解可见性，需要先理解cpu的高速缓存。高速缓存是cpu的一块儿缓存区。如果线程修改了某个变量的值，那么是先将修改过的值先放入缓存区，然后满足一定条件后才会同步到内存区。同步到内存区后，其他线程才可以看见变量的改变。</p>
<p>可见性是指，当有一个线程修改某个成员变量的值时，其他变量可以立马看到修改过的值。</p>
<p>比如：</p>
<p>int i=0,j=10;</p>
<p>i=j;</p>
<p>如果线程A执行了以上代码，这时如果还未将i等于10的结果由高速缓存区同步到内存区，那么B线程读取到的i的值就是0。</p>
<p>用<code>volatile</code>修饰的变量进行写操作时，会多出一些汇编代码，是以 lock为前缀的汇编指令，这个指令会有以下两种效果：</p>
<ol>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
<p>于是就强制了其他线程重新从内存中读取数据。</p>
<p><strong>有序性</strong></p>
<p>处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>用<strong>volatile</strong>关键字，禁止被它修饰的变量发生指令重排操作。是通过内存屏障去完成的禁止指令重排序。</p>
<h3 id="1-3-为什么要使用多线程"><a href="#1-3-为什么要使用多线程" class="headerlink" title="1.3 为什么要使用多线程"></a>1.3 为什么要使用多线程</h3><p><strong>从计算机底层来说</strong>：线程可以比作是轻量级的进程，是程序执行的最小单位<strong>线程间的切换和调度的成本远远小于进程</strong>。另外，多核CPU时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。<br><strong>从当代互联网发展趋势来说</strong>：现在的系统动不动就要求百万级甚至千万级的并发量，而<strong>多线程并发编程正是开发高并发系统的基础</strong>，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p>
<h3 id="1-4-使用多线程带来的问题"><a href="#1-4-使用多线程带来的问题" class="headerlink" title="1.4 使用多线程带来的问题"></a>1.4 使用多线程带来的问题</h3><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、上下文切换、死锁</strong>还有受限于硬件和软件的资源闲置问题。</p>
<h3 id="1-5-线程生命周期和状态"><a href="#1-5-线程生命周期和状态" class="headerlink" title="1.5 线程生命周期和状态"></a>1.5 线程生命周期和状态</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200427140706741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200427140740209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>由上图可以看出：线程创建之后它将处于<strong>NEW</strong>（新建）状态，调用 <strong>start（）</strong>方法后开始运行，线程这时候处于 <strong>READY</strong>（可运行）状态。可运行状态的线程<strong>获得了CPU时间片</strong>（ timeslice）后就处于<strong>RUNNING</strong>（运行）状态。</p>
<p>当线程执行<strong>wait（）</strong>方法之后，线程进入 <strong>WAITING</strong>（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME WAITING</strong>（超时等待）状态相当于在等待状态的基础上增加了超时限制，比如通过 <strong>sleep</strong>（ Long millis）方法或<strong>wait</strong>（ Long millis）方法可以将Java线程置于 TIMED WAITING状态。当<strong>超时时间到达后java线程将会返回到 RUNNABLE状态</strong>。当线程调用同步方法时，在<strong>没有获取到锁的情况下，线程将会进入到 BLOCKED</strong>（阻塞）状态。线程在执行Runnable的run（）方法之后将会进入到 TERMINATED（终止）状态。</p>
<h3 id="1-6-上下文切换"><a href="#1-6-上下文切换" class="headerlink" title="1.6 上下文切换"></a>1.6 上下文切换</h3><p>概括来说就是：当前任务在执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<h3 id="1-7-线程死锁以及避免"><a href="#1-7-线程死锁以及避免" class="headerlink" title="1.7 线程死锁以及避免"></a>1.7 线程死锁以及避免</h3><p>学过操作系统的朋友都知道产生死锁必须具备以下四个条件</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<p><strong>避免死锁</strong></p>
<ol>
<li>破坏互斥条件：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li>
<li>破坏请求与保持条件：一次性申请所有的资源。</li>
<li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源）释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<h3 id="1-8-sleep-方法和wait-方法区别和共同点？"><a href="#1-8-sleep-方法和wait-方法区别和共同点？" class="headerlink" title="1.8 sleep()方法和wait()方法区别和共同点？"></a>1.8 sleep()方法和wait()方法区别和共同点？</h3><p>两者最主要的区别在于：<strong>sleep方法没有释放锁，而wait方法释放了锁</strong>。</p>
<ul>
<li>两者都可以暂停线程的执行。</li>
<li>wait通常被用于线程间交互/通信， sleep通常被用于暂停执行。</li>
<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify或者notifyAll方法。sleep方法执行完成后，线程会自动苏醒。或者可以使用 wait（long timeout)超时后线程会自动苏醒。</li>
</ul>
<h3 id="1-9-为什么我们调用-start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#1-9-为什么我们调用-start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="1.9 为什么我们调用 start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>1.9 为什么我们调用 start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h3><p>new一个 Thread，线程进入了新建状态；调用start()方法，会启动一个线程并使线程进入了就绪状态当分配到时间片后就可以开始运行了。 <strong>start()会执行线程的相应准备工作</strong>，然后自动执行run()方法的内容，这是真正的多线程工作。<br>而直接执行run()方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。<br><strong>总结</strong>：调用 start方法方可启动线程并使线程进入就绪状态，而run方法只是 thread的一个普通方法调用，还是在主线程里执行。</p>
<h3 id="1-10-多线程实现的三种方式"><a href="#1-10-多线程实现的三种方式" class="headerlink" title="1.10 多线程实现的三种方式"></a>1.10 多线程实现的三种方式</h3><h4 id="1-10-1-继承Thread，重写run方法"><a href="#1-10-1-继承Thread，重写run方法" class="headerlink" title="1.10.1 继承Thread，重写run方法"></a>1.10.1 继承Thread，重写run方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-10-2-实现Runnable接口，重写run方法"><a href="#1-10-2-实现Runnable接口，重写run方法" class="headerlink" title="1.10.2 实现Runnable接口，重写run方法"></a>1.10.2 实现Runnable接口，重写run方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-10-3-实现Callable接口，重写run方法"><a href="#1-10-3-实现Callable接口，重写run方法" class="headerlink" title="1.10.3 实现Callable接口，重写run方法"></a>1.10.3 实现Callable接口，重写run方法</h4><p>有返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。执行 Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务 返回的Object了，再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程 了</p>
<p>Callable 可以有返回值，返回值通过 FutureTask 进行封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-10-4-实现接口-与继承-Thread区别"><a href="#1-10-4-实现接口-与继承-Thread区别" class="headerlink" title="1.10.4 实现接口 与继承 Thread区别"></a>1.10.4 实现接口 与继承 Thread区别</h4><p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<h2 id="二、线程池"><a href="#二、线程池" class="headerlink" title="二、线程池"></a>二、线程池</h2><p>线程池可以看做是线程的集合。线程生命周期的开销非常高，创建和销毁线程所花费的时间和资源可能比处理客户端的任务花费的时间和资源更多，并且还会有某些空闲线程也会占用资源。引入线程池，当请求到来时，线程池给这个请求分配一个空闲的线程，任务完成后回到线程池中等待下次任务(而不是销毁)。这样就实现了线程的重用。</p>
<p>所以说：线程最好是交由线程池来管理，这样可以减少对线程生命周期的管理，一定程度上提高性能。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426193949958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<h3 id="2-1-线程池分类"><a href="#2-1-线程池分类" class="headerlink" title="2.1 线程池分类"></a>2.1 线程池分类</h3><h4 id="2-1-1-通过构造方法实现"><a href="#2-1-1-通过构造方法实现" class="headerlink" title="2.1.1 通过构造方法实现"></a>2.1.1 通过构造方法实现</h4><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426200456516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<h4 id="2-1-2-通过Excutor工具类"><a href="#2-1-2-通过Excutor工具类" class="headerlink" title="2.1.2 通过Excutor工具类"></a>2.1.2 通过Excutor工具类</h4><p>JDK给我们提供了Excutor框架来使用线程池，它是线程池的基础。但是严格意义上讲 Executor 并不是一个线程池，而 只是一个执行线程的工具。真正的线程池接口是ExecutorService<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426190755264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426200432237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><p>该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">	            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">	            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><p>该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">             <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">             <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><p>方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">             <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h5><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426195158760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<h3 id="2-2-ThreadPoolExecutor详解"><a href="#2-2-ThreadPoolExecutor详解" class="headerlink" title="2.2 ThreadPoolExecutor详解"></a>2.2 ThreadPoolExecutor详解</h3><p>Executor调用创建的三种线程池内部也是通过传递ThreadPoolExecutor不同参数实现的。</p>
<h4 id="2-2-1-构造参数"><a href="#2-2-1-构造参数" class="headerlink" title="2.2.1 构造参数"></a>2.2.1 构造参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>核心线程数量</strong>：定义了最小可以同时运行的线程数量</li>
<li><strong>最大线程数量</strong>：当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li>允许线程空闲时间：当线程池中的线程数量大于 corePoo lsize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁</li>
<li>时间对象：keepAliveTime参数的时间单位</li>
<li><strong>阻塞队列</strong>：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</li>
<li>线程工厂：创建新线程的时候会用到</li>
<li>任务拒绝策略：</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020042621072592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<h4 id="2-2-2-参数要点"><a href="#2-2-2-参数要点" class="headerlink" title="2.2.2 参数要点"></a>2.2.2 参数要点</h4><p><strong>线程数量要点：</strong></p>
<ul>
<li>如果运行线程的数量<strong>少于</strong>核心线程数量，则创建新的线程处理请求</li>
<li>如果运行线程的数量<strong>大于</strong>核心线程数量，小于最大线程数量，则当队列满的时候才创建新的线程</li>
<li>如果核心线程数量<strong>等于</strong>最大线程数量，那么将创建固定大小的连接池</li>
<li>如果设置了最大线程数量为无穷，那么允许线程池适合任意的并发数量</li>
</ul>
<p><strong>线程空闲时间要点：</strong></p>
<ul>
<li>当前线程数大于核心线程数，如果空闲时间已经超过了，那该线程会销毁。</li>
</ul>
<p><strong>排队策略要点：</strong></p>
<ul>
<li>同步移交：不会放到队列中，而是等待线程执行它。如果当前线程没有执行，很可能会新开一个线程执行。</li>
<li>无界限策略：如果核心线程都在工作，该线程会放到队列中。所以线程数不会超过核心线程数</li>
<li>有界限策略：可以避免资源耗尽，但是一定程度上减低了吞吐量</li>
</ul>
<p>当线程关闭或者线程数量满了和队列饱和了，就有拒绝任务的情况了：</p>
<p><strong>拒绝任务策略：</strong></p>
<ul>
<li>直接抛出异常</li>
<li>使用调用者的线程来处理</li>
<li>直接丢掉这个任务</li>
<li>丢掉最老的任务</li>
</ul>
<h3 id="2-3-execute执行方法"><a href="#2-3-execute执行方法" class="headerlink" title="2.3 execute执行方法"></a>2.3 execute执行方法</h3><p>在这之前，先了解下Executor与Callable</p>
<h4 id="2-3-1-实现-Runnable接口和-Callable接口的区别"><a href="#2-3-1-实现-Runnable接口和-Callable接口的区别" class="headerlink" title="2.3.1 实现 Runnable接口和 Callable接口的区别"></a>2.3.1 实现 Runnable接口和 Callable接口的区别</h4><p>Runnable自Java1.0以来一直存在，但 Callable仅在Java1.5中引入目的就是为了来处理 Runnable不支持的用例。<br><strong>Runnable接口不会返回结果或抛出检查异常，但是 Callable接口可以。</strong><br>所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable接口，这样代码看起来会更加简洁。</p>
<p>工具类 Executors可以实现 Runnable对象和 Callable对象之间的相互转换。Executors callable（ Runnable task ） 或 Executors, callable（Runnable task, object resule））</p>
<h4 id="2-3-2-execute-和submit方法区别"><a href="#2-3-2-execute-和submit方法区别" class="headerlink" title="2.3.2 execute()和submit方法区别"></a>2.3.2 execute()和submit方法区别</h4><p><strong>submit方法</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426212805147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><strong>execute()方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//如果线程池中运行的线程数量&lt;corePoolSize，则创建新线程来处理请求，即使其他辅助线程是空闲的。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果线程池中运行的线程数量&gt;=corePoolSize，且线程池处于RUNNING状态，且把提交的任务成功放入阻塞队列中，就再次检查线程池的状态，</span></span><br><span class="line">      <span class="comment">// 1.如果线程池不是RUNNING状态，且成功从阻塞队列中删除任务，则该任务由当前 RejectedExecutionHandler 处理。</span></span><br><span class="line">      <span class="comment">// 2.否则如果线程池中运行的线程数量为0，则通过addWorker(null, false)尝试新建一个线程，新建线程对应的任务为null。</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果以上两种case不成立，即没能将任务成功放入阻塞队列中，且addWoker新建线程失败，则该任务由当前 RejectedExecutionHandler 处理。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Java锁"><a href="#三、Java锁" class="headerlink" title="三、Java锁"></a>三、Java锁</h2><h3 id="3-1-锁的分类"><a href="#3-1-锁的分类" class="headerlink" title="3.1 锁的分类"></a>3.1 锁的分类</h3><h4 id="3-1-1-同步锁与死锁"><a href="#3-1-1-同步锁与死锁" class="headerlink" title="3.1.1 同步锁与死锁"></a>3.1.1 同步锁与死锁</h4><p><strong>同步锁</strong><br>当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程 同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可 以使用synchronized关键字来取得一个对象的同步锁。<br><strong>死锁</strong><br>何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放</p>
<h4 id="3-1-2-乐观锁"><a href="#3-1-2-乐观锁" class="headerlink" title="3.1.2 乐观锁"></a>3.1.2 乐观锁</h4><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为 别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数 据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新）， 如果失败则要重复读-比较-写的操作。<br>java 中的乐观锁基本都是通过 <strong>CAS 操作实现</strong>的，CAS 是一种更新的原子操作，比较当前值跟传入 值是否一样，一样则更新，否则失败。 </p>
<h4 id="3-1-3-悲观锁"><a href="#3-1-3-悲观锁" class="headerlink" title="3.1.3 悲观锁"></a>3.1.3 悲观锁</h4><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人 会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block（阻塞）直到拿到锁。 java中的悲观锁就是<code>Synchronized</code>,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到， 才会转换为悲观锁，如<code>RetreenLock</code>。 </p>
<hr>
<p>java并发包提供的加锁模式分为独占锁和共享锁。 </p>
<h4 id="3-1-4-独占锁"><a href="#3-1-4-独占锁" class="headerlink" title="3.1.4 独占锁"></a>3.1.4 独占锁</h4><p>独占锁模式下，每次只能有一个线程能持有锁，<code>ReentrantLock</code> 就是以独占方式实现的互斥锁。 独占锁是一种<strong>悲观</strong>保守的加锁策略，它避免了读/读冲突，如果<strong>某个只读线程获取锁，则其他读线 程都只能等待</strong>，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。 </p>
<h4 id="3-1-5-共享锁"><a href="#3-1-5-共享锁" class="headerlink" title="3.1.5 共享锁"></a>3.1.5 共享锁</h4><p> 共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：<code>ReadWriteLock</code>。共享锁则是一种 <strong>乐观</strong>锁，它放宽了加锁策略，<strong>允许多个执行读操作的线程同时访问共享资源</strong>。 </p>
<ol>
<li>AQS的内部类Node定义了两个常量SHARED和EXCLUSIVE，他们分别标识 AQS队列中等 待线程的锁获取模式。 <ol start="2">
<li>java的并发包中提供了<code>ReadWriteLock</code>，读-写锁。它允许一个资源可以被多个读操作访问， 或者被一个 写操作访问，但两者不能同时进行。 </li>
</ol>
</li>
</ol>
<hr>
<h4 id="3-1-6-公平锁与非公平锁"><a href="#3-1-6-公平锁与非公平锁" class="headerlink" title="3.1.6 公平锁与非公平锁"></a>3.1.6 公平锁与非公平锁</h4><p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁， ReentrantLock在构造函数中提供了是否公平锁的初始化方式来定义公平锁。 </p>
<p>JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了 是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非 程序有特殊需要，否则常用非公平锁的分配机制。</p>
<hr>
<h4 id="3-1-7-可重入锁"><a href="#3-1-7-可重入锁" class="headerlink" title="3.1.7 可重入锁"></a>3.1.7 可重入锁</h4><p>本文里面讲的是广义上的可重入锁，而不是单指JAVA下的ReentrantLock。可重入锁，也叫 做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受 影响。在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁。 </p>
<h4 id="3-1-8-分段锁"><a href="#3-1-8-分段锁" class="headerlink" title="3.1.8 分段锁"></a>3.1.8 分段锁</h4><p>分段锁也并非一种实际的锁，而是一种思想ConcurrentHashMap是学习分段锁的好实践 </p>
<h3 id="3-2-锁的实现"><a href="#3-2-锁的实现" class="headerlink" title="3.2 锁的实现"></a>3.2 锁的实现</h3><h4 id="3-2-1-Volatile关键字"><a href="#3-2-1-Volatile关键字" class="headerlink" title="3.2.1 Volatile关键字"></a>3.2.1 Volatile关键字</h4><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来<strong>确保将变量的更新操作通知到其他 线程</strong>。volatile 变量具备两种特性，volatile变量不会被缓存在寄存器或者对其他处理器不可见的 地方，因此在读取volatile类型的变量时总会返回新写入的值。 </p>
<p><strong>可见性</strong><br>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的 值对于其他线程是可以立即获取的。 </p>
<p><strong>禁止重排序</strong><br>volatile 禁止了指令重排。 </p>
<p><strong>比sychronized关键字更轻量级的同步机制</strong><br>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一 种比sychronized关键字更轻量级的同步机制。volatile适合这种场景：一个变量被多个线程共 享，线程直接给这个变量赋值。 </p>
<p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有 多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。 </p>
<p><strong>适用场景</strong><br>值得说明的是对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量， 但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。在某些场景下可以 代替Synchronized。但是,volatile的不能完全取代Synchronized的位置，只有在一些特殊的场景下，才能适用volatile。<br>总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安 全：   </p>
<ol>
<li>对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）。 </li>
<li>该变量没有包含在具有其他变量的不变式中，也就是说，不同的volatile变量之间，不 能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile</li>
</ol>
<p> <strong>与Synchronized区别</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200427133137535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<h4 id="3-2-2-Synchronized"><a href="#3-2-2-Synchronized" class="headerlink" title="3.2.2 Synchronized"></a>3.2.2 Synchronized</h4><p>Synchronized属于<strong>独占式的悲观锁，同时属于可重 入锁</strong>。<br><strong>作用范围</strong></p>
<ol>
<li>作用于方法时，锁住的是对象的实例(this)； </li>
<li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen （jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁， 会锁所有调用该方法的线程； </li>
<li>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列， 当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。 </li>
</ol>
<p><strong>核心组件</strong></p>
<ol>
<li>Wait Set：调用wait方法被阻塞的线程被放置在这里； </li>
<li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中； </li>
<li>Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中； </li>
<li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck； </li>
<li>Owner：当前已经获取到所有资源的线程被称为Owner；  </li>
<li>!Owner：当前释放锁的线程。 </li>
</ol>
<p><strong>实现</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200427112041199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<ol>
<li><p>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下， <strong>ContentionList会被大量的并发线程进行CAS访问</strong>，为了降低对尾部元素的竞争，JVM会将 一部分线程移动到EntryList中作为候选竞争线程。 </p>
</li>
<li><p>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并<strong>指定 EntryList中的某个线程为OnDeck线程</strong>（一般是先进去的那个线程）。 </p>
</li>
<li><p>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把<strong>锁竞争的权利交给 OnDeck</strong>， OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在 JVM中，也把这种选择行为称之为“竞争切换”。 </p>
</li>
<li><p>OnDeck线程获取到锁资源后会变为Owner线程，而没有得到锁资源的仍然停留在EntryList 中。如果<strong>Owner线程被wait方法阻塞，则转移到WaitSet队列中</strong>，直到某个时刻通过notify 或者notifyAll唤醒，会重新进去EntryList中。 </p>
</li>
<li><p>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统 来完成的（Linux内核下采用pthread_mutex_lock内核函数实现的）。 </p>
</li>
<li><p>Synchronized是非公平锁。 Synchronized在线程进入ContentionList时，等待的线程会先 尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是 不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁 资源。 参考：<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">https://blog.csdn.net/zqz_zqz/article/details/70233767</a> </p>
</li>
<li><p>每个<strong>对象都有个 monitor 对象</strong>，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加 上monitorenter和monitorexit指令来实现的，方法加锁是通过一个标记位来判断的 </p>
</li>
<li><p>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线 程加锁消耗的时间比有用操作消耗的时间更多。 </p>
</li>
<li><p>Java1.6，synchronized进行了很多的优化，有<strong>适应自旋、锁消除、锁粗化、轻量级锁及偏向 锁</strong>等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做 了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。 </p>
</li>
<li><p>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀； </p>
<p><strong>双重检验所锁实现单例模式</strong><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200427132358957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
</li>
</ol>
<h4 id="3-2-3-RetreenLock"><a href="#3-2-3-RetreenLock" class="headerlink" title="3.2.3 RetreenLock"></a>3.2.3 RetreenLock</h4><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种<strong>可重入锁</strong>，除了能完 成 synchronized 所能完成的所有工作外，还提供了诸如<strong>可响应中断锁、可轮询锁请求、定时锁</strong>等 <strong>避免多线程死锁</strong>的方法。 </p>
<p><strong>Lock主要方法</strong></p>
<ol>
<li>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经 被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁. </li>
<li>boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和 lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一 直等待, 在未获得锁之前,当前线程并不继续向下执行.  </li>
<li>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程 并不持有锁, 却执行该方法, 可能导致异常的发生. </li>
<li>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定， 当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。 </li>
<li>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行lock方法的次 数。 </li>
<li>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个 线程获得锁，此时返回的是9 </li>
<li>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线 程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了 condition对象的 await方法，那么此时执行此方法返回10 </li>
<li>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件 (condition)，对于指定contidion对象，有多少线程执行了condition.await方法 </li>
<li>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁 </li>
<li>hasQueuedThreads()：是否有线程等待此锁 </li>
<li>isFair()：该锁是否公平锁 </li>
<li>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分 别是false和true </li>
<li>isLock()：此锁是否有任意线程占用 </li>
<li>lockInterruptibly（）：如果当前线程未被中断，获取锁 </li>
<li>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁 </li>
<li>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持， 则获取该锁</li>
</ol>
<p><strong>ReentrantLock实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123; </span><br><span class="line">            <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); </span><br><span class="line"> <span class="comment">//Lock lock=new ReentrantLock(true);//公平锁 </span></span><br><span class="line">            <span class="comment">//Lock lock=new ReentrantLock(false);//非公平锁 </span></span><br><span class="line">           <span class="keyword">private</span> Condition condition=lock.newCondition();<span class="comment">//创建Condition </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123; </span><br><span class="line">             <span class="keyword">try</span> &#123; </span><br><span class="line">               lock.lock();<span class="comment">//lock加锁 </span></span><br><span class="line">  <span class="comment">//1：wait 方法等待： </span></span><br><span class="line">            <span class="comment">//System.out.println("开始wait"); </span></span><br><span class="line">            condition.await(); </span><br><span class="line"><span class="comment">//通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁 </span></span><br><span class="line"> <span class="comment">//:2：signal方法唤醒 </span></span><br><span class="line"> condition.signal();<span class="comment">//condition对象的signal方法可以唤醒wait 线程 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line"> System.out.println(<span class="string">"ThreadName="</span> + Thread.currentThread().getName()+ (<span class="string">" "</span> + (i + <span class="number">1</span>))); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">             e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123; </span><br><span class="line">            lock.unlock(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Condition类与Object类区别</strong></p>
<ol>
<li>Condition类的awiat方法和Object类的wait方法等效 <ol start="2">
<li>Condition类的signal方法和Object类的notify方法等效 </li>
<li>Condition类的signalAll方法和Object类的notifyAll方法等效 </li>
<li>ReentrantLock类可以唤醒指定条件的线程，而object的唤醒是随机的 </li>
</ol>
</li>
</ol>
<p><strong>tryLock与 lock 和 lockInterruptibly区别</strong></p>
<ol>
<li>tryLock能获得锁就返回true，不能就立即返回false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回false <ol start="2">
<li>lock能获得锁就返回true，不能的话一直等待获得锁 </li>
<li>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程， lock不会抛出异常，而lockInterruptibly会抛出异常</li>
</ol>
</li>
</ol>
<h4 id="3-2-4-ReentrantLock与synchronized区别"><a href="#3-2-4-ReentrantLock与synchronized区别" class="headerlink" title="3.2.4 ReentrantLock与synchronized区别"></a>3.2.4 ReentrantLock与synchronized区别</h4><ol>
<li>ReentrantLock 通过方法lock()与unlock()来进行加锁与解锁操作，与synchronized会 被 JVM 自动解锁机制不同，<strong>ReentrantLock 加锁后需要手动进行解锁</strong>。为了避免程序出 现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操 作。 </li>
<li>ReentrantLock相比synchronized的优势是<strong>可中断、公平锁、多个锁</strong>。这种情况下需要 使用ReentrantLock。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020042711585666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><h4 id="3-2-5-ReentrantReadWriteLock"><a href="#3-2-5-ReentrantReadWriteLock" class="headerlink" title="3.2.5 ReentrantReadWriteLock"></a>3.2.5 ReentrantReadWriteLock</h4>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如 果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写 锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。 </li>
</ol>
<p><strong>读锁</strong><br>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 </p>
<p> <strong>写锁</strong><br>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。</p>
<p>总之，读的时候上 读锁，写的时候上写锁！<br>Java 中读写锁有个接口 java.util.concurrent.locks.ReadWriteLock ，也有具体的实现 <code>ReentrantReadWriteLock</code></p>
<h3 id="3-3-锁优化"><a href="#3-3-锁优化" class="headerlink" title="3.3 锁优化"></a>3.3 锁优化</h3><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p>
<h4 id="3-3-1-减少锁持有时间"><a href="#3-3-1-减少锁持有时间" class="headerlink" title="3.3.1 减少锁持有时间"></a>3.3.1 减少锁持有时间</h4><p> 只用在有线程安全要求的程序上加锁 </p>
<h4 id="3-3-2-减小锁粒度"><a href="#3-3-2-减小锁粒度" class="headerlink" title="3.3.2 减小锁粒度"></a>3.3.2 减小锁粒度</h4><p> 将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。 降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。典型的减小锁粒度的案例就是 ConcurrentHashMap。 </p>
<h4 id="3-3-3-锁分离"><a href="#3-3-3-锁分离" class="headerlink" title="3.3.3 锁分离"></a>3.3.3 锁分离</h4><p> 常见的锁分离就是读写锁ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互 斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发Java 五] JDK并发包1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如 LinkedBlockingQueue 从头部取出，从尾部放数据 </p>
<h4 id="3-3-4-自旋锁"><a href="#3-3-4-自旋锁" class="headerlink" title="3.3.4 自旋锁"></a>3.3.4 自旋锁</h4><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h4 id="3-3-5-锁消除"><a href="#3-3-5-锁消除" class="headerlink" title="3.3.5 锁消除"></a>3.3.5 锁消除</h4><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p>
<p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h4 id="3-3-6-锁粗化"><a href="#3-3-6-锁粗化" class="headerlink" title="3.3.6 锁粗化"></a>3.3.6 锁粗化</h4><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<h3 id="3-4-四种锁状态"><a href="#3-4-四种锁状态" class="headerlink" title="3.4 四种锁状态"></a>3.4 四种锁状态</h3><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。 </p>
<h4 id="3-4-1-重量级锁"><a href="#3-4-1-重量级锁" class="headerlink" title="3.4.1 重量级锁"></a>3.4.1 重量级锁</h4><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又 是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要<strong>从用 户态转换到核心态，这个成本非常高</strong>，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为 “重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。 JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和 “偏向锁”。</p>
<h4 id="3-4-2-轻量级锁"><a href="#3-4-2-轻量级锁" class="headerlink" title="3.4.2 轻量级锁"></a>3.4.2 轻量级锁</h4><p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，它使用 CAS 操作来避免重量级锁使用互斥量的开销。但是，首先需要强调一点的是， 轻量级锁并不是用来代替重量级锁的，它的本意是在<strong>没有多线程竞争的前提下，减少传统的重量 级锁使用产生的性能消耗</strong>。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所<strong>适应的场 景是线程交替执行同步块</strong>的情况（整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步），<strong>如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀 为重量级锁</strong>（ CAS 失败了再改用互斥量进行同步）。</p>
<h4 id="3-4-3-偏向锁"><a href="#3-4-3-偏向锁" class="headerlink" title="3.4.3 偏向锁"></a>3.4.3 偏向锁</h4><p>偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起 来让这个线程得到了偏护。这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。轻 量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进 一步提高性能。 </p>
<h4 id="3-4-4-无锁"><a href="#3-4-4-无锁" class="headerlink" title="3.4.4 无锁"></a>3.4.4 无锁</h4><h2 id="四、CAS（比较并交换）"><a href="#四、CAS（比较并交换）" class="headerlink" title="四、CAS（比较并交换）"></a>四、CAS（比较并交换）</h2><blockquote>
<p>比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p>
</blockquote>
<p>它包含 3 个参数 CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N；如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当 前线程什么都不做。最后，CAS返回当前V的真实值。 </p>
<p>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时 使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。<strong>失败的线程不会被挂起</strong>，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理， <strong>CAS操作即使没有锁</strong>，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。 </p>
<h3 id="4-1-CAS失败的两种情况"><a href="#4-1-CAS失败的两种情况" class="headerlink" title="4.1 CAS失败的两种情况"></a>4.1 CAS失败的两种情况</h3><p><strong>失败放弃</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426180037775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<p><strong>失败自旋（循环再试）</strong><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426180122522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426180149190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<h3 id="4-2-原子包Atomic（CAS的应用）"><a href="#4-2-原子包Atomic（CAS的应用）" class="headerlink" title="4.2 原子包Atomic（CAS的应用）"></a>4.2 原子包Atomic（CAS的应用）</h3><p>原子变量类在<code>java.util.concurrent.atomic</code>包下<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426180344581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>我们可以对其进行分类：</p>
<ul>
<li>基本类型：<ul>
<li>AtomicBoolean：布尔型</li>
<li>AtomicInteger：整型</li>
<li>AtomicLong：长整型</li>
</ul>
</li>
<li>数组：<ul>
<li>AtomicIntegerArray：数组里的整型</li>
<li>AtomicLongArray：数组里的长整型</li>
<li>AtomicReferenceArray：数组里的引用类型</li>
</ul>
</li>
<li>引用类型：<ul>
<li>AtomicReference：引用类型</li>
<li>AtomicStampedReference：带有版本号的引用类型</li>
<li>AtomicMarkableReference：带有标记位的引用类型</li>
</ul>
</li>
<li>对象的属性：<ul>
<li>AtomicIntegerFieldUpdater：对象的属性是整型</li>
<li>AtomicLongFieldUpdater：对象的属性是长整型</li>
<li>AtomicReferenceFieldUpdater：对象的属性是引用类型</li>
</ul>
</li>
</ul>
<p>JDK8新增DoubleAccumulator、LongAccumulator、DoubleAdder、LongAdder是对AtomicLong等类的改进。比如LongAccumulator与LongAdder在高并发环境下比AtomicLong更高效。</p>
<p><strong>AtomicInteger实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享变量(使用AtomicInteger来替代Synchronized锁)</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Atomic包里的类基本都是使用Unsafe实现的包装类。<br>Unsafe里边有几个我们喜欢的方法(CAS)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一和第二个参数代表对象的实例以及地址，第三个参数代表期望值，第四个参数代表更新值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure>
<p>从原理上概述就是：Atomic包的类的实现绝大调用Unsafe的方法，而<strong>Unsafe底层实际上是调用C代码</strong>，C代码调用汇编，最后生成出一条CPU指令cmpxchg，完成操作。这也就为啥CAS是原子性的，因为它是一条<strong>CPU指令，不会被打断</strong>。</p>
<p><strong>compareAndSwapInt实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">           <span class="keyword">return</span> value;   </span><br><span class="line">     &#125;   </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  <span class="comment">//CAS自旋，一直尝试，直达成功 </span></span><br><span class="line">           <span class="keyword">int</span> current = get();   </span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;   </span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))   </span><br><span class="line">                <span class="keyword">return</span> current;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-ABA问题"><a href="#4-3-ABA问题" class="headerlink" title="4.3 ABA问题"></a>4.3 ABA问题</h3><p>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时 刻比较并替换，那么在这个时间差类会导致数据的变化。 </p>
<p><strong>描述</strong><br>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操 作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过 程就是没有问题的。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426181530314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<p> <strong>解决</strong><br>部分乐观锁的实现是通过版本号（version）的方式来解决ABA问题，乐观锁每次在执行数据的修 改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本 号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问 题，因为版本号只会增加不会减少。 </p>
<h2 id="五、AQS（抽象队列同步器）"><a href="#五、AQS（抽象队列同步器）" class="headerlink" title="五、AQS（抽象队列同步器）"></a>五、AQS（抽象队列同步器）</h2><p>AbstractQueuedSynchronizer类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问 共享资源的同步器框架，许多同步类实现都依赖于它，Lock的子类实现都是基于AQS的。如常用的 ReentrantLock/Semaphore/CountDownLatch。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426181834494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<h3 id="5-1-原理"><a href="#5-1-原理" class="headerlink" title="5.1 原理"></a>5.1 原理</h3><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC80LzI1LzE2MmZjZDM0ZGQ2MjFlMzI?x-oss-process=image/format,png"  alt="https://user-gold-cdn.xitu.io/2018/4/25/162fcd34dd621e32?w=1864&amp;h=4179&amp;f=png&amp;s=799799"><br>通读了一遍，可以总结出以下比较关键的信息：</p>
<ul>
<li>AQS其实就是一个可以给我们实现锁的框架</li>
<li>内部实现的关键是：先进先出的队列、state状态</li>
<li>定义了内部类ConditionObject</li>
<li>拥有两种线程模式<ul>
<li>独占模式</li>
<li>共享模式</li>
</ul>
</li>
<li>在LOCK包中的相关锁(常用的有ReentrantLock、ReadWriteLock)都是基于AQS来构建</li>
<li>一般我们叫AQS为同步器</li>
</ul>
<h2 id="六、同步工具类"><a href="#六、同步工具类" class="headerlink" title="六、同步工具类"></a>六、同步工具类</h2><p>Java为我们提供了三个同步工具类：</p>
<ul>
<li>CountDownLatch(闭锁、线程计数器)</li>
<li>CyclicBarrier(栅栏)</li>
<li>Semaphore(信号量)<br>这几个工具类是为了能够更好控制线程之间的通讯问题</li>
</ul>
<h3 id="6-1-CountDownLatch"><a href="#6-1-CountDownLatch" class="headerlink" title="6.1 CountDownLatch"></a>6.1 CountDownLatch</h3><p>CountDownLatch是一个同步的辅助类，允许一个或多个线程一直等待，直到其它线程完成它们的操作。（任务A需要等待其它4个任务完成才能执行）<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426173850288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>它常用的API其实就两个:await()和countDown()<br><strong>用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3y线程启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里调用的是await()不是wait()</span></span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"等待其它线程执行完毕才开始"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他线程启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"其它线程执行完毕"</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-CyclicBarrier"><a href="#6-2-CyclicBarrier" class="headerlink" title="6.2 CyclicBarrier"></a>6.2 CyclicBarrier</h3><p>CyclicBarrier允许一组线程互相等待，直到到达某个<strong>公共屏障点</strong>。叫做cyclic是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用(对比于CountDownLatch是不能重用的)</p>
<p><strong>用法</strong><br>CountDownLatch注重的是等待其他线程完成，CyclicBarrier注重的是：当线程到达某个状态后，暂停下来等待其他线程，所有线程均到达以后，继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CyclicBarrier CyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                <span class="keyword">if</span> (name.equals(<span class="string">"Thread-0"</span>)) &#123;</span><br><span class="line">                    name = <span class="string">"线程0"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    name = <span class="string">"线程1"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(name + <span class="string">"等待执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 两个人都要到体育西才能发朋友圈</span></span><br><span class="line">                    CyclicBarrier.await();</span><br><span class="line">                    <span class="comment">// 他俩到达了体育西，看见了对方发了一条朋友圈：</span></span><br><span class="line">                    System.out.println(name+<span class="string">"可以开始执行"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-Semaphore"><a href="#6-3-Semaphore" class="headerlink" title="6.3 Semaphore"></a>6.3 Semaphore</h3><p>Semaphore(信号量)实际上就是可以控制同时访问的线程个数，它维护了一组”许可证”。</p>
<ul>
<li>当调用acquire()方法时，会消费一个许可证。如果没有许可证了，会阻塞起来</li>
<li>当调用release()方法时，会添加一个许可证。</li>
</ul>
<p>这些”许可证”的个数其实就是一个count变量</p>
<p><strong>用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设有50个同时来到酸奶店门口</span></span><br><span class="line">        <span class="keyword">int</span> nums = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 酸奶店只能容纳10个人同时挑选酸奶</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 有"号"的才能进酸奶店挑选购买</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"顾客"</span> + finalI + <span class="string">"在挑选商品，购买..."</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 假设挑选了xx长时间，购买了</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 归还一个许可，后边的就可以进来购买了</span></span><br><span class="line">                    System.out.println(<span class="string">"顾客"</span> + finalI + <span class="string">"购买完毕了..."</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>Java为我们提供了三个同步工具类：</p>
<ul>
<li>CountDownLatch(闭锁)某个线程等待其他线程执行完毕后，它才执行(其他线程等待某个线程执行完毕后，它才执行)</li>
<li>CyclicBarrier(栅栏)一组线程互相等待至某个状态，这组线程再同时执行。</li>
<li>Semaphore(信号量)控制一组线程同时执行。<h2 id="七、ThreadLocal"><a href="#七、ThreadLocal" class="headerlink" title="七、ThreadLocal"></a>七、ThreadLocal</h2>ThreadLocal 提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离。</li>
</ul>
<p>ThreadLocal设计的目的是为了能够在当前线程中有属于自己的变量，并<strong>不是为了解决并发或者共享变量的问题</strong></p>
<h3 id="7-1-实现原理"><a href="#7-1-实现原理" class="headerlink" title="7.1 实现原理"></a>7.1 实现原理</h3><p>Set和Get方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 得到当前线程对象</span></span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 这里获取ThreadLocalMap</span></span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果map存在，则将当前线程对象t作为key，要存储的对象作为value存到map里面去</span></span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过currentThread()方法可以获得Thread对象t，通过getMap(t)就可以获得当前的ThreadLocalMap对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//....很长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocalMap是ThreadLocal的一个内部类。用Entry类来进行存储。我们的值都是存储到这个Map上的，key是当前ThreadLocal对象，而value为要存储的对象！<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426172336356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<h3 id="7-2-内存泄漏问题"><a href="#7-2-内存泄漏问题" class="headerlink" title="7.2 内存泄漏问题"></a>7.2 内存泄漏问题</h3><p>ThreadLocal的对象关系引用图：<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426172607723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>
<blockquote>
<p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200426172808499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDExNzIz,size_16,color_FFFFFF,t_70"  alt="这里是引用"></p>
</blockquote>
<p><strong>另一种说法：</strong><br>ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p>
<p>想要避免内存泄露就要手动remove()</p>
<h3 id="7-3-总结"><a href="#7-3-总结" class="headerlink" title="7.3 总结"></a>7.3 总结</h3><ol>
<li>每个Thread维护着一个ThreadLocalMap的引用</li>
<li>ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储</li>
<li>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象</li>
<li>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</li>
<li>ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。</li>
</ol>
<p>正因为这个原理，所以ThreadLocal能够实现“数据隔离”，获取当前线程的局部变量值，不受其他线程影响。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">hofe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hofe.work/2020/04/27/Java/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">http://hofe.work/2020/04/27/Java/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hofe.work" target="_blank">Hofe's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/28/%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Http协议详解</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/Dubbo%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200427153333.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">项目开发记录</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'b5cpWE77l9G2Um3MSdyvAmh6-gzGzoHsz',
  appKey: 'LCxOgpdF1CrQ1Xb4dnNrg6OH',
  placeholder: '留下你的足迹吧',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'en',
  recordIP: true,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By hofe</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="http://hofe.work/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = false;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script></body></html>