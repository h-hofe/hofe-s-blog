<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL学习笔记基础篇 | Hofe's blog</title><meta name="description" content="MySQL学习笔记基础篇"><meta name="keywords" content="MySQL"><meta name="author" content="hofe"><meta name="copyright" content="hofe"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="http://ta.qq.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="JoP76yOkd4"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="MySQL学习笔记基础篇"><meta name="twitter:description" content="MySQL学习笔记基础篇"><meta name="twitter:image" content="https://gitee.com/hofe/graph/raw/master/img/20200625152804.png"><meta property="og:type" content="article"><meta property="og:title" content="MySQL学习笔记基础篇"><meta property="og:url" content="http://hofe.work/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/"><meta property="og:site_name" content="Hofe's blog"><meta property="og:description" content="MySQL学习笔记基础篇"><meta property="og:image" content="https://gitee.com/hofe/graph/raw/master/img/20200625152804.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://hofe.work/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/"><link rel="prev" title="Markdown中使用flow绘制流程图" href="http://hofe.work/2020/05/01/%E5%B7%A5%E5%85%B7/Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8flow%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/"><link rel="next" title="HTTPS协议详解" href="http://hofe.work/2020/04/28/%E7%BD%91%E7%BB%9C/Https%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-4088686103083456',
  enable_page_level_ads: 'true'
});</script><script src="https://tajs.qq.com/stats?sId=66539762" charset="UTF-8"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://hofe.work","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">65</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">61</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">45</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-clock-o"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments-o"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fa fa-camera"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-info-circle"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、概念"><span class="toc-text">一、概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、存储引擎"><span class="toc-text">二、存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-什么是存储引擎"><span class="toc-text">2.1 什么是存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-存储引擎分类"><span class="toc-text">2.2 存储引擎分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-MyISAM和InnoDB的区别"><span class="toc-text">2.3 MyISAM和InnoDB的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、索引"><span class="toc-text">三、索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-索引是什么"><span class="toc-text">3.1 索引是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1为什么要使用索引"><span class="toc-text">3.1.1为什么要使用索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-索引分类"><span class="toc-text">3.2 索引分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-索引数据结构"><span class="toc-text">3.3 索引数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-MyISAM和InnoDB索引实现"><span class="toc-text">3.4 MyISAM和InnoDB索引实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-MyISAM实现"><span class="toc-text">3.4.1 MyISAM实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-InnoDB实现"><span class="toc-text">3.4.2 InnoDB实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-其他关于索引的问题"><span class="toc-text">3.5 其他关于索引的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、事务"><span class="toc-text">四、事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-特性ACID"><span class="toc-text">4.1 特性ACID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-实现原理"><span class="toc-text">4.2 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-原子性"><span class="toc-text">4.2.1 原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-持久性"><span class="toc-text">4.2.2 持久性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-隔离性"><span class="toc-text">4.2.3 隔离性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-一致性"><span class="toc-text">4.2.4 一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-并发一致性问题"><span class="toc-text">4.2.5 并发一致性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6-隔离级别"><span class="toc-text">4.2.6 隔离级别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、锁机制"><span class="toc-text">五、锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-什么是乐观锁和悲观锁"><span class="toc-text">5.1 什么是乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-事务隔离是怎么实现的？有哪些锁？"><span class="toc-text">5.2  事务隔离是怎么实现的？有哪些锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-三级加锁协议（可解决脏读和不可重复读）"><span class="toc-text">5.3 三级加锁协议（可解决脏读和不可重复读）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、MVCC"><span class="toc-text">六、MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-什么是MVCC"><span class="toc-text">6.1 什么是MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-什么是读写冲突"><span class="toc-text">6.2 什么是读写冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-为什么需要MVCC"><span class="toc-text">6.3 为什么需要MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-事务所带来的问题"><span class="toc-text">6.3.1 事务所带来的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-MVCC原理"><span class="toc-text">6.4 MVCC原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-行记录结构"><span class="toc-text">6.4.1 行记录结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-版本链"><span class="toc-text">6.4.2 版本链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-ReadView"><span class="toc-text">6.4.3 ReadView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-4-不同隔离级别下的ReadView"><span class="toc-text">6.4.4 不同隔离级别下的ReadView</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXPLAIN查询"><span class="toc-text">EXPLAIN查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#drop、truncate和delete的区别"><span class="toc-text">drop、truncate和delete的区别</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/hofe/graph/raw/master/img/20200625152804.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hofe's blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-clock-o"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments-o"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fa fa-camera"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-info-circle"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">MySQL学习笔记基础篇</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-28 16:37:45"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-25 16:58:57"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-25</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">12k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 37 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><blockquote>
<p>这篇介绍了下Mysql面试题常考内容，并做了延伸；个人觉得MVCC部分讲的应该是网上较为清楚的了。</p>
<p>参考：</p>
<p><a href="https://www.codercto.com/a/88775.html" target="_blank" rel="noopener">https://www.codercto.com/a/88775.html</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1629409989970483292&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1629409989970483292&amp;wfr=spider&amp;for=pc</a></p>
</blockquote>
<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>mysql 有那些存储引擎，有哪些区别（innodb 与myisam 的区别？ ）</p>
<p>mysql 索引在什么情况下会失效 </p>
<p>mysql 的索引模型 </p>
<p>数据库为什么用B+树。联合索引特点</p>
<p>可重复读是什么；</p>
<p>有一段代码，两个session，判断结果是什么（和重复读有关）；</p>
<p>数据库用什么实现可重复读。</p>
<h2 id="二、存储引擎"><a href="#二、存储引擎" class="headerlink" title="二、存储引擎"></a>二、存储引擎</h2><h3 id="2-1-什么是存储引擎"><a href="#2-1-什么是存储引擎" class="headerlink" title="2.1 什么是存储引擎"></a>2.1 什么是存储引擎</h3><blockquote>
<p>MySQL中的数据用各种不同的技术存储在文件(或者内存)中。每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p>
</blockquote>
<h3 id="2-2-存储引擎分类"><a href="#2-2-存储引擎分类" class="headerlink" title="2.2 存储引擎分类"></a>2.2 存储引擎分类</h3><p>使用<code>show engines;</code>可查看引擎种类，有<strong>MEMORY</strong>、<strong>ARCHIVE</strong>、<strong>MERGE</strong>等等，主要的是<strong>MyISAM</strong>和<strong>InnoDB</strong>。</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163020.png"  alt=""></p>
<h3 id="2-3-MyISAM和InnoDB的区别"><a href="#2-3-MyISAM和InnoDB的区别" class="headerlink" title="2.3 MyISAM和InnoDB的区别"></a>2.3 MyISAM和InnoDB的区别</h3><ol>
<li><p>存储结构</p>
<ul>
<li><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。 .frm文件存储表定义，数据文件的扩展名为.MYD(MYD)，索引文件的扩展名是.MYI(MYIndex)。</p>
</li>
<li><p>InnoDB:所在的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p>
</li>
</ul>
</li>
<li><p>存储空间</p>
<ul>
<li><p>MyISAM:可被压缩，存储空间较小。支持三种不同的存储格式：静态表、动态表、压缩表。</p>
</li>
<li><p>InnoDB:需要更多的内存和存储，它会在主内存中建立其专用的<strong>缓冲池用于高速缓冲数据和索引</strong>。</p>
</li>
</ul>
</li>
<li><p>事务支持</p>
<ul>
<li><p>MyISAM:强调的是<strong>性能</strong>，每次查询具有原子性，其执行速度比Innodb类型更快，但是不提供事务支持。</p>
</li>
<li><p>InnoDB:提供事务支持。具有提交（commit）、回滚（rollback）和崩溃修复能力（crach recovery capabilities）的事务安全（transaction-safe ACID compliant）型表。</p>
</li>
</ul>
</li>
<li><p>CURD操作</p>
<ul>
<li><p>MyISAM: 如果执行大量的select, MyISAM是更好的选择。（因为没有支持行级锁），在增删的时候需要锁定整个表格，效率会低一些。</p>
</li>
<li><p>InnoDB:如果你的数据执行大量的insert或update，出于性能方面的考虑，应该使用InnoDB表。innoDB支持行级锁，删除插入的时候只需要锁定该行就行，效率较高。但delete from table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p>
</li>
</ul>
</li>
<li><p>外键</p>
<ul>
<li><p>MyISAM: 不支持。</p>
</li>
<li><p>InoDB:支持。</p>
</li>
</ul>
</li>
<li><p>索引</p>
<ul>
<li><p>MyISAM:采用<strong>非聚集索引</strong>，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是<strong>辅索引不用保证唯一性</strong>。支持全文索引和空间索引。</p>
</li>
<li><p>InnoDB:主键索引采用<strong>聚集索引</strong>（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问主键索引。</p>
</li>
</ul>
</li>
</ol>
<h2 id="三、索引"><a href="#三、索引" class="headerlink" title="三、索引"></a>三、索引</h2><h3 id="3-1-索引是什么"><a href="#3-1-索引是什么" class="headerlink" title="3.1 索引是什么"></a>3.1 索引是什么</h3><p>索引(Index)是帮助MySQL高效获取数据的数据结构。可以简单理解为：<strong>快速查找排好序的一种数据结构</strong>，可以提高数据检索的效率，降低数据库的IO成本</p>
<h4 id="3-1-1为什么要使用索引"><a href="#3-1-1为什么要使用索引" class="headerlink" title="3.1.1为什么要使用索引"></a>3.1.1为什么要使用索引</h4><p>查询数据时需要从磁盘中全表扫描读取数据，会遇上两个问题</p>
<ul>
<li>数据量过大的时候，从磁盘中读数据到内存，内存是否有足够容量存放</li>
<li>如果表非常大，那么我们不可能一次将所有的数据读到内存，需要分多次读取磁盘，而操作磁盘相对于内存来说是一个非常耗时的操作</li>
</ul>
<p><strong>优点</strong>：</p>
<ol>
<li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性</li>
<li>大大加快数据的查询速度</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加</p>
</li>
<li><p>索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值</p>
</li>
<li><p>当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。</p>
</li>
</ol>
<p><strong>使用原则</strong>：</p>
<p>通过上面说的优点和缺点，我们应该可以知道，并不是每个字段都设置索引就好，也不是索引越多越好，而是需要自己合理的使用。</p>
<p><strong>加在哪些列上？</strong></p>
<ol>
<li>在经<strong>常需要搜索的列</strong>上，可以加快搜索的速度；</li>
<li>在作为<strong>主键的列</strong>上，强制该列的唯一性和组织表中数据的排列结构；</li>
<li>在经常用在<strong>连接</strong>的列上，这些列主要是一些外键，可以加快连接的速度；</li>
<li>在经常需要根据<strong>范围进行搜索</strong>的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>
<li>在经常需要<strong>排序的列</strong>上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>在经常使用在<strong>WHERE子句中的列</strong>上面创建索引，加快条件的判断速度</li>
</ol>
<p><strong>不该加在哪些列上？</strong></p>
<ol>
<li><p>对于那些在<strong>查询中很少使用</strong>或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
</li>
<li><p>对于那些只有<strong>很少数据值的列</strong>也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
</li>
<li><p>第三，对于那些定义为<strong>text, image和bit数据类型</strong>的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</p>
</li>
<li><p>第四，当<strong>修改性能远远大于检索性能时，不应该创建索引</strong>。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p>
</li>
</ol>
<h3 id="3-2-索引分类"><a href="#3-2-索引分类" class="headerlink" title="3.2 索引分类"></a>3.2 索引分类</h3><p>按照<strong>索引形式</strong>不同可以分为：</p>
<ul>
<li><p>普通索引：仅加速查询</p>
</li>
<li><p>唯一索引：加速查询 + 列值唯一（可以有null）</p>
</li>
<li><p>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</p>
</li>
<li><p>全文索引：对文本的内容进行分词，进行搜索</p>
</li>
<li><p>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于<strong>索引合并</strong></p>
</li>
</ul>
<p>按照<strong>索引实现方式</strong>不同可以分为：</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
<th>特点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>B+ Tree索引</td>
<td>使用B+ Tree作为底层实现</td>
<td>对树进行搜索，查找速度快分为聚簇索引和非聚簇索引</td>
<td>查找、排序、分组</td>
</tr>
<tr>
<td>哈希索引</td>
<td>使用哈希作为底层实现</td>
<td>无法用于排序与分组只支持精确查找，时间复杂度为O(1)</td>
<td>当索引值使用的频繁时，会在B+ Tree索引之上再创建一个哈希索引</td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引使用倒排索引实现，记录着关键词到其所在文档的映射</td>
<td></td>
<td>查找文本中的关键词</td>
</tr>
<tr>
<td>空间索引</td>
<td></td>
<td>从所有维度来索引数据</td>
<td>用于地理数据存储</td>
</tr>
</tbody></table>
<h3 id="3-3-索引数据结构"><a href="#3-3-索引数据结构" class="headerlink" title="3.3 索引数据结构"></a>3.3 索引数据结构</h3><p>数据库<strong>索引是存储在磁盘</strong>上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应<strong>索引树的节点</strong>）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。</p>
<p>通过对比各种数据结构的特点，可以回答为什么要用B+Tree作为数据库的索引的问题</p>
<p><strong>和其他数据结构对比来看</strong>：</p>
<p>二叉搜索树：如果数据是单边增长的情况，那么出现的就是和链表一样的数据结构了，树高度大。</p>
<p>红黑树：在二叉树的基础上多了树平衡，也叫二叉平衡树，不像二叉树那样极端的情况会往一个方向发展，但数据量大的话，红黑树的深度会很深，也就是说深度不可控，这样一来查找数据还是会很耗时。</p>
<p>Hash表：通过hash函数计算出数据映射位置，相比较于红黑树，hash可以固定“深度”，且映射到磁盘存储引用，但是 hash 还是有些不足：只能用于精确查找的场景，无法进行范围查询。</p>
<p>BTree：每个节点是一个二元数组，存放着key，value， 从左到右递增排列。节点之间存放着指向这相应区间范围内的节点。然而也存在着一些缺陷：</p>
<ol>
<li>在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。造成IO操作频繁。</li>
<li>区间查找可能需要返回上层节点重复遍历，IO操作繁琐。</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163215.png"  alt=""></p>
<p>B+Tree：非叶子结点不存储data，只存储索引（减小内存占用，这样可以多读入一些节点）</p>
<p>叶子结点包含所有索引字段，存放所有的data</p>
<p>叶子结点用指针连接，提高区间访问的性能（不用回到上层节点再往下找）</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163232.png"  alt=""></p>
<p>b+树相比于b树的查询优势：</p>
<ol>
<li>一次IO只能加载一个磁盘页（对应一个节点），b树的节点是由key,data组成的，而b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，可以使得树更加矮胖；</li>
<li>b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；B+树的每次查询过程中，都需要遍历从根节点到叶子节点的某条路径。所有关键字的查询路径长度相同，导致每一次查询的效率相当。</li>
<li>对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历，如下两图：</li>
</ol>
<p>总结：B+Tree 既减少查询次数又提供了很好的范围查询</p>
<h3 id="3-4-MyISAM和InnoDB索引实现"><a href="#3-4-MyISAM和InnoDB索引实现" class="headerlink" title="3.4 MyISAM和InnoDB索引实现"></a>3.4 MyISAM和InnoDB索引实现</h3><p>索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的。它们实现的都是<strong>B+Tree索引模型</strong></p>
<h4 id="3-4-1-MyISAM实现"><a href="#3-4-1-MyISAM实现" class="headerlink" title="3.4.1 MyISAM实现"></a>3.4.1 MyISAM实现</h4><p>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</p>
<ul>
<li><p>MyISAM的主索引图：索引文件的每个<strong>数据域存储指向数据文件的指针</strong>(每个索引指向了数据地址)</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163301.png"  alt=""></p>
</li>
<li><p>MyISAM的辅索引：索引文件的<strong>每个数据域存储指向数据文件的指针</strong>(每个索引指向了数据地址)，辐索引不用保证唯一性。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163331.png"  alt=""></p>
</li>
</ul>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分</p>
<h4 id="3-4-2-InnoDB实现"><a href="#3-4-2-InnoDB实现" class="headerlink" title="3.4.2 InnoDB实现"></a>3.4.2 InnoDB实现</h4><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，<strong>表数据文件本身就是按B+Tree组织的一个索引结构</strong>，这棵树的叶结点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>Innodb的主索引图: <strong>叶子节点存储数据本身</strong></p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163412.png"  alt=""></p>
<p>Innodb的辐索引图: <strong>叶子结点存储主键的值</strong>。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163434.png"  alt=""></p>
<h3 id="3-5-其他关于索引的问题"><a href="#3-5-其他关于索引的问题" class="headerlink" title="3.5 其他关于索引的问题"></a>3.5 其他关于索引的问题</h3><p><strong>主键索引三问</strong>：</p>
<ul>
<li><p>为什么非主键索引结构叶子节点存储的是主键值？</p>
<p>一是保证一致性，更新数据的时候只需要更新主键索引树；二是节省存储空间。</p>
</li>
<li><p>为什么推荐InnoDB表必须有主键？</p>
<p>保证会有主键索引树的存在（因为数据存放在主键索引树上面），如果没有mysql会自己生成一个rowid作为自增的主键主键索引</p>
</li>
<li><p>为什么推荐使用整型的自增主键？</p>
<p>一是方便查找比较，二是新增数据的时候只需要在最后加入，不会大规模调整树结构，如果是UUID的话，大小不好比较，新增的时候也极有可能在中间插入数据，会导致树结构大规调整，造成插入数据变慢。</p>
</li>
</ul>
<p><strong>索引合并</strong>：使用多个单列索引组合搜索</p>
<p><strong>索引覆盖</strong>：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖</p>
<p><strong>索引下推</strong>：如果没有索引下推优化（或称ICP优化），当进行索引查询时，首先根据索引来查找记录，然后再根据where条件来过滤记录；在支持ICP优化后，MySQL会在取出索引的同时，判断是否可以进行where条件过滤，也就是说提前执行where的部分过滤操作，在某些场景下，可以大大减少回表次数，从而提升整体性能。</p>
<p>对于user_table表，我们现在有（username,age）联合索引<br> 如果现在有一个需求，查出名称中以“张”开头且年龄小于等于10的用户信息，语句C如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">and</span> age &gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>



<p> 语句C有两种执行可能：</p>
<ol>
<li><p>根据（username,age）联合索引查询所有满足名称以“张”开头的索引，然后回表查询出相应的全行数据，然后再筛选出满足年龄小于等于10的用户数据。</p>
</li>
<li><p>根据（username,age）联合索引查询所有满足名称以“张”开头的索引，然后直接再筛选出年龄小于等于10的索引，之后再回表查询全行数据。</p>
</li>
</ol>
<p>明显的，第二种方式需要回表查询的全行数据比较少，这就是mysql的索引下推</p>
<p>注意点：<br> 1、innodb引擎的表，索引下推只能用于二级索引。</p>
<blockquote>
<p>就像之前提到的，innodb的主键索引树叶子结点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。</p>
</blockquote>
<p>2、索引下推一般可用于所求查询字段（select列）不是/不全是联合索引的字段，查询条件为多条件查询且查询条件子句（where/order by）字段全是联合索引。</p>
<blockquote>
<p>假设表t有联合索引（a,b）,下面语句可以使用索引下推提高效率<br> select * from t where a &gt; 2 and b &gt; 10;</p>
</blockquote>
<p><strong>索引失效</strong></p>
<ol>
<li>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</li>
<li>使用查询的时候遵循mysql组合索引的”<strong>最左前缀</strong>“规则，假设现在有组合索引（a，b，c），查询语句就只能是<code>a=1</code>或<code>a=1and b=1</code>或<code>a=1 and b=1 and c=1</code>。这里有两点需要注意<ul>
<li><code>a=1 and b=1</code>和<code>b=1 and a=1</code>一样，没有区别，都会使用索引。<code>b = 1</code>和<code>b = 1 and c=1</code>无法使用索引</li>
<li>组合索引（a，b，c）的最左前缀是a；组合索引（c，b，a）的最左前缀是c，最左前缀和表字段顺序无关。在组合索引中，如果where查询条件中某个列使用了范围查询（不管%在哪），则其右边的所有列都无法使用索引优化查询</li>
</ul>
</li>
<li>like查询以%开头</li>
<li>如果<strong>列类型是字符串，那一定要在条件中将数据使用引号引用</strong>起来,否则不使用索引</li>
<li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li>
<li>需要将打算加索引的列设置为 not  NULL，否则将导致引擎放弃使用索引而进行全表扫描。</li>
<li><strong>索引列不能是表达式的一部分，也不能作为函数的参数</strong>，否则无法使用索引查询</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_test <span class="keyword">WHERE</span> user_name = <span class="keyword">concat</span>(user_name, <span class="string">'fei'</span>);</span><br></pre></td></tr></table></figure>









<h2 id="四、事务"><a href="#四、事务" class="headerlink" title="四、事务"></a>四、事务</h2><h3 id="4-1-特性ACID"><a href="#4-1-特性ACID" class="headerlink" title="4.1 特性ACID"></a>4.1 特性ACID</h3><p>原子性(Atomicity)：指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做</p>
<p>一致性(Consistency)：事务使得系统从一个一致的状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度，也导致了事务的不同隔离级别。</p>
<p>隔离性(Isolation)：事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>持久性(Durability)：事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p>
<h3 id="4-2-实现原理"><a href="#4-2-实现原理" class="headerlink" title="4.2 实现原理"></a>4.2 实现原理</h3><p><strong>首先思考事务想要做到什么效果？</strong></p>
<p>按我理解，无非是要做到<strong>可靠性</strong>以及<strong>并发处理</strong></p>
<p>可靠性：数据库要保证当insert或update操作时抛异常或者数据库crash的时候需要保障数据的操作前后的一致，想要做到这个，我需要知道我修改之前和修改之后的状态，所以就有了undo log和redo log。</p>
<p>并发处理：也就是说当多个并发请求过来，并且其中有一个请求是对数据修改操作的时候会有影响，为了避免读到脏数据，所以需要对事务之间的读写进行隔离，至于隔离到啥程度得看业务系统的场景了，实现这个就得用MySQL 的隔离级别。</p>
<h4 id="4-2-1-原子性"><a href="#4-2-1-原子性" class="headerlink" title="4.2.1 原子性"></a>4.2.1 原子性</h4><p>要实现原子性，即需要保证操作要么全做，要么全不做，对于做到一半无法完成的操作就应该进行回滚。那么就需要有日志文件记录数据被修改前的信息，这样才能达到回到修改前的状态，undo log 回滚日志就实现了这一需求。</p>
<h4 id="4-2-2-持久性"><a href="#4-2-2-持久性" class="headerlink" title="4.2.2 持久性"></a>4.2.2 持久性</h4><p>事务一旦提交，对数据库的改变就该是永久性的。那么由于数据是存放在磁盘中的，如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。但如果MySQL宕机了，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p>
<p>于是引入redo log，当数据修改时，除了修改Buffer Pool中的数据，还会<strong>在redo log记录这次操作</strong>；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，<strong>重启时可以读取redo log中的数据，对数据库进行恢复</strong>。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p>
<h4 id="4-2-3-隔离性"><a href="#4-2-3-隔离性" class="headerlink" title="4.2.3 隔离性"></a>4.2.3 隔离性</h4><p>事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。主要考虑读写操作下的隔离，可以分为两个方面：</p>
<ul>
<li>(一个事务)<strong>写</strong>操作对(另一个事务)<strong>写</strong>操作的影响：<strong>锁机制</strong>保证隔离性</li>
<li>(一个事务)<strong>写</strong>操作对(另一个事务)<strong>读</strong>操作的影响：<strong>MVCC</strong>保证隔离性</li>
</ul>
<h4 id="4-2-4-一致性"><a href="#4-2-4-一致性" class="headerlink" title="4.2.4 一致性"></a>4.2.4 一致性</h4><p>事务执行结束后，<strong>数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</strong></p>
<p>实现一致性的措施包括：</p>
<ul>
<li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li>
<li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li>
<li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</li>
</ul>
<h4 id="4-2-5-并发一致性问题"><a href="#4-2-5-并发一致性问题" class="headerlink" title="4.2.5 并发一致性问题"></a>4.2.5 并发一致性问题</h4><ul>
<li><p>丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；</p>
</li>
<li><p>脏读（Dirty Read）：读到了其他事务未提交的脏数据。</p>
</li>
<li><p>不可重复读（Nonrepeatable Read）：由于其他事务对某个记录进行了 <strong>修改(更新或删除)</strong> 而导致当前事务对某个数据的两次读取结果不同。</p>
</li>
<li><p>幻读（Phantom Read）：由于其他事务 <strong>插入了一条记录</strong> 而导致当前事务对某个数据的两次读取结果不同。对于幻读必须加表级锁，防止在这个表中新增一条数据。</p>
</li>
</ul>
<h4 id="4-2-6-隔离级别"><a href="#4-2-6-隔离级别" class="headerlink" title="4.2.6 隔离级别"></a>4.2.6 隔离级别</h4><p>MySQL数据的四种隔离级别：</p>
<ol>
<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>
<li>Read committed (读已提交)：可避免脏读的发生。</li>
<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>
<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>
</ol>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>可以处理的并发问题</th>
<th>描述</th>
<th>实现</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td><code>SERIALIZABLE</code> (串行化)</td>
<td>全部</td>
<td>事务一个接着一个执行</td>
<td>三级 + GAP 锁</td>
<td>1星</td>
</tr>
<tr>
<td><code>REPEATABLE READ</code> (可重复读)</td>
<td>脏读，不可重复读</td>
<td>所有被 SELECT 的数据不能被修改</td>
<td>三级</td>
<td>2星</td>
</tr>
<tr>
<td><code>READ COMMITTED</code> (读已提交)</td>
<td>脏读</td>
<td>不可重复读，幻读</td>
<td>二级</td>
<td>3星</td>
</tr>
<tr>
<td><code>READ UNCOMMITTED</code> (读未提交)</td>
<td>无</td>
<td>允许其他事务读取未提交的数据</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。<br>像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，<br>所以平时选用何种隔离级别应该根据实际情况。<br>在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506163536.png"  alt=""></p>
<p><img src="/" class="lazyload" data-src="https://images2015.cnblogs.com/blog/476810/201608/476810-20160802234328293-1886690666.png"  alt=""></p>
<p>可以看到，隔离级别只解决了脏读、不可重复读、幻读问题，却没解决丢失修改的问题。至于为什么隔离性级别不解决丢失修改，我猜是有更好的解决方案吧。这也就解释了为什么“<strong>防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决</strong>”</p>
<p>repeatable read能解决脏读和不可重复读，但不能解决丢失修改。</p>
<h2 id="五、锁机制"><a href="#五、锁机制" class="headerlink" title="五、锁机制"></a>五、锁机制</h2><p>按锁的粒度划分：表级锁、行级锁、页级锁</p>
<p>按锁级别划分：共享锁、排它锁、意向锁</p>
<p>按加锁方式划分：自动锁、显示锁</p>
<p>按使用方式划分：乐观锁、悲观锁</p>
<p><strong>行锁、页锁、表锁</strong></p>
<p>锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</p>
<p>按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。<strong>表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源，因此在锁定数据较多情况下使用表锁可以节省大量资源</strong>。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p>
<p><strong>行级锁</strong>：行级锁分为共享锁和排他锁。行级锁是MySQL中锁定粒度最细的锁。InnoDB引擎支持行级锁和表级锁，<strong>只有在通过索引检索数据的时候，才使用行级锁</strong>，否就使用表级锁。行级锁开销大，加锁慢，锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p>
<p><strong>表级锁：</strong>表级锁分为表共享锁和表独占锁。表级锁开销小，加锁快，锁定粒度大，发生锁冲突最高，并发度最低</p>
<p><strong>页级锁：</strong>页级锁是MySQL中锁定粒度<strong>介于行级锁和表级锁中间的一种锁</strong>。<strong>表级锁速度快，但冲突多，行级冲突少，但速度慢</strong>。所以取了折中的页级，一次<strong>锁定相邻的一组记录</strong>。BDB支持页级锁。开销和加锁时间界于表锁和行锁之间；会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p>
<p><strong>触发行锁、表锁时机</strong></p>
<ul>
<li><p>如果where条件中只用到索引项，则加的是行锁；否则加的是表锁。比如说主键索引，唯一索引和聚簇索引等。如果sql的where是全表扫描的，想加行锁也爱莫能助。</p>
</li>
<li><p>行锁和表锁对我们编程有什么影响，要在where中尽量只用索引项，否则就会触发表锁。</p>
</li>
</ul>
<p>innodb一般情况下走索引或者主键更新都是锁行，其余都是锁表，在并发的时候可以加select for update手工锁</p>
<h3 id="5-1-什么是乐观锁和悲观锁"><a href="#5-1-什么是乐观锁和悲观锁" class="headerlink" title="5.1 什么是乐观锁和悲观锁"></a>5.1 什么是乐观锁和悲观锁</h3><ul>
<li>悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于数据更新比较频繁的场景；</li>
<li>乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于读多写少的场景。</li>
</ul>
<p>乐观锁的实现方式有：</p>
<ul>
<li>加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；</li>
<li>先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新</li>
</ul>
<h3 id="5-2-事务隔离是怎么实现的？有哪些锁？"><a href="#5-2-事务隔离是怎么实现的？有哪些锁？" class="headerlink" title="5.2  事务隔离是怎么实现的？有哪些锁？"></a>5.2  事务隔离是怎么实现的？有哪些锁？</h3><p>事务隔离通过排他锁、共享锁实现</p>
<ul>
<li><p>排他写锁（X 锁）：若事务 T对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其他任何事物都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁为止。</p>
</li>
<li><p>共享读锁（S 锁）：若事务 T 对数据 A 加上 S 锁，则事务 T 可以读 A 但是不能修改 A，其他事务只能对 A 加 S 锁而不能加 X 锁，直到 T 释放 A 上的 S 锁为止。所以它的最主要作用是阻塞 X 锁。</p>
</li>
<li><p>意向锁：事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。所以需要<strong>意向锁，当事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，其他事务B要加锁的时候先判断表是否已被其他事务用表锁锁表，发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞</strong>。</p>
</li>
</ul>
<h3 id="5-3-三级加锁协议（可解决脏读和不可重复读）"><a href="#5-3-三级加锁协议（可解决脏读和不可重复读）" class="headerlink" title="5.3 三级加锁协议（可解决脏读和不可重复读）"></a>5.3 三级加锁协议（可解决脏读和不可重复读）</h3><p><strong>一级加锁协议（无法避免脏读、不可重复读）</strong>–读不加锁，写加X锁</p>
<ul>
<li>如果只对数据进行读操作，不需要加锁。</li>
<li>如果对数据进行写操作，需要加 X 锁直至事务结束。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。</li>
</ul>
<p><strong>二级加锁协议（可避免脏读，无法避免不可重复读）</strong>–读加S锁（读完释放），写加X锁</p>
<p>在一级加锁协议的基础上，添加操作：事务 T 在读取数据 R 前要对 R 加上 S 锁，<strong>读完之后即可释放 S 锁</strong>，无需等待事务结束。</p>
<p><strong>三级加锁协议（可避免脏读、不可重复读）</strong>–读加S锁（事务结束释放），写加X锁</p>
<p><strong>基本与二级加锁协议相同</strong>，只是 S 锁加上之后要等到<strong>事务结束才能释放</strong>。</p>
<p><strong>3 种锁：</strong></p>
<ul>
<li>Record Locks（记录锁）：在索引记录上加锁。</li>
<li>Gap Locks（间隙锁）：在索引记录之间加锁，或者在第一个索引记录之前加锁，或者在最后一个索引记录之后加锁，可避免幻读。</li>
<li>Next-Key Locks：在索引记录上加锁，并且在索引记录之前的间隙加锁。它相当于是 Record Locks 与 Gap Locks 的一个结合。</li>
</ul>
<h2 id="六、MVCC"><a href="#六、MVCC" class="headerlink" title="六、MVCC"></a>六、MVCC</h2><h3 id="6-1-什么是MVCC"><a href="#6-1-什么是MVCC" class="headerlink" title="6.1 什么是MVCC"></a>6.1 什么是MVCC</h3><p>多版本并发控制 ，是现代数据库（包括 <code>MySQL</code> 、 <code>Oracle</code> 、 <code>PostgreSQL</code> 等）引擎实现中常用的<strong>处理读写冲突的手段</strong>， 目的在于提高数据库高并发场景下的吞吐性能 。</p>
<p><strong>作用</strong>：</p>
<p>如此一来不同的事务在并发过程中， <code>SELECT</code> 操作可以不加锁而是通过 <code>MVCC</code> 机制读取指定的版本历史记录，并通过一些手段保证保证读取的记录值符合事务所处的隔离级别，从而<strong>解决并发场景下的读写冲突</strong>。</p>
<h3 id="6-2-什么是读写冲突"><a href="#6-2-什么是读写冲突" class="headerlink" title="6.2 什么是读写冲突"></a>6.2 什么是读写冲突</h3><p>先来看下什么是版本冲突，也就知道为什么要引入MVCC解决版本冲突问题。</p>
<p>设想一种常见，事务A <code>begin</code>之后修改了数据但还没commit或者rollback这段时间内，事务B <code>select</code>查找数据，那事务B读到的值应该是什么？很明显，理论上来说，既然还没提交，那肯定B读到的是旧数据，但<strong>在不同隔离级别下，B读到的值也会不一样</strong>！</p>
<ol>
<li>如果事务 <code>B</code> 的隔离级别是读未提交（RU），那么两次读取均读取到 <code>x</code> 的最新值，即 <code>20</code> 。</li>
<li>如果事务 <code>B</code> 的隔离级别是读已提交（RC），那么第一次读取到旧值 <code>10</code> ，第二次因为事务 <code>A</code> 已经提交，则读取到新值 20。</li>
<li>如果事务 <code>B</code> 的隔离级别是可重复读或者串行（RR，S），则两次均读到旧值 <code>10</code> ，不论事务 <code>A</code> 是否已经提交。</li>
</ol>
<p>可见在不同的隔离级别下，数据库通过 <code>MVCC</code> 和隔离级别，让事务之间并行操作遵循了某种规则，来保证单个事务内前后数据的一致性。</p>
<p><strong>注意</strong>：这里大家会发现RR和S隔离级别读到的数据是一样的，但实现原理不同，RR是由MVCC实现，S由加锁来实现。因此，MVCC用于RC和RR级别下。</p>
<h3 id="6-3-为什么需要MVCC"><a href="#6-3-为什么需要MVCC" class="headerlink" title="6.3 为什么需要MVCC"></a>6.3 为什么需要MVCC</h3><h4 id="6-3-1-事务所带来的问题"><a href="#6-3-1-事务所带来的问题" class="headerlink" title="6.3.1 事务所带来的问题"></a>6.3.1 事务所带来的问题</h4><p><code>InnoDB</code> 相比 <code>MyISAM</code> 有两大特点，一是支持事务二是支持行级锁，事务的引入带来了一些新的挑战。相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况：</p>
<ol>
<li>更新丢失（ <code>Lost Update</code> ）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 —— 最后的更新覆盖了其他事务所做的更新。如何避免这个问题呢，最好在一个事务对数据进行更改但还未提交时，其他事务不能访问修改同一个数据。</li>
<li>脏读（ <code>Dirty Reads</code> ）：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些尚未提交的脏数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做 “脏读” 。</li>
<li>不可重复读（ <code>Non-Repeatable Reads</code> ）：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</li>
<li>幻读（ <code>Phantom Reads</code> ）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为 “幻读” 。</li>
</ol>
<p>以上是并发事务过程中会存在的问题，解决更新丢失可以交给应用，但是后三者需要数据库提供<strong>事务间的隔离机制</strong>来解决。 <strong>实现隔离机制的方法主要有两种</strong> ：</p>
<ol>
<li>加读写锁</li>
<li>一致性快照读，即 <code>MVCC</code></li>
</ol>
<p>但本质上，隔离级别是一种在并发性能和并发产生的副作用间的妥协，通常数据库均倾向于采用 <code>Weak Isolation</code> </p>
<p>总结来说，使用MVCC的开销比使用加读写锁的开销来的小，所以需要MVCC。</p>
<h3 id="6-4-MVCC原理"><a href="#6-4-MVCC原理" class="headerlink" title="6.4 MVCC原理"></a>6.4 MVCC原理</h3><h4 id="6-4-1-行记录结构"><a href="#6-4-1-行记录结构" class="headerlink" title="6.4.1 行记录结构"></a>6.4.1 行记录结构</h4><p>InnoDB 中 <code>MVCC</code> 的实现方式为：每一行记录都有两个隐藏列： <code>DATA_TRX_ID</code> 、 <code>DATA_ROLL_PTR</code></p>
<table>
<thead>
<tr>
<th>column1</th>
<th>column1</th>
<th>……</th>
<th>DATA_TRX_ID</th>
<th>DATA_ROLL_PTR</th>
<th>DB_ROW_ID</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>name</td>
<td></td>
<td>事务版本号</td>
<td>上一版本地址</td>
<td>没有主键的时候才出现</td>
</tr>
</tbody></table>
<p>实现MVCC，最主要的就是 <code>DATA_TRX_ID</code> 、 <code>DATA_ROLL_PTR</code>这两个隐藏列</p>
<p><strong>DATA_TRX_ID</strong>：记录最近更新这条行记录的 <code>事务 ID</code> ，大小为 <code>6</code> 个字节。也就是标记是哪个事务修改的。</p>
<p><strong>DATA_ROLL_PTR</strong>：表示指向该行回滚段 <code>（rollback segment）</code> 的指针，大小为 <code>7</code> 个字节， <code>InnoDB</code> 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在 <code>undo</code> 中都通过链表的形式组织。</p>
<p>这里需要大家了解了上文讲到的事务原子性由undo log记录更改前的版本来实现这部分知识。</p>
<h4 id="6-4-2-版本链"><a href="#6-4-2-版本链" class="headerlink" title="6.4.2 版本链"></a>6.4.2 版本链</h4><p>在多个事务并行操作某行数据的情况下，不同事务对该行数据的 UPDATE 会产生多个版本，然后通过回滚指针组织成一条 <code>Undo Log</code> 链，这节我们通过一个简单的例子来看一下 <code>Undo Log</code> 链是如何组织的， <code>DATA_TRX_ID</code> 和 <code>DATA_ROLL_PTR</code> 两个参数在其中又起到什么样的作用。</p>
<p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/hhf443/blog-graph/img/20200506150324.png"  alt=""></p>
<p>事务200的操作过程</p>
<ol>
<li>对 column1 = 20 的这行记录加排他锁</li>
<li>将column1 = 20 的这一行原本的值原样拷贝到 undo log 中</li>
<li>修改该行的值这时产生一个新版本，更新 <code>DATA_TRX_ID</code> 为修改记录的事务 <code>ID</code> ，将 <code>DATA_ROLL_PTR</code> 指向刚刚拷贝到 <code>undo log</code> 链中的旧版本记录。如果对同一行记录执行连续的 <code>UPDATE</code> ， <code>Undo Log</code> 会组成一个链表，遍历这个链表可以看到这条记录的变迁。</li>
<li>记录 <code>redo log</code> ，包括 <code>undo log</code> 中的修改</li>
</ol>
<p>那么 <code>INSERT</code> 和 <code>DELETE</code> 会怎么做呢？其实相比 <code>UPDATE</code> 这二者很简单， <code>INSERT</code> 会产生一条新纪录，它的 <code>DATA_TRX_ID</code> 为当前插入记录的事务 <code>ID</code> ； <code>DELETE</code> 某条记录时可看成是一种特殊的 <code>UPDATE</code> ，其实是软删，真正执行删除操作会在 <code>commit</code> 时， <code>DATA_TRX_ID</code> 则记录下删除该记录的事务 <code>ID</code> 。</p>
<h4 id="6-4-3-ReadView"><a href="#6-4-3-ReadView" class="headerlink" title="6.4.3 ReadView"></a>6.4.3 ReadView</h4><p>上面说了，通过版本链的方式控制不同隔离级别下，并发事务读到的版本不一样。那事务怎么知道自己能读哪些版本呢？这就由ReadView来解决，读已提交（RC）和可重复读（RR）的生成ReadView策略是不一样的。</p>
<p>ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是<strong>begin了还未提交的事务</strong>。<strong>通过这个列表来判断记录的某个版本是否对当前事务可见</strong>。</p>
<p>总结：ReadView记录了当前活跃着的读写事务id的列表，称之为 <code>m_ids</code>，它有个[ up_limit_id，low_limit_id]范围（是的，没写错，up_limit_id就是左界限），这个左右界限就决定了哪些版本的数据是事务可以访问的。</p>
<ol>
<li>如果被访问版本的 <code>trx_id</code> 小于 <code>m_ids</code> 中的最小值 <code>up_limit_id</code> ，说明生成该版本的事务在 <code>ReadView</code> 生成前就已经提交了，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的 <code>trx_id</code> 大于 <code>m_ids</code> 列表中的最大值 <code>low_limit_id</code> ，说明生成该版本的事务在生成 <code>ReadView</code> 后才生成，所以该版本不可以被当前事务访问。需要根据 <code>Undo Log</code> 链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性。</li>
<li>如果被访问版本的 <code>trx_id</code> 属性值在 <code>m_ids</code> 列表中最大值和最小值之间（包含），那就需要判断一下 <code>trx_id</code> 的值是不是在 <code>m_ids</code> 列表中。如果在，说明创建 <code>ReadView</code> 时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的 <code>DB_TRX_ID</code> 再从头计算一次可见性；如果不在，说明创建 <code>ReadView</code> 时生成该版本的事务已经被提交，该版本可以被访问。</li>
<li>此时经过一系列判断我们已经得到了这条记录相对 <code>ReadView</code> 来说的可见结果。此时，如果这条记录的 <code>delete_flag</code> 为 <code>true</code> ，说明这条记录已被删除，不返回。否则说明此记录可以安全返回给客户端。</li>
</ol>
<p>举个例子吧</p>
<p>假设当前列表里的事务id为[80,100]。</p>
<ul>
<li>如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。</li>
<li>如果你要访问的记录版本的事务id为90, 发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。</li>
<li>如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。</li>
</ul>
<p>这些记录都是去版本链里面找的，先找最近记录，如果最近这一条记录事务id不符合条件，不可见的话，再去找上一个版本再比较当前事务的id和这个版本事务id看能不能访问，以此类推直到返回可见的版本或者结束。</p>
<h4 id="6-4-4-不同隔离级别下的ReadView"><a href="#6-4-4-不同隔离级别下的ReadView" class="headerlink" title="6.4.4 不同隔离级别下的ReadView"></a>6.4.4 不同隔离级别下的ReadView</h4><p>大致的流程就像上面说讲的那样，但是根据不同的ReadView也会有不一样的结果。这是因为<strong>已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView</strong></p>
<ol>
<li><p>RC下的MVCC判断流程</p>
<p>当事务 <code>A</code> 未提交时，事务 <code>B</code> 进行查询，假设事务 <code>B</code> 的事务 <code>ID</code> 为 <code>300</code> ，此时生成 <code>ReadView</code> 的 <code>m_ids</code> 为 [200，300]，而最新版本的 <code>trx_id</code> 为 <code>200</code> ，处于 <code>m_ids</code> 中，则该版本记录不可被访问，查询版本链得到上一条记录的 trx_id 为 <code>100</code> ，小于 <code>m_ids</code> 的最小值 <code>200</code> ，因此可以被访问，此时事务 <code>B</code> 就查询到值 <code>10</code> 而非 <code>20</code> 。</p>
<p>待事务 <code>A</code> 提交之后，事务 <code>B</code> 进行查询，此时生成的 <code>ReadView</code> 的 <code>m_ids</code> 为 [300]，而最新的版本记录中 <code>trx_id</code> 为 <code>200</code> ，小于 <code>m_ids</code> 的最小值 <code>300</code> ，因此可以被访问到，此时事务 <code>B</code> 就查询到 <code>20</code> 。</p>
</li>
<li><p>RR下的MVCC判断流程</p>
<p>如果在 <code>RR</code> 隔离级别下，为什么事务 <code>B</code> 前后两次均查询到 <code>10</code> 呢？ <code>RR</code> 下生成 <code>ReadView</code> 是在事务开始时，m_ids 为 [200,300]，后面不发生变化，因此即使事务 <code>A</code> 提交了， <code>trx_id</code> 为 <code>200</code> 的记录依旧处于 <code>m_ids</code> 中，不能被访问，只能访问版本链中的记录 <code>10</code> 。</p>
</li>
</ol>
<h2 id="EXPLAIN查询"><a href="#EXPLAIN查询" class="headerlink" title="EXPLAIN查询"></a>EXPLAIN查询</h2><p>+—-+————-+——-+——-+——————-+———+———+——-+——<br>| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |<br>+—-+————-+——-+——-+——————-+———+———+——-+——</p>
<p>下面对各个属性进行了解：</p>
<p>1、id：这是SELECT的查询序列号</p>
<p>2、select_type：select_type就是select的类型，可以有以下几种：</p>
<blockquote>
<p>SIMPLE：简单SELECT(不使用UNION或子查询等)</p>
<p>PRIMARY：最外面的SELECT</p>
<p>UNION：UNION中的第二个或后面的SELECT语句</p>
<p>DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询</p>
<p>UNION RESULT：UNION的结果。</p>
<p>SUBQUERY：子查询中的第一个SELECT</p>
<p>DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询</p>
<p>DERIVED：导出表的SELECT(FROM子句的子查询)</p>
</blockquote>
<p>3、table：显示这一行的数据是关于哪张表的</p>
<p>4、<strong>type</strong>：这列最重要，显示了<strong>连接使用了哪种类别,有无使用索引</strong>，是使用Explain命令分析性能瓶颈的关键项之一。</p>
<blockquote>
<p>结果值从好到坏依次是：</p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。</p>
</blockquote>
<p>5、<strong>possible_keys</strong>：列指出MySQL能使用哪个索引在该表中找到行</p>
<p>6、<strong>key</strong>：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL</p>
<p>7、key_len：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好</p>
<p>8、ref：显示使用哪个列或常数与key一起从表中选择行。</p>
<p>9、rows：显示MySQL认为它执行查询时必须检查的行数。</p>
<p>10、<strong>Extra</strong>：<strong>包含MySQL解决查询的详细信息</strong>，也是关键参考项之一。</p>
<blockquote>
<p>Distinct<br>一旦MYSQL找到了与行相联合匹配的行，就不再搜索了</p>
<p>Not exists<br>MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了</p>
<p>Range checked for each</p>
<p>Record（index map:#）<br>没有找到理想的索引，因此对于从前面表中来的每一 个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一</p>
<p>Using filesort<br>看 到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来 排序全部行</p>
<p>Using index<br>列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表 的全部的请求列都是同一个索引的部分的时候</p>
<p>Using temporary<br>看到这个的时候，查询需要优化了。这 里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上</p>
<p>Using where<br>使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index， 这就会发生，或者是查询有问题</p>
</blockquote>
<h3 id="drop、truncate和delete的区别"><a href="#drop、truncate和delete的区别" class="headerlink" title="drop、truncate和delete的区别"></a>drop、truncate和delete的区别</h3><p>drop直接释放表占用的内存，会删除表结构和数据，不记录到日志中，不能回滚。</p>
<p>TRUNCATE 一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p>
<p>DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">hofe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hofe.work/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL%E5%9F%BA%E7%A1%80%E7%AF%87/">http://hofe.work/2020/04/28/数据库/通过面试题学MySQL基础篇/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hofe.work" target="_blank">Hofe's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/hofe/graph/raw/master/img/20200625150059.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/01/%E5%B7%A5%E5%85%B7/Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8flow%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/"><img class="prev_cover lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200625145730.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Markdown中使用flow绘制流程图</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/28/%E7%BD%91%E7%BB%9C/Https%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"><img class="next_cover lazyload" data-src="https://gitee.com/hofe/graph/raw/master/img/20200625153041.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HTTPS协议详解</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/06/数据库/通过面试题学MySQL进阶篇/" title="MySQL学习笔记进阶篇"><img class="relatedPosts_cover lazyload"data-src="https://gitee.com/hofe/graph/raw/master/img/20200625152804.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-06</div><div class="relatedPosts_title">MySQL学习笔记进阶篇</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'b5cpWE77l9G2Um3MSdyvAmh6-gzGzoHsz',
  appKey: 'LCxOgpdF1CrQ1Xb4dnNrg6OH',
  placeholder: '留下你的足迹吧',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'en',
  recordIP: true,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By hofe</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="http://hofe.work/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = false;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script></body></html>