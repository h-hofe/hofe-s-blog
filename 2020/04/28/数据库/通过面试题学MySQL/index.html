<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>通过面试题学MySQL | Hofe's blog</title><meta name="description" content="通过面试题学MySQL"><meta name="author" content="hofe"><meta name="copyright" content="hofe"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="http://ta.qq.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="JoP76yOkd4"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="通过面试题学MySQL"><meta name="twitter:description" content="通过面试题学MySQL"><meta name="twitter:image" content="http://hofe.work/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="通过面试题学MySQL"><meta property="og:url" content="http://hofe.work/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL/"><meta property="og:site_name" content="Hofe's blog"><meta property="og:description" content="通过面试题学MySQL"><meta property="og:image" content="http://hofe.work/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://hofe.work/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL/"><link rel="prev" title="通过面试题学分布式" href="http://hofe.work/2020/04/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6%E5%88%86%E5%B8%83%E5%BC%8F/"><link rel="next" title="通过面试题学Java多线程" href="http://hofe.work/2020/04/27/Java/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-4088686103083456',
  enable_page_level_ads: 'true'
});</script><script src="https://tajs.qq.com/stats?sId=66539762" charset="UTF-8"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://hofe.work","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">19</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-clock-o"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments-o"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fa fa-camera"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-info-circle"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、常见面试题"><span class="toc-text">一、常见面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、存储引擎"><span class="toc-text">二、存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-什么是存储引擎"><span class="toc-text">2.1 什么是存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-存储引擎分类"><span class="toc-text">2.2 存储引擎分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-MyISAM和InnoDB的区别"><span class="toc-text">2.3 MyISAM和InnoDB的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、索引"><span class="toc-text">三、索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-索引是什么"><span class="toc-text">3.1 索引是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1为什么要使用索引"><span class="toc-text">3.1.1为什么要使用索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-索引分类"><span class="toc-text">3.2 索引分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-索引数据结构"><span class="toc-text">3.3 索引数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-MyISAM和InnoDB索引实现"><span class="toc-text">3.4 MyISAM和InnoDB索引实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-MyISAM实现"><span class="toc-text">3.4.1 MyISAM实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-InnoDB实现"><span class="toc-text">3.4.2 InnoDB实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-其他关于索引的问题"><span class="toc-text">3.5 其他关于索引的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、事务"><span class="toc-text">四、事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-特性ACID"><span class="toc-text">4.1 特性ACID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-实现原理"><span class="toc-text">4.2 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-原子性"><span class="toc-text">4.2.1 原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-持久性"><span class="toc-text">4.2.2 持久性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-隔离性"><span class="toc-text">4.2.3 隔离性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-一致性"><span class="toc-text">4.2.4 一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并发一致性问题"><span class="toc-text">并发一致性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#隔离级别"><span class="toc-text">隔离级别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁机制-行锁与表锁"><span class="toc-text">锁机制-行锁与表锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是乐观锁和悲观锁"><span class="toc-text">什么是乐观锁和悲观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC"><span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-MVCC"><span class="toc-text">什么是 MVCC</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hofe's blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-clock-o"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-comments-o"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/album/"><i class="fa-fw fa fa-camera"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-info-circle"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">通过面试题学MySQL</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-28 16:37:45"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-28</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-04-30 16:50:57"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-30</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">7.2k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 22 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="一、常见面试题"><a href="#一、常见面试题" class="headerlink" title="一、常见面试题"></a>一、常见面试题</h2><p>mysql 有那些存储引擎，有哪些区别（innodb 与myisam 的区别？ ）</p>
<p>mysql 索引在什么情况下会失效 </p>
<p>mysql 的索引模型 </p>
<p>数据库为什么用B+树。联合索引特点</p>
<p>mysql 主从同步怎么搞的？分哪几个过程？如果有一台新机器要加到从机里，怎么个过程。    </p>
<p>乐观锁与悲观锁的区别？    </p>
<p>binlog 日志是 master 推的还是 salve 来拉的？</p>
<p>数据库如何实现并发；可重复读是什么；有一段代码，两个session，判断结果是什么（和重复读有关）；数据库用什么实现可重复读。</p>
<h2 id="二、存储引擎"><a href="#二、存储引擎" class="headerlink" title="二、存储引擎"></a>二、存储引擎</h2><h3 id="2-1-什么是存储引擎"><a href="#2-1-什么是存储引擎" class="headerlink" title="2.1 什么是存储引擎"></a>2.1 什么是存储引擎</h3><blockquote>
<p>MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p>
</blockquote>
<h3 id="2-2-存储引擎分类"><a href="#2-2-存储引擎分类" class="headerlink" title="2.2 存储引擎分类"></a>2.2 存储引擎分类</h3><p>使用<code>show engines;</code>可查看引擎种类，有<strong>MEMORY</strong>、<strong>ARCHIVE</strong>、<strong>MERGE</strong>等等，主要的是<strong>MyISAM</strong>和<strong>InnoDB</strong>。</p>
<p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20180919170259760?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F1c2hhbWluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"  alt=""></p>
<h3 id="2-3-MyISAM和InnoDB的区别"><a href="#2-3-MyISAM和InnoDB的区别" class="headerlink" title="2.3 MyISAM和InnoDB的区别"></a>2.3 MyISAM和InnoDB的区别</h3><ol>
<li><p>存储结构</p>
<ul>
<li><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。 .frm文件存储表定义，数据文件的扩展名为.MYD(MYD)，索引文件的扩展名是.MYI(MYIndex)。</p>
</li>
<li><p>InnoDB:所在的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p>
</li>
</ul>
</li>
<li><p>存储空间</p>
<ul>
<li><p>MyISAM:可被压缩，存储空间较小。支持三种不同的存储格式：静态表、动态表、压缩表。</p>
</li>
<li><p>InnoDB:需要更多的内存和存储，它会在主内存中建立其专用的<strong>缓冲池用于高速缓冲数据和索引</strong>。</p>
</li>
</ul>
</li>
<li><p>事物支持</p>
<ul>
<li><p>MyISAM:强调的是<strong>性能</strong>，每次查询具有原子性，其执行速度比Innodb类型更快，但是不提供事物支持。</p>
</li>
<li><p>InnoDB:提供事务支持。具有提交（commit）、回滚（rollback）和崩溃修复能力（crach recovery capabilities）的事务安全（transaction-safe ACID compliant）型表。</p>
</li>
</ul>
</li>
<li><p>CURD操作</p>
<ul>
<li><p>MyISAM: 如果执行大量的select, MyISAM是更好的选择。（因为没有支持行级锁），在增删的时候需要锁定整个表格，效率会低一些。相关的是</p>
</li>
<li><p>InnoDB:如果你的数据执行大量的insert或update，出于性能方面的考虑，应该使用InnoDB表。innoDB支持行级锁，删除插入的时候只需要锁定该行就行，效率较高。但delete from table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p>
</li>
</ul>
</li>
<li><p>外键</p>
<ul>
<li><p>MyISAM: 不支持。</p>
</li>
<li><p>InoDB:支持。</p>
</li>
</ul>
</li>
<li><p>索引</p>
<ul>
<li><p>MyISAM:采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。支持全文索引和空间索引。</p>
</li>
<li><p>InnoDB:主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问主键索引。</p>
</li>
</ul>
</li>
</ol>
<h2 id="三、索引"><a href="#三、索引" class="headerlink" title="三、索引"></a>三、索引</h2><h3 id="3-1-索引是什么"><a href="#3-1-索引是什么" class="headerlink" title="3.1 索引是什么"></a>3.1 索引是什么</h3><p>索引(Index)是帮助MySQL高效获取数据的数据结构。可以简单理解为：<strong>快速查找排好序的一种数据结构</strong>，可以提高数据检索的效率，降低数据库的IO成本</p>
<h4 id="3-1-1为什么要使用索引"><a href="#3-1-1为什么要使用索引" class="headerlink" title="3.1.1为什么要使用索引"></a>3.1.1为什么要使用索引</h4><p>查询数据时需要从磁盘中全表扫描读取数据，会遇上两个问题</p>
<ul>
<li>数据量过大的时候，从磁盘中读数据到内存，内存是否有足够容量存放</li>
<li>如果表非常大，那么我们不可能一次将所有的数据读到内存，需要分多次读取磁盘，而操作磁盘相对于内存来说是一个非常耗时的操作</li>
</ul>
<p><strong>优点</strong>：</p>
<ol>
<li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性</li>
<li>大大加快数据的查询速度</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加</p>
</li>
<li><p>索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值</p>
</li>
<li><p>当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。</p>
</li>
</ol>
<p><strong>使用原则</strong>：</p>
<p>通过上面说的优点和缺点，我们应该可以知道，并不是每个字段度设置索引就好，也不是索引越多越好，而是需要自己合理的使用。</p>
<p><strong>加在哪些列上？</strong></p>
<ol>
<li>在经<strong>常需要搜索的列</strong>上，可以加快搜索的速度；</li>
<li>在作为<strong>主键的列</strong>上，强制该列的唯一性和组织表中数据的排列结构；</li>
<li>在经常用在<strong>连接</strong>的列上，这些列主要是一些外键，可以加快连接的速度；</li>
<li>在经常需要根据<strong>范围进行搜索</strong>的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>
<li>在经常需要<strong>排序的列</strong>上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>在经常使用在<strong>WHERE子句中的列</strong>上面创建索引，加快条件的判断速度</li>
</ol>
<p><strong>不该加在哪些列上？</strong></p>
<ol>
<li>对于那些在<strong>查询中很少使用</strong>或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>
<li>对于那些只有<strong>很少数据值的列</strong>也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>
<li>第三，对于那些定义为<strong>text, image和bit数据类型</strong>的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>第四，当<strong>修改性能远远大于检索性能时，不应该创建索引</strong>。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li>
</ol>
<h3 id="3-2-索引分类"><a href="#3-2-索引分类" class="headerlink" title="3.2 索引分类"></a>3.2 索引分类</h3><p>按照<strong>索引形式</strong>不同可以分为：</p>
<ul>
<li><p>普通索引：仅加速查询</p>
</li>
<li><p>唯一索引：加速查询 + 列值唯一（可以有null）</p>
</li>
<li><p>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</p>
</li>
<li><p>全文索引：对文本的内容进行分词，进行搜索</p>
</li>
<li><p>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于<strong>索引合并</strong></p>
</li>
</ul>
<p>按照<strong>索引实现方式</strong>不同可以分为：</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
<th>特点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>B+ Tree索引</td>
<td>使用B+ Tree作为底层实现</td>
<td>对树进行搜索，查找速度快分为聚簇索引和非聚簇索引</td>
<td>查找、排序、分组</td>
</tr>
<tr>
<td>哈希索引</td>
<td>使用哈希作为底层实现</td>
<td>无法用于排序与分组只支持精确查找，时间复杂度为O(1)</td>
<td>当索引值使用的频繁时，会在B+ Tree索引之上再创建一个哈希索引</td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引使用倒排索引实现，记录着关键词到其所在文档的映射</td>
<td></td>
<td>查找文本中的关键词</td>
</tr>
<tr>
<td>空间索引</td>
<td></td>
<td>从所有维度来索引数据</td>
<td>用于地理数据存储</td>
</tr>
</tbody></table>
<h3 id="3-3-索引数据结构"><a href="#3-3-索引数据结构" class="headerlink" title="3.3 索引数据结构"></a>3.3 索引数据结构</h3><p>数据库<strong>索引是存储在磁盘</strong>上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应<strong>索引树的节点</strong>）。所以我们要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。</p>
<p>通过对比各种数据结构的特点，可以回答为什么要用B+Tree作为数据库的索引的问题</p>
<p><strong>和其他数据结构对比来看</strong>：</p>
<p>二叉树：如果数据是单边增长的情况，那么出现的就是和链表一样的数据结构了，树高度大。</p>
<p>红黑树：在二叉树的基础上多了树平衡，也叫二叉平衡树，不像二叉树那样极端的情况会往一个方向发展，但数据量大的话，红黑树的深度会很深，也就是说深度不可控，这样一来查找数据还是会很耗时。</p>
<p>Hash表：通过hash函数计算出数据映射位置，相比较于红黑树，hash可以固定“深度”，且映射到磁盘存储引用，但是 hash 还是有些不足：只能用于精确查找的场景，无法进行范围查询。</p>
<p>BTree：每个节点是一个二元数组，存放着key，value， 从左到右递增排列。节点之间存放着指向这相应区间范围内的节点。然而也存在着一些缺陷：</p>
<ol>
<li>在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。造成IO操作频繁。</li>
<li>区间查找可能需要返回上层节点重复遍历，IO操作繁琐。</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20181014145506497?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhaWp1bnNlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"  alt=""></p>
<p>B+Tree：非叶子结点不存储data，只存储索引（减小内存占用，这样可以多读入一些节点）</p>
<p>叶子结点包含所有索引字段，存放所有的data</p>
<p>叶子结点用指针连接，提高区间访问的性能（不用回到上层节点再往下找）</p>
<p><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20181014173425183?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhaWp1bnNlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"  alt=""></p>
<p>b+树相比于b树的查询优势：</p>
<ol>
<li>一次IO只能加载一个磁盘页（对应一个节点），b树的节点是由key,data组成的，而b+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，可以使得树更加矮胖；</li>
<li>b+树查询必须查找到叶子节点，b树只要匹配到即可不用管元素位置，因此b+树查找更稳定（并不慢）；</li>
<li>对于范围查找来说，b+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历，如下两图：</li>
</ol>
<p>总结：B+Tree 既减少查询次数又提供了很好的范围查询</p>
<h3 id="3-4-MyISAM和InnoDB索引实现"><a href="#3-4-MyISAM和InnoDB索引实现" class="headerlink" title="3.4 MyISAM和InnoDB索引实现"></a>3.4 MyISAM和InnoDB索引实现</h3><p>索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的。它们实现的都是<strong>B+Tree索引模型</strong></p>
<h4 id="3-4-1-MyISAM实现"><a href="#3-4-1-MyISAM实现" class="headerlink" title="3.4.1 MyISAM实现"></a>3.4.1 MyISAM实现</h4><p>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</p>
<ul>
<li><p>MyISAM的主索引图：索引文件的每个<strong>数据域存储指向数据文件的指针</strong>(每个索引指向了数据地址)</p>
<img src="/" class="lazyload" data-src="https://img2018.cnblogs.com/blog/1266222/201810/1266222-20181002092110599-2117319768.png"  alt="img" style="zoom:50%;" />
</li>
<li><p>MyISAM的辅索引：索引文件的<strong>每个数据域存储指向数据文件的指针</strong>(每个索引指向了数据地址)，辐索引不用保证唯一性。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<img src="/" class="lazyload" data-src="https://img2018.cnblogs.com/blog/1266222/201810/1266222-20181002092240212-858513347.png"  alt="img" style="zoom:50%;" />

</li>
</ul>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分</p>
<h4 id="3-4-2-InnoDB实现"><a href="#3-4-2-InnoDB实现" class="headerlink" title="3.4.2 InnoDB实现"></a>3.4.2 InnoDB实现</h4><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，<strong>表数据文件本身就是按B+Tree组织的一个索引结构</strong>，这棵树的叶结点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>Innodb的主索引图: <strong>叶子节点存储数据本身</strong></p>
<img src="/" class="lazyload" data-src="https://img2018.cnblogs.com/blog/1266222/201810/1266222-20181002094955943-831346533.png"  alt="img" style="zoom:50%;" />

<p>Innodb的辐索引图: <strong>叶子结点存储主键的值</strong>。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p>
<img src="/" class="lazyload" data-src="https://img2018.cnblogs.com/blog/1266222/201810/1266222-20181002095028620-445399058.png"  alt="img" style="zoom:50%;" />





<h3 id="3-5-其他关于索引的问题"><a href="#3-5-其他关于索引的问题" class="headerlink" title="3.5 其他关于索引的问题"></a>3.5 其他关于索引的问题</h3><p><strong>主键索引三问</strong>：</p>
<ul>
<li><p>为什么非主键索引结构叶子节点存储的是主键值？</p>
</li>
<li><p>一是保证一致性，更新数据的时候只需要更新主键索引树，二是节省存储空间。</p>
</li>
<li><p>为什么推荐InnoDB表必须有主键？</p>
</li>
<li><p>保证会有主键索引树的存在（因为数据存放在主键索引树上面），如果没有mysql会自己生成一个rowid作为自增的主键主键索引</p>
</li>
<li><p>为什么推荐使用整型的自增主键？</p>
<p>一是方便查找比较，而是新增数据的时候只需要在最后加入，不会大规模调整树结构，如果是UUID的话，大小不好比较，新增的时候也极有可能在中间插入数据，会导致树结构大规调整，造成插入数据变慢。</p>
</li>
</ul>
<p><strong>索引合并</strong>：使用多个单列索引组合搜索</p>
<p><strong>索引覆盖</strong>：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖</p>
<p><strong>索引下推</strong>：如果没有索引下推优化（或称ICP优化），当进行索引查询时，首先根据索引来查找记录，然后再根据where条件来过滤记录；在支持ICP优化后，MySQL会在取出索引的同时，判断是否可以进行where条件过滤，也就是说提前执行where的部分过滤操作，在某些场景下，可以大大减少回表次数，从而提升整体性能。</p>
<p>对于user_table表，我们现在有（username,age）联合索引<br> 如果现在有一个需求，查出名称中以“张”开头且年龄小于等于10的用户信息，语句C如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_table <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">and</span> age &gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>



<p> 语句C有两种执行可能：</p>
<ol>
<li><p>根据（username,age）联合索引查询所有满足名称以“张”开头的索引，然后回表查询出相应的全行数据，然后再筛选出满足年龄小于等于10的用户数据。</p>
</li>
<li><p>根据（username,age）联合索引查询所有满足名称以“张”开头的索引，然后直接再筛选出年龄小于等于10的索引，之后再回表查询全行数据。</p>
</li>
</ol>
<p>明显的，第二种方式需要回表查询的全行数据比较少，这就是mysql的索引下推</p>
<p>注意点：<br> 1、innodb引擎的表，索引下推只能用于二级索引。</p>
<blockquote>
<p>就像之前提到的，innodb的主键索引树叶子结点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。</p>
</blockquote>
<p>2、索引下推一般可用于所求查询字段（select列）不是/不全是联合索引的字段，查询条件为多条件查询且查询条件子句（where/order by）字段全是联合索引。</p>
<blockquote>
<p>假设表t有联合索引（a,b）,下面语句可以使用索引下推提高效率<br> select * from t where a &gt; 2 and b &gt; 10;</p>
</blockquote>
<p><strong>索引失效</strong></p>
<ol>
<li><p>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</p>
</li>
<li><p>使用查询的时候遵循mysql组合索引的”<strong>最左前缀</strong>“规则，假设现在有组合索引（a，b，c），查询语句就只能是<code>a=1</code>或<code>a=1and b=1</code>或<code>a=1 and b=1 and c=1</code>。这里有两点需要注意</p>
<ul>
<li><code>a=1 and b=1</code>和<code>b=1 and a=1</code>一样，没有区别，都会使用索引。<code>b = 1</code>和<code>b = 1 and c=1</code>无法使用索引</li>
<li>组合索引（a，b，c）的最左前缀是a；组合索引（c，b，a）的最左前缀是c，最左前缀和表字段顺序无关。在组合索引中，如果where查询条件中某个列使用了范围查询（不管%在哪），则其右边的所有列都无法使用索引优化查询</li>
</ul>
</li>
<li><p>like查询以%开头</p>
</li>
<li><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</p>
</li>
<li><p>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</p>
</li>
<li><p>索引列不能是表达式的一部分，也不能作为函数的参数，否则无法使用索引查询</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_test <span class="keyword">WHERE</span> user_name = <span class="keyword">concat</span>(user_name, <span class="string">'fei'</span>);</span><br></pre></td></tr></table></figure>







<h2 id="四、事务"><a href="#四、事务" class="headerlink" title="四、事务"></a>四、事务</h2><h3 id="4-1-特性ACID"><a href="#4-1-特性ACID" class="headerlink" title="4.1 特性ACID"></a>4.1 特性ACID</h3><p>原子性(Atomicity)：指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做</p>
<p>一致性(Consistency)：事务使得系统从一个一致的状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度，也导致了事务的不同隔离级别。</p>
<p>隔离型(Isolation)：事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>持久性(Durability)：事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p>
<h3 id="4-2-实现原理"><a href="#4-2-实现原理" class="headerlink" title="4.2 实现原理"></a>4.2 实现原理</h3><p><strong>首先思考事务想要做到什么效果？</strong></p>
<p>按我理解，无非是要做到<strong>可靠性</strong>以及<strong>并发处理</strong></p>
<p>可靠性：数据库要保证当insert或update操作时抛异常或者数据库crash的时候需要保障数据的操作前后的一致，想要做到这个，我需要知道我修改之前和修改之后的状态，所以就有了undo log和redo log。</p>
<p>并发处理：也就是说当多个并发请求过来，并且其中有一个请求是对数据修改操作的时候会有影响，为了避免读到脏数据，所以需要对事务之间的读写进行隔离，至于隔离到啥程度得看业务系统的场景了，实现这个就得用MySQL 的隔离级别。</p>
<h4 id="4-2-1-原子性"><a href="#4-2-1-原子性" class="headerlink" title="4.2.1 原子性"></a>4.2.1 原子性</h4><p>要实现原子性，即需要保证操作要么全做，要么全不做，对于做到一半无法完成的操作就应该进行回滚。那么就需要有日志文件记录数据被修改前的信息，这样才能达到回到修改前的状态，undo log 回滚日志就实现了这一需求。</p>
<h4 id="4-2-2-持久性"><a href="#4-2-2-持久性" class="headerlink" title="4.2.2 持久性"></a>4.2.2 持久性</h4><p>事务一旦提交，对数据库的改变就该是永久性的。那么由于数据是存放在磁盘中的，如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。但如果MySQL宕机了，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p>
<p>于是引入redo log，当数据修改时，除了修改Buffer Pool中的数据，还会<strong>在redo log记录这次操作</strong>；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，<strong>重启时可以读取redo log中的数据，对数据库进行恢复</strong>。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p>
<h4 id="4-2-3-隔离性"><a href="#4-2-3-隔离性" class="headerlink" title="4.2.3 隔离性"></a>4.2.3 隔离性</h4><p>事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。主要考虑读写操作下的隔离，可以分为两个方面：</p>
<ul>
<li>(一个事务)<strong>写</strong>操作对(另一个事务)<strong>写</strong>操作的影响：<strong>锁机制</strong>保证隔离性</li>
<li>(一个事务)<strong>写</strong>操作对(另一个事务)<strong>读</strong>操作的影响：<strong>MVCC</strong>保证隔离性</li>
</ul>
<h4 id="4-2-4-一致性"><a href="#4-2-4-一致性" class="headerlink" title="4.2.4 一致性"></a>4.2.4 一致性</h4><p>事务执行结束后，<strong>数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</strong></p>
<p>实现一致性的措施包括：</p>
<ul>
<li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li>
<li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li>
<li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</li>
</ul>
<h4 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h4><ul>
<li><p>丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；</p>
</li>
<li><p>脏读（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致；</p>
</li>
<li><p>不可重复读（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改；</p>
</li>
<li><p>幻读（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入删除操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且需要是插入操作或删除）</p>
</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>MySQL数据的四种隔离级别：</p>
<ol>
<li><p>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p>
</li>
<li><p>Read committed (读已提交)：可避免脏读的发生。</p>
</li>
<li><p>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</p>
</li>
<li><p>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</p>
</li>
</ol>
<p>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。<br>像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，<br>所以平时选用何种隔离级别应该根据实际情况。<br>在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p>
<p><img src="/" class="lazyload" data-src="https://img2018.cnblogs.com/blog/1174710/201901/1174710-20190128201034603-681355962.png"  alt=""></p>
<h2 id="锁机制-行锁与表锁"><a href="#锁机制-行锁与表锁" class="headerlink" title="锁机制-行锁与表锁"></a><strong>锁机制</strong>-<strong>行锁与表锁</strong></h2><p>锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</p>
<p>按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p>
<h3 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h3><ul>
<li>悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于数据更新比较频繁的场景；</li>
<li>乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于读多写少的场景。</li>
</ul>
<p>乐观锁的实现方式有：</p>
<ul>
<li>加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；</li>
<li>先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新</li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h2><p>在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务常用的处理读写冲突的手段， 目的在于提高数据库高并发场景下的吞吐性能 。</p>
<p>如此一来不同的事务在并发过程中， <code>SELECT</code> 操作可以不加锁而是通过 <code>MVCC</code> 机制读取指定的版本历史记录，并通过一些手段保证保证读取的记录值符合事务所处的隔离级别，从而解决并发场景下的读写冲突。</p>
<p>实现原理</p>
<p><code>InnoDB</code> 中 <code>MVCC</code> 的实现方式为：每一行记录都有两个隐藏列： <code>DATA_TRX_ID</code> 、 <code>DATA_ROLL_PTR</code> （如果没有主键，则还会多一个隐藏的主键列）</p>
<p><img src="/" class="lazyload" data-src="https://img1.3s78.com/codercto/bfa89998d4dea1104d7954d6ab03350e"  alt=""></p>
<p><strong>DATA_TRX_ID</strong>：记录最近更新这条行记录的 <code>事务 ID</code> ，大小为 <code>6</code> 个字节</p>
<p><strong>DATA_ROLL_PTR</strong>：表示指向该行回滚段 <code>（rollback segment）</code> 的指针，大小为 <code>7</code> 个字节， <code>InnoDB</code> 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在 <code>undo</code> 中都通过链表的形式组织。</p>
<h3 id="什么是-MVCC"><a href="#什么是-MVCC" class="headerlink" title="什么是 MVCC"></a>什么是 MVCC</h3><p>多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储创建版本号和删除版本号。</p>
<pre><code>创建版本号：创建一个数据行时的事务版本号（事务版本号：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会自动递增）；
删除版本号：删除操作时的事务版本号；
各种操作：
插入操作时，记录创建版本号；
删除操作时，记录删除版本号；
更新操作时，先记录删除版本号，再新增一行记录创建版本号；    查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）</code></pre><p>通过版本号减少了锁的争用，提高了系统性能；可以实现提交读和可重复读两种隔离级别，未提交读无需使用MVCC</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">hofe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hofe.work/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL/">http://hofe.work/2020/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6MySQL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hofe.work" target="_blank">Hofe's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6%E5%88%86%E5%B8%83%E5%BC%8F/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">通过面试题学分布式</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/27/Java/%E9%80%9A%E8%BF%87%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">通过面试题学Java多线程</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'b5cpWE77l9G2Um3MSdyvAmh6-gzGzoHsz',
  appKey: 'LCxOgpdF1CrQ1Xb4dnNrg6OH',
  placeholder: '留下你的足迹吧',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'en',
  recordIP: true,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By hofe</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="http://hofe.work/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = false;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script></body></html>